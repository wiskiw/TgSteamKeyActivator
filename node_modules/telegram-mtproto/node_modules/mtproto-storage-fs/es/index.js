function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Bluebird from 'bluebird';
import { readJson, outputJson, ensureFileSync, readJsonSync, outputJsonSync } from 'fs-extra';
import { watch } from 'chokidar';

import Logger from 'mtproto-logger';
const log = Logger`reactive-storage`;

export class FileStorage {

  constructor(filepath, data) {
    this.allowRead = true;
    this.readInterval = 2e3;
    this.timeoutID = -Infinity;

    this.allowReadNow = () => {
      this.allowRead = true;
    };

    this.reReadProtect = () => {
      this.allowRead = false;
      clearTimeout(this.timeoutID);
      this.timeoutID = setTimeout(this.allowReadNow, this.readInterval);
    };

    this.filepath = filepath.substr(-5) === '.json' ? filepath : `${filepath}.json`;
    if (data != null) this.data = data;

    // process.on('beforeExit', () => {
    //   watcher.close()
    // })
    this.init();
  }
  init() {
    var _this = this;

    //TODO make async
    const data = ensureSync(this.filepath);
    if (!this.data) this.data = data;
    const watcher = watch(this.filepath, {
      useFsEvents: false,
      disableGlobbing: true,
      persistent: false,
      atomic: true
    });
    watcher.on('change', (() => {
      var _ref = _asyncToGenerator(function* (stats) {
        log('change')(stats);
        log('allowRead')(_this.allowRead);
        if (_this.allowRead) {
          const result = yield readJson(_this.filepath);
          _this.data = result;
        }
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    })());
  }


  save() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.reReadProtect();
      yield outputJson(_this2.filepath, _this2.data, { spaces: 2 });
      _this2.reReadProtect();
    })();
  }

  get(key) {
    const data = this.data[key];
    log('get', `key ${key}`)(data);
    return Bluebird.resolve(data);
  }

  set(key, val) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.data[key] = val;
      log('set', `key ${key}`)(val);
      yield _this3.save();
    })();
  }

  remove(...keys) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const data = _this4.data;
      for (const key of keys) delete data[key];
      log('remove')(keys);
      yield _this4.save();
    })();
  }

  clear() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      _this5.data = {};
      log('clear')('ok');
      yield _this5.save();
    })();
  }
}

function ensureSync(filepath) {
  ensureFileSync(filepath);
  let fileData = null;
  try {
    fileData = readJsonSync(filepath);
  } catch (err) {
    log(`init`, `error`)(err);
  }
  if (fileData === null) {
    outputJsonSync(filepath, {});
    fileData = {};
  }
  return fileData;
}

export { FileStorage as Storage };

export default FileStorage;
//# sourceMappingURL=index.js.map