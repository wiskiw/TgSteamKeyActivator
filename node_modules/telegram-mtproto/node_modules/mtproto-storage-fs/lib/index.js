'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Storage = exports.FileStorage = undefined;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _fsExtra = require('fs-extra');

var _chokidar = require('chokidar');

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const log = _mtprotoLogger2.default`reactive-storage`;

class FileStorage {

  constructor(filepath, data) {
    this.allowRead = true;
    this.readInterval = 2e3;
    this.timeoutID = -Infinity;

    this.allowReadNow = () => {
      this.allowRead = true;
    };

    this.reReadProtect = () => {
      this.allowRead = false;
      clearTimeout(this.timeoutID);
      this.timeoutID = setTimeout(this.allowReadNow, this.readInterval);
    };

    this.filepath = filepath.substr(-5) === '.json' ? filepath : `${filepath}.json`;
    if (data != null) this.data = data;

    // process.on('beforeExit', () => {
    //   watcher.close()
    // })
    this.init();
  }
  init() {
    var _this = this;

    //TODO make async
    const data = ensureSync(this.filepath);
    if (!this.data) this.data = data;
    const watcher = (0, _chokidar.watch)(this.filepath, {
      useFsEvents: false,
      disableGlobbing: true,
      persistent: false,
      atomic: true
    });
    watcher.on('change', (() => {
      var _ref = _asyncToGenerator(function* (stats) {
        log('change')(stats);
        log('allowRead')(_this.allowRead);
        if (_this.allowRead) {
          const result = yield (0, _fsExtra.readJson)(_this.filepath);
          _this.data = result;
        }
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    })());
  }


  save() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.reReadProtect();
      yield (0, _fsExtra.outputJson)(_this2.filepath, _this2.data, { spaces: 2 });
      _this2.reReadProtect();
    })();
  }

  get(key) {
    const data = this.data[key];
    log('get', `key ${key}`)(data);
    return _bluebird2.default.resolve(data);
  }

  set(key, val) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.data[key] = val;
      log('set', `key ${key}`)(val);
      yield _this3.save();
    })();
  }

  remove(...keys) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const data = _this4.data;
      for (const key of keys) delete data[key];
      log('remove')(keys);
      yield _this4.save();
    })();
  }

  clear() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      _this5.data = {};
      log('clear')('ok');
      yield _this5.save();
    })();
  }
}

exports.FileStorage = FileStorage;
function ensureSync(filepath) {
  (0, _fsExtra.ensureFileSync)(filepath);
  let fileData = null;
  try {
    fileData = (0, _fsExtra.readJsonSync)(filepath);
  } catch (err) {
    log(`init`, `error`)(err);
  }
  if (fileData === null) {
    (0, _fsExtra.outputJsonSync)(filepath, {});
    fileData = {};
  }
  return fileData;
}

exports.Storage = FileStorage;
exports.default = FileStorage;
//# sourceMappingURL=index.js.map