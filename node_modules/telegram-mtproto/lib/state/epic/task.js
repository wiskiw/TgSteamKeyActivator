'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receiveResponse = exports.onTaskEnd = undefined;

var _most = require('most');

var _mezza = require('mezza');

var _mezza2 = _interopRequireDefault(_mezza);

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

var _error = require('../../error');

var _action = require('../action');

var _signal = require('../signal');

var _jsonError = require('../../util/json-error');

var _jsonError2 = _interopRequireDefault(_jsonError);

var _either = require('../../util/either');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var log = _mtprotoLogger2.default`epic-task`;

var requestMap = id => _signal.networker.map(net => net.get(id)).map(net => net && net.requestMap).startWith({}).filter(val => val != null).skipRepeats();

var onTaskEnd = exports.onTaskEnd = action => action.thru(e => _action.API.CALL_RESULT.stream(e)).thru(_signal.whenActive).map(val => val.payload).combine((val, map) => Object.assign({}, val, {
  messages:
  // console.log(val.result),
  // console.log('map', map),
  chooseType(map)(val.result)
}), requestMap(2))
// .tap(val => console.log('val.messages', val.messages))
.map(val => Object.assign({}, val, {
  messages: Array.isArray(val.messages) ? val.messages.map(detectErrors) : val.messages
})).map(_action.API.DONE_REQUEST);

var receiveResponse = exports.receiveResponse = action => action.thru(e => _action.NET.RECEIVE_RESPONSE.stream(e)).thru(_signal.whenActive).map(val => val.payload).map((() => {
  var _ref = _asyncToGenerator(function* ({ result, thread, message, noResponseMsgs }) {
    return {
      result: yield thread.parseResponse(result.data),
      noResponseMsgs,
      thread,
      message
    };
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
})()).thru(_most.awaitPromises).map((() => {
  var _ref2 = _asyncToGenerator(function* ({ result, thread, message, noResponseMsgs }) {
    yield thread.requestPerformer(message, noResponseMsgs, result);
    return {
      result,
      thread,
      message
    };
  });

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
})()).thru(_most.awaitPromises).map(_action.API.CALL_RESULT).recoverWith(err => (0, _most.of)(_action.NET.NETWORK_ERROR((0, _jsonError2.default)(err))).delay(15));

class MsgId {
  constructor(real, box, req, map) {
    this.real = real;
    this.box = box;
    this.req = req;
    this.linked = map[req];
  }
  static container(box, map) {
    return new MsgId(box, box, box, map);
  }
  static single(real, req, map) {
    return new MsgId(real, real, req, map);
  }
  static of(real, box, req, map) {
    return new MsgId(real, box, req, map);
  }
}

var chooseType = map => (0, _mezza2.default)({
  Single: val => isObject(val) && isObject(val.response) && val.response._ === 'rpc_result',
  Container: val => isObject(val) && isObject(val.response) && val.response._ === 'msg_container'
}, {
  Single(val) {
    var type = val.response._;
    var data = val.response;
    if (isObject(val.response.result)) {
      type = val.response.result._;
      data = val.response.result;
    }
    return [{
      ids: MsgId.single(val.messageID, val.response.req_msg_id, map),
      type,
      meta: {},
      data
    }];
  },
  Container(val) {
    var container = {
      ids: MsgId.container(val.messageID, map),
      type: 'msg_container',
      meta: {},
      data: val.response.messages.map(msg => msg.msg_id)
    };
    var result = [container];
    for (var _iterator = val.response.messages, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref3 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref3 = _i.value;
      }

      var message = _ref3;

      var isSingleMessage = message.body._ === 'rpc_result';
      var _ids = isSingleMessage ? MsgId.of(message.msg_id, val.messageID, message.body.req_msg_id, map) : MsgId.of(message.msg_id, val.messageID, message.msg_id, map);
      var _data = isSingleMessage ? message.body.result : message.body;
      result.push({
        ids: _ids,
        type: message.body._,
        meta: {},
        data: _data
      });
    }
    return result;
  },
  _: val => ({ type: 'Other', val })
});

function detectErrors(message) {
  var type = message.type;
  if (type === 'rpc_error') {
    //$FlowIssue
    var _data2 = _error.RpcApiError.of(message.data);
    //$FlowIssue
    return (0, _either.Left)(Object.assign({}, message, { data: _data2, type }));
  } else {
    //$FlowIssue
    var cast = message;
    return (0, _either.Right)(cast);
  }
}

function isObject(obj) {
  return typeof obj === 'object' && obj != null;
}
//# sourceMappingURL=task.js.map