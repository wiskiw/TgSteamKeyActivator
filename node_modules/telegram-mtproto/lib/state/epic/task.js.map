{"version":3,"sources":["../../../src/state/epic/task.js"],"names":["log","requestMap","id","map","net","get","startWith","filter","val","skipRepeats","onTaskEnd","action","thru","e","CALL_RESULT","stream","payload","combine","messages","chooseType","result","Array","isArray","detectErrors","DONE_REQUEST","receiveResponse","RECEIVE_RESPONSE","thread","message","noResponseMsgs","parseResponse","data","requestPerformer","recoverWith","err","NETWORK_ERROR","delay","MsgId","constructor","real","box","req","linked","container","single","of","Single","isObject","response","_","Container","type","ids","messageID","req_msg_id","meta","msg","msg_id","isSingleMessage","body","push","cast","obj"],"mappings":"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","file":"task.js","sourcesContent":["//@flow\n\nimport { Stream, of, awaitPromises } from 'most'\nimport choose from 'mezza'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`epic-task`\n\nimport { RpcApiError } from '../../error'\nimport { NET, API } from '../action'\nimport { whenActive, networker } from '../signal'\nimport jsonError from '../../util/json-error'\nimport { Left, Right, Either } from '../../util/either'\n\nexport type TaskEndData = {\n  messages: Either<UniMessageR, UniMessageL>[]\n}\n\nconst requestMap = (id: number) => networker\n  .map(net => net.get(id))\n  .map(net => net && net.requestMap)\n  .startWith({})\n  .filter(val => val != null)\n  .skipRepeats()\n\nexport const onTaskEnd = (action: Stream<any>) => action\n  .thru(e => API.CALL_RESULT.stream(e))\n  .thru(whenActive)\n  .map(val => val.payload)\n  .combine((val, map) => ({\n    ...val,\n    messages: (\n      // console.log(val.result),\n      // console.log('map', map),\n      chooseType(map)(val.result))\n  }), requestMap(2))\n  // .tap(val => console.log('val.messages', val.messages))\n  .map(val => ({\n    ...val,\n    messages: Array.isArray(val.messages)\n      ? val.messages.map(detectErrors)\n      : val.messages\n  }))\n  .map(API.DONE_REQUEST)\n\nexport const receiveResponse = (action: Stream<any>) => action\n  .thru(e => NET.RECEIVE_RESPONSE.stream(e))\n  .thru(whenActive)\n  .map(val => val.payload)\n  .map(async({ result, thread, message, noResponseMsgs }) => ({\n    result: await thread.parseResponse(result.data),\n    noResponseMsgs,\n    thread,\n    message\n  }))\n  .thru(awaitPromises)\n  .map(async({ result, thread, message, noResponseMsgs }) => {\n    await thread.requestPerformer(message, noResponseMsgs, result)\n    return {\n      result,\n      thread,\n      message\n    }\n  })\n  .thru(awaitPromises)\n  .map(API.CALL_RESULT)\n  .recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))).delay(15))\n\nclass MsgId {\n  real: string\n  box: string\n  req: string\n  linked: string | void\n  constructor(real: string, box: string, req: string, map: { [req: string]: string }) {\n    this.real = real\n    this.box = box\n    this.req = req\n    this.linked = map[req]\n  }\n  static container(box: string, map: { [req: string]: string }) {\n    return new MsgId(box, box, box, map)\n  }\n  static single(real: string, req: string, map: { [req: string]: string }) {\n    return new MsgId(real, real, req, map)\n  }\n  static of(real: string, box: string, req: string, map: { [req: string]: string }) {\n    return new MsgId(real, box, req, map)\n  }\n}\n\ntype TaskResult<Response> = {\n  messageID: string,\n  seqNo: number,\n  response: Response,\n}\n\ntype SingleMessage = {\n  _: 'rpc_result',\n  req_msg_id: string,\n  result: Object,\n}\n\ntype ContainerMessage = {\n  _: 'msg_container',\n  messages: InnerMessage[]\n}\n\ntype InnerMessage = {\n  _: 'message',\n  msg_id: string,\n  seqno: number,\n  body: SingleMessage | Object,\n}\n\ntype UniMessageL = {\n  ids: MsgId,\n  type: 'rpc_error',\n  meta: {[key: string]: mixed},\n  data: RpcApiError,\n}\n\ntype UniMessageR = {\n  ids: MsgId,\n  type: 'rpc_result' | 'msg_container' | 'message',\n  meta: {[key: string]: mixed},\n  data: Object | string[],\n}\n\ntype UniMessage = {\n  ids: MsgId,\n  //$FlowIssue\n  type: 'rpc_result' | 'msg_container' | 'message' | 'rpc_error',\n  meta: {[key: string]: mixed},\n  data: Object | string[] | RpcApiError,\n}\n\ntype TaskResultRaw = TaskResult<SingleMessage | ContainerMessage>\n\ntype ChooseType =\n  (map: { [req: string]: string }) =>\n    (val: TaskResultRaw) =>\n      UniMessage[]\n\nconst chooseType: ChooseType = (map) => choose({\n  Single: (val: ?TaskResultRaw) =>\n    isObject(val)\n    && isObject(val.response)\n    && val.response._ === 'rpc_result',\n  Container: (val: ?TaskResultRaw) =>\n    isObject(val)\n    && isObject(val.response)\n    && val.response._ === 'msg_container',\n}, {\n  Single(val: TaskResult<SingleMessage>): UniMessage[] {\n    let type = val.response._\n    let data = val.response\n    if (isObject(val.response.result)) {\n      type = val.response.result._\n      data = val.response.result\n    }\n    return [{\n      ids : MsgId.single(val.messageID, val.response.req_msg_id, map),\n      type,\n      meta: {},\n      data,\n    }]\n  },\n  Container(val: TaskResult<ContainerMessage>): UniMessage[] {\n    const container = {\n      ids : MsgId.container(val.messageID, map),\n      type: 'msg_container',\n      meta: {},\n      data: val.response.messages.map(msg => msg.msg_id),\n    }\n    const result: UniMessage[] = [container]\n    for (const message of val.response.messages) {\n      const isSingleMessage = message.body._ === 'rpc_result'\n      const ids = isSingleMessage\n        ? MsgId.of(message.msg_id, val.messageID, message.body.req_msg_id, map)\n        : MsgId.of(message.msg_id, val.messageID, message.msg_id, map)\n      const data = isSingleMessage\n        ? message.body.result\n        : message.body\n      result.push({\n        ids,\n        type: message.body._,\n        meta: {},\n        data\n      })\n    }\n    return result\n  },\n  _: (val) => ({ type: 'Other', val }),\n})\n\nfunction detectErrors(message: UniMessage): Either<UniMessageR, UniMessageL> {\n  const type = message.type\n  if (type === 'rpc_error') {\n    //$FlowIssue\n    const data = RpcApiError.of(message.data)\n    //$FlowIssue\n    return Left({ ...message, data, type })\n  } else {\n    //$FlowIssue\n    const cast: UniMessageR = message\n    return Right(cast)\n  }\n}\n\nfunction isObject(obj: mixed): boolean %checks {\n  return (\n    typeof obj === 'object'\n    && obj != null\n  )\n}\n"]}