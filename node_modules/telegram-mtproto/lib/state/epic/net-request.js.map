{"version":3,"sources":["../../../src/state/epic/net-request.js"],"names":["log","makeApiBytes","message","thread","ctx","startMaxLength","body","length","uid","writer","serverSalt","sessionID","encryptedBytes","opts","bytes","authKey","authKeyUint8","onNewRequest","action","thru","NEW_REQUEST","stream","combine","data","homeDc","skipRepeatsWith","old","fresh","payload","map","CALL_TASK","onNewTask","tap","val","netReq","invoke","filter","netRequest","SEND","options","responseType","msgKey","rest","request","byteLength","mtBytes","authKeyID","url","dcMap","dcID","noResponseMsgs","result","post","RECEIVE_RESPONSE","recoverWith","err","NETWORK_ERROR","delay"],"mappings":";;;;;;;AAEA;;AACA;;AAEA;;;;AAGA;;AACA;;AACA;;AACA;;;;AACA;;;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAVA,IAAMA,MAAM,uBAAO,aAAnB;;AAWA;;AAEA,SAASC,YAAT,CAAsB,EAAEC,OAAF,EAAWC,MAAX,EAAtB,EAGE;AACA,SAAO,kCAAW;AAChBC,SAAY,0BAAkB,EAAEC,gBAAgBH,QAAQI,IAAR,CAAaC,MAAb,GAAsB,EAAxC,EAAlB,EAAgEJ,OAAOK,GAAvE,EAA4EC,MADxE;AAEhBC,gBAAYP,OAAOO,UAFH;AAGhBC,eAAYR,OAAOQ,SAHH;AAIhBT;AAJgB,GAAX,CAAP;AAMD;;AAED,SAASU,cAAT,CAAwBC,IAAxB,EAGI;AACF,SAAO,uCAAgB;AACrBC,WAASb,aAAaY,IAAb,CADY;AAErBE,aAASF,KAAKV,MAAL,CAAYa;AAFA,GAAhB,CAAP;AAID;;AAWD;AACA;AACA;AACA;;AAEO,IAAMC,sCAAgBC,MAAD,IAAyBA,OAClDC,IADkD,CAC7C,YAAIC,WAAJ,CAAgBC,MAD6B,EAElDF,IAFkD,qBAGlDG,OAHkD,CAG1C,CAACC,IAAD,EAAOC,MAAP,uBAAwBD,IAAxB,IAA8BC,MAA9B,GAH0C,kBAIlDF,OAJkD,CAI1C,CAACC,IAAD,EAAOf,GAAP,uBAAqBe,IAArB,IAA2Bf,GAA3B,GAJ0C,eAKlDiB,eALkD,CAKlC,CAACC,GAAD,EAAMC,KAAN,KAAgB,mBAAOD,IAAIE,OAAX,EAAoBD,MAAMC,OAA1B,CALkB,EAMlDC,GANkD,CAM9C,YAAIC,SAN0C,CAA9C;;AAQA,IAAMC,gCAAab,MAAD,IAAyBA,OAC/CC,IAD+C,CAC1C,YAAIW,SAAJ,CAAcT,MAD4B,EAE/CF,IAF+C,qBAG/CU,GAH+C,CAG3C,CAAC,EAAED,OAAF,EAAD,KAAiBA,OAH0B;AAIhD;AAJgD,CAK/CI,GAL+C,CAK3CC,OAAOA,IAAIL,OAAJ,CAAYM,MAAZ,CAAmBC,MAAnB,EALoC,EAM/CC,MAN+C,CAMxC,MAAM,KANkC,CAA3C;;AAQP,IAAMC,aAAcnB,MAAD,IAAyBA,OACzCC,IADyC,CACpC,YAAImB,IAAJ,CAASjB,MAD2B,EAEzCF,IAFyC,qBAGzCU,GAHyC,CAGrC,CAAC,EAAED,OAAF,EAAD,KAAoCA,OAHC,EAIzCC,GAJyC;AAAA,+BAIrC;AAAA,QAAM,EAAEU,OAAF,EAAN;AAAA,QAAoBhB,IAApB;;AAAA,6BACAA,IADA;AAEHgB;AACEC,sBAAc;AADhB,SAEKD,OAFL,CAFG;AAMHhB,YAAM,MAAMX,eAAeW,IAAf;AANT;AAAA,GAJqC;;AAAA;AAAA;AAAA;AAAA,MAYzCJ,IAZyC,sBAazCU,GAbyC,CAarC;AAAA,MAAC,EAAEN,IAAF,EAAD;AAAA,MAAYV,IAAZ;;AAAA,2BAA6BU,IAA7B,EAAsCV,IAAtC;AAAA,CAbqC,EAczCgB,GAdyC,CAcrC,WAAiD;AAAA,MAAhD,EAAEjB,cAAF,EAAkBT,MAAlB,EAA0BsC,MAA1B,EAAgD;AAAA,MAAXC,IAAW;;AACpD,MAAMC,UAAU,0BAAkB;AAChCtC,oBAAgBO,eAAegC,UAAf,GAA4B;AADZ,GAAlB,EAEbzC,OAAOK,GAFM,EAEDC,MAFf;;AAIA,MAAMoC,UAAU,iCAAU;AACxBzC,SAAWuC,OADa;AAExBG,eAAW3C,OAAO2C,SAFM;AAGxBL,UAHwB;AAIxB7B;AAJwB,GAAV,CAAhB;AAMA,MAAMmC,MAAM,yBAAOC,KAAP,CAAa7C,OAAOK,GAApB,EAAyBL,OAAO8C,IAAhC,CAAZ;AACA,yBAAS9C,MAAT,EAAiB0C,OAAjB,EAA0BE,GAA1B,IAAkCL,IAAlC;AAA0C,CA1BF,EA2BzCb,GA3ByC;AAAA,gCA2BrC,WAAM,EAAEU,OAAF,EAAWM,OAAX,EAAoB3C,OAApB,EAA6BC,MAA7B,EAAqC+C,cAArC,EAAqDH,GAArD,EAAN;AAAA,WAAsE;AACzE7C,aADyE;AAEzEC,YAFyE;AAGzE+C,oBAHyE;AAIzEC,cAAQ,MAAM,iBAAWC,IAAX,CAAgBL,GAAhB,EAAqBF,OAArB,EAA8BN,OAA9B;AAJ2D,KAAtE;AAAA,GA3BqC;;AAAA;AAAA;AAAA;AAAA,MAiCzCpB,IAjCyC,sBAkCzCU,GAlCyC,CAkCrC,YAAIwB,gBAlCiC,EAmCzCC,WAnCyC,CAmC7BC,OAAO,cAAG,YAAIC,aAAJ,CAAkB,yBAAUD,GAAV,CAAlB,CAAH,EAAsCE,KAAtC,CAA4C,EAA5C,CAnCsB,CAA5C;;kBAsCepB,U","file":"net-request.js","sourcesContent":["//@flow\n\nimport { Stream, of, awaitPromises } from 'most'\nimport { equals } from 'ramda'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`net-request`\n\nimport { API, NET } from '../action'\nimport { NetMessage } from '../../service/networker/net-message'\nimport { apiMessage, encryptApiBytes, mtMessage } from '../../service/chain/encrypted-message'\nimport Config from '../../config-provider'\nimport NetworkerThread from '../../service/networker/index'\nimport { Serialization } from '../../tl/index'\nimport { httpClient } from '../../http'\nimport { homeDc, uid, whenActive } from '../signal'\nimport jsonError from '../../util/json-error'\n// import ApiRequest from '../../service/main/request'\n\nfunction makeApiBytes({ message, thread }: {\n  message: NetMessage,\n  thread: NetworkerThread }\n) {\n  return apiMessage({\n    ctx       : new Serialization({ startMaxLength: message.body.length + 64 }, thread.uid).writer,\n    serverSalt: thread.serverSalt,\n    sessionID : thread.sessionID,\n    message\n  })\n}\n\nfunction encryptedBytes(opts: *): Promise<{|\n  encryptedBytes: ArrayBuffer,\n  msgKey: Uint8Array,\n|}> {\n  return encryptApiBytes({\n    bytes  : makeApiBytes(opts),\n    authKey: opts.thread.authKeyUint8\n  })\n}\n\ntype NetRequestPayload = {\n  payload: {\n    message: NetMessage,\n    options: Object,\n    threadID: string,\n    thread: NetworkerThread,\n  },\n  type: 'net/send',\n}\n// process.on('unhandledRejection', val => {\n//   console.log(val)\n//   console.trace('on')\n// })\n\nexport const onNewRequest = (action: Stream<any>) => action\n  .thru(API.NEW_REQUEST.stream)\n  .thru(whenActive)\n  .combine((data, homeDc) => ({ ...data, homeDc }), homeDc)\n  .combine((data, uid) => ({ ...data, uid }), uid)\n  .skipRepeatsWith((old, fresh) => equals(old.payload, fresh.payload))\n  .map(API.CALL_TASK)\n\nexport const onNewTask = (action: Stream<any>) => action\n  .thru(API.CALL_TASK.stream)\n  .thru(whenActive)\n  .map(({ payload }) => payload)\n  // .delay(50)\n  .tap(val => val.payload.netReq.invoke())\n  .filter(() => false)\n\nconst netRequest = (action: Stream<any>) => action\n  .thru(NET.SEND.stream)\n  .thru(whenActive)\n  .map(({ payload }: NetRequestPayload) => payload)\n  .map(async({ options, ...data }) => ({\n    ...data,\n    options: {\n      responseType: 'arraybuffer',\n      ...options,\n    },\n    data: await encryptedBytes(data)\n  }))\n  .thru(awaitPromises)\n  .map(({ data, ...opts }) => ({ ...data, ...opts }))\n  .map(({ encryptedBytes, thread, msgKey, ...rest }) => {\n    const request = new Serialization({\n      startMaxLength: encryptedBytes.byteLength + 256\n    }, thread.uid).writer\n\n    const mtBytes = mtMessage({\n      ctx      : request,\n      authKeyID: thread.authKeyID,\n      msgKey,\n      encryptedBytes\n    })\n    const url = Config.dcMap(thread.uid, thread.dcID)\n    return { thread, mtBytes, url, ...rest } })\n  .map(async({ options, mtBytes, message, thread, noResponseMsgs, url }) => ({\n    message,\n    thread,\n    noResponseMsgs,\n    result: await httpClient.post(url, mtBytes, options)\n  }))\n  .thru(awaitPromises)\n  .map(NET.RECEIVE_RESPONSE)\n  .recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))).delay(15))\n\n\nexport default netRequest\n"]}