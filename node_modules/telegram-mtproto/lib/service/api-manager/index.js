'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiManager = undefined;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

var _authorizer = require('../authorizer');

var _authorizer2 = _interopRequireDefault(_authorizer);

var _defer = require('../../util/defer');

var _defer2 = _interopRequireDefault(_defer);

var _error = require('../../error');

var _bin = require('../../bin');

var _mtprotoShared = require('mtproto-shared');

require('./index.h');

require('../main/index.h');

require('eventemitter2');

require('../../plugins');

var _configProvider = require('../../config-provider');

var _configProvider2 = _interopRequireDefault(_configProvider);

var _networker = require('../networker');

var _networker2 = _interopRequireDefault(_networker);

var _request = require('../main/request');

var _request2 = _interopRequireDefault(_request);

var _observer = require('../../util/observer');

var _observer2 = _interopRequireDefault(_observer);

var _property = require('../../property');

var _action = require('../../state/action');

var _core = require('../../state/core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var log = _mtprotoLogger2.default`api-manager`;

var baseDcID = 2;

var Ln = (length, obj) => {
  if (obj == null) return false;
  var res = typeof obj.length === 'number' && obj.length === length;
  return res;
};

class ApiManager {
  constructor(config, uid) {
    this.cache = {
      uploader: {},
      downloader: {},
      auth: {},
      servers: {},
      keysParsed: {}
    };
    this.authPromise = (0, _defer2.default)();
    this.authBegin = false;
    this.currentDc = 2;
    this.online = false;

    var {
      server,
      api,
      app: {
        storage,
        publicKeys
      }
    } = config;
    this.uid = uid;
    this.apiConfig = api;
    this.publicKeys = publicKeys;
    this.storage = storage;
    this.serverConfig = server;
    var emitter = _configProvider2.default.rootEmitter(this.uid);
    this.on = emitter.on;
    this.emit = emitter.emit;
    this.auth = (0, _authorizer2.default)(uid, publicKeys, this.cache.keysParsed);

    //$FlowIssue
    this.mtpInvokeApi = this.mtpInvokeApi.bind(this);
    this.invokeNetRequest = this.invokeNetRequest.bind(this);
    //$FlowIssue
    this.mtpGetNetworker = this.mtpGetNetworker.bind(this);

    // this.updatesManager = UpdatesManager(apiManager, this.TL)
    // apiManager.updates = this.updatesManager
    emitter.on('error.303', newDc => {
      this.authBegin = false;
      this.currentDc = newDc;
    });
  }
  networkSetter(dc, authKey, serverSalt) {
    var networker = new _networker2.default({
      appConfig: this.apiConfig,
      storage: this.storage
    }, dc, authKey, serverSalt, this.uid);
    this.cache.downloader[dc] = networker;
    return networker;
  }
  mtpGetNetworker(dcID) {
    var _this = this;

    return _asyncToGenerator(function* () {
      // const isUpload = options.fileUpload || options.fileDownload
      // const cache = isUpload
      //   ? this.cache.uploader
      //   : this.cache.downloader

      var cache = _this.cache.downloader;
      if (!dcID) throw new Error('get Networker without dcID');

      if (typeof cache[dcID] !== 'undefined') return cache[dcID];

      var akk = `dc${dcID}_auth_key`;
      var ssk = `dc${dcID}_server_salt`;

      var dcUrl = _configProvider2.default.dcMap(_this.uid, dcID);
      if (typeof dcUrl !== 'string') throw new _error.DcUrlError(dcID, dcUrl);

      if (cache[dcID]) return cache[dcID];

      var authKeyHex = yield _this.storage.get(akk);
      var serverSaltHex = yield _this.storage.get(ssk);

      // if (!authKeyHex || !serverSaltHex)
      // await this.doAuth()

      if (Ln(512, authKeyHex)) {
        if (!serverSaltHex || serverSaltHex.length !== 16) serverSaltHex = 'AAAAAAAAAAAAAAAA';
        var _authKey = (0, _bin.bytesFromHex)(authKeyHex);
        var _serverSalt = (0, _bin.bytesFromHex)(serverSaltHex);

        return _this.networkSetter(dcID, _authKey, _serverSalt);
      }

      var auth = void 0;
      try {
        auth = yield _this.auth(dcID, _this.cache.auth, dcUrl);
      } catch (error) {
        return netError(error);
      }

      var { authKey, serverSalt } = auth;

      yield _this.storage.set(akk, (0, _bin.bytesToHex)(authKey));
      yield _this.storage.set(ssk, (0, _bin.bytesToHex)(serverSalt));

      _this.emit('base', 'WORK');

      return _this.networkSetter(dcID, authKey, serverSalt);
    })();
  }
  doAuth() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.authBegin = true;
      _this2.emit('base', 'CHECK');
      try {
        var storedBaseDc = yield _this2.storage.get('dc');
        var baseDc = storedBaseDc || baseDcID;
        var opts = {
          dc: baseDc,
          createNetworker: true
        };
        var networker = yield _this2.mtpGetNetworker(baseDc);
        var nearestDc = yield networker.wrapApiCall('help.getNearestDc', {}, opts);
        var { nearest_dc, this_dc } = nearestDc;
        yield _this2.storage.set('nearest_dc', nearest_dc);
        if (storedBaseDc == null) {
          yield _this2.storage.set('dc', this_dc);
          // if (nearest_dc !== this_dc) await this.mtpGetNetworker(nearest_dc, {
          //   dcID           : this_dc,
          //   createNetworker: true
          // })
        }
        log(`nearest Dc`, ` this dc`)(nearestDc, this_dc);
        _this2.authPromise.resolve();
      } catch (err) {
        _this2.authPromise.reject(err);
      }
    })();
  }
  initConnection() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.emit('base', 'REQUEST');
      if (!isAnyNetworker(_this3)) {
        if (!_this3.authBegin) _this3.doAuth();
        yield _this3.authPromise.promise;
      }
    })();
  }
  mtpInvokeApi(method, params = {}, options = {}) {
    var _this4 = this;

    return _asyncToGenerator(function* () {

      /* const akk = `dc${this.currentDc}_auth_key`
      if (method === 'auth.sendCode' || method === 'auth.signIn') {
        const dcKey = await this.storage.get(akk)
        if (typeof dcKey === 'string' && dcKey.length > 0) alreadyAuthWarning(method)
      } */

      var netReq = new _request2.default({ method, params }, options, _this4.invokeNetRequest);
      // const toPromise = {
      //   Left : (val) => Bluebird.reject(val),
      //   Right: (val) => Bluebird.resolve(val),
      // }
      // const ok: any = {}
      // const request = subject(ok)
      // const obs = requestObserver(netReq, request)
      // obs.then(debug`obs`)
      netReq.options.requestID = netReq.requestID;
      // this.emit('new-request', netReq)
      (0, _core.dispatch)(_action.API.NEW_REQUEST({
        netReq,
        method,
        params,
        timestamp: Date.now()
      }, netReq.requestID));
      // netReq.defer.promise.then(
      //   val => request.next(val),
      //   err => request.error(err)
      // )
      return netReq.deferFinal.promise;
    })();
  }

  invokeNetRequest(netReq) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      var networker = void 0;

      var dcID = void 0;
      try {
        yield _this5.initConnection();

        if (netReq.options.dc) {
          var reqDc = netReq.options.dc;
          if (typeof reqDc === 'number') dcID = reqDc;else if (reqDc === '@@home') dcID = yield _this5.storage.get('dc');else throw new Error(`invokeNetRequest wrong request id ${reqDc}`);
        } else dcID = yield _this5.storage.get('dc');

        networker = yield _this5.mtpGetNetworker(dcID);
      } catch (e) {
        netReq.defer.reject(e);
        return netReq.defer.promise;
      }

      // const requestThunk = (waitTime: number): Promise<any> => {
      //   debug('requestThunk', 'waitTime')(waitTime)
      //   return delayedCall(req.performRequest, +waitTime * 1e3)
      // }

      yield networker.wrapApiCall(netReq.data.method, netReq.data.params, netReq.options, netReq.requestID);

      // try {
      //   const result = await networker.wrapApiCall(
      //     netReq.data.method,
      //     netReq.data.params,
      //     netReq.options,
      //     netReq.requestID)
      //   netReq.defer.resolve(result)
      //   return result
      // } catch (err) {
      //   if (isRawError(err)) {
      //     (err: RawErrorStruct)
      //     log`raw error`(err)
      //     console.trace('Wrong way!')
      //     dispatch(API.DONE_REQUEST(err, netReq.requestID))
      //     return netReq.defer.promise
      //   }
      //   const error: MTError = err
      //   console.error(dTime(), 'Error', error.code, error.type, baseDcID, dcID)
      //   console.trace('Unhandled performRequest')
      //   const noAuth = error.code === 401
      //   if (noAuth) {
      //     log('performRequest', 'no auth')(dcID)
      //     this.emit('no-auth', {
      //       dc    : dcID,
      //       apiReq: netReq,
      //       error
      //     })
      //   }
      //   // if (!error)
      //   //   err = { type: 'ERROR_EMPTY', input: '' }
      //   // else if (!is(Object, error))
      //   //   err = { message: error }
      //   // else err = error
      //   console.warn(`[rejectPromise] Unhandled error!`, err)

      //   if (!netReq.options.noErrorBox) {
      //     //TODO weird code. `error` changed after `.reject`?

      //     /*err.input = method

      //     err.stack =
      //       stack ||
      //       hasPath(['originalError', 'stack'], error) ||
      //       error.stack ||
      //       (new Error()).stack*/
      //     /*this.emit('error.invoke', error)*/
      //   }
      //   netReq.defer.reject(error)
      // }

      return netReq.defer.promise;
    })();
  }
}

exports.ApiManager = ApiManager; /* type RawErrorStruct = {
                                   _: 'rpc_error',
                                   error_code: number,
                                   error_message: string,
                                 }
                                 
                                 function isRawError(val: mixed): boolean %checks {
                                   return typeof val === 'object'
                                     && val != null
                                     && val._ === 'rpc_error'
                                     && typeof val.error_code === 'number'
                                     && typeof val.error_message === 'string'
                                 }
                                 
                                 function requestObserver(netReq: ApiRequest, request: HoldSubject<any>) {
                                   const obs = Observer({
                                     next(data) {
                                       log`obs, next`(data)
                                       return data
                                     },
                                     error(data) {
                                       log`obs, error`(data)
                                       return request.next(data)
                                     },
                                     async complete(data) {
                                       log`obs, complete`(data)
                                       // dispatch(API.DONE_REQUEST(data, netReq.requestID))
                                       return data
                                     }
                                   })(request)
                                 
                                   return obs
                                 } */

var isAnyNetworker = ctx => Object.keys(ctx.cache.downloader).length > 0;

var netError = error => {
  console.log('Get networker error', error, error.stack);
  return _bluebird2.default.reject(error);
};

/* const alreadyAuthWarning = (method: string) => {
  const message = `
!! WARNING !!
You call ${method} method at the time when you are already authorized.
That will have result in unnecessary re-creation of the session`
  console.warn(message)
} */
//# sourceMappingURL=index.js.map