{"version":3,"sources":["../../../src/service/chain/parse-response.js"],"names":["authKey","msgKey","encryptedData","aesKey","aesIv","dataWithPadding","aesDecrypt","getDataWithPad","hashData","reader","dataHash","sha1Hash","slice","console","warn","Error","response","fetchObject","parsedResponse","readResponse","readHash","authKeyStored","authKeyID","fetchIntBytes","fetchRawBytes","byteLength","getOffset","currentSession","prevSession","sessionID","messageID","typeBuffer","isInvalidSession","seqNo","fetchInt","offset","totalLength","messageBodyLength","messageBody","buffer","paddingLength","subarray"],"mappings":"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","file":"parse-response.js","sourcesContent":["//@flow\n\nimport { Deserialization } from '../../tl/index'\nimport { bytesCmp, bytesToHex, convertToUint8Array, bytesToArrayBuffer, bytesFromArrayBuffer } from '../../bin'\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { readLong } from '../../tl/reader'\n\ntype ReadResponse = {\n  response: ArrayBuffer | Buffer,\n  reader: Deserialization,\n  authKeyStored: number[]\n}\n\ntype GetDataWithPad = {\n  authKey: Uint8Array,\n  msgKey: Uint8Array,\n  encryptedData: Uint8Array\n}\n\ntype ReadHash = {\n  reader: Deserialization,\n  currentSession: number[],\n  prevSession: number[],\n  dataWithPadding: ArrayBuffer\n}\n\ntype ParsedResponse = {\n  hashData: Uint8Array,\n  msgKey: Uint8Array,\n  reader: Deserialization,\n}\n\n\nexport function readResponse({ response, reader, authKeyStored }: ReadResponse) {\n  const authKeyID = reader.fetchIntBytes(64, 'auth_key_id')\n  if (!bytesCmp(authKeyID, authKeyStored)) {\n    throw new Error(`[MT] Invalid server auth_key_id: ${  bytesToHex(authKeyID)}`)\n  }\n  const msgKey = reader.fetchIntBytes(128, 'msg_key')\n  const encryptedData = reader.fetchRawBytes(\n    response.byteLength - reader.getOffset(),\n    'encrypted_data')\n  return {\n    msgKey,\n    encryptedData\n  }\n}\n\n\nexport async function getDataWithPad({ authKey, msgKey, encryptedData }: GetDataWithPad) {\n  const [aesKey, aesIv] = await getMsgKeyIv(authKey, msgKey, false)\n  const dataWithPadding = await CryptoWorker.aesDecrypt(encryptedData, aesKey, aesIv)\n  return dataWithPadding\n}\n\nexport function readHash({ reader, currentSession, prevSession, dataWithPadding }: ReadHash) {\n  reader.fetchIntBytes(64, 'salt')\n  const sessionID = reader.fetchIntBytes(64, 'session_id')\n  const messageID = readLong(reader.typeBuffer, 'message_id')\n\n  const isInvalidSession = !bytesCmp(sessionID, currentSession) && (!prevSession\n    //eslint-disable-next-line\n    || !bytesCmp(sessionID, prevSession));\n  if (isInvalidSession) {\n    console.warn('Sessions', sessionID, currentSession, prevSession)\n    throw new Error(`[MT] Invalid server session_id: ${ bytesToHex(sessionID) }`)\n  }\n\n  const seqNo = reader.fetchInt('seq_no')\n\n  let offset = reader.getOffset()\n  const totalLength = dataWithPadding.byteLength\n\n  const messageBodyLength = reader.fetchInt('message_data[length]')\n  if (messageBodyLength % 4\n    || messageBodyLength > totalLength - offset) {\n    throw new Error(`[MT] Invalid body length: ${  messageBodyLength}`)\n  }\n  const messageBody = reader.fetchRawBytes(messageBodyLength, 'message_data')\n\n  const buffer = bytesToArrayBuffer(messageBody)\n\n  offset = reader.getOffset()\n  const paddingLength = totalLength - offset\n  if (paddingLength < 0 || paddingLength > 15)\n    throw new Error(`[MT] Invalid padding length: ${paddingLength}`)\n  const hashData =\n    convertToUint8Array(dataWithPadding)\n      .subarray(0, offset)\n\n  return {\n    hashData,\n    seqNo,\n    messageID,\n    sessionID,\n    buffer\n  }\n}\n\n\nexport async function parsedResponse({ hashData, msgKey, reader }: ParsedResponse) {\n  const dataHash = await CryptoWorker.sha1Hash(hashData)\n\n  if (!bytesCmp(msgKey, bytesFromArrayBuffer(dataHash).slice(-16))) {\n    console.warn(msgKey, bytesFromArrayBuffer(dataHash))\n    throw new Error('[MT] server msgKey mismatch')\n  }\n  const response = reader.fetchObject('', 'INPUT')\n\n  return response\n}\n"]}