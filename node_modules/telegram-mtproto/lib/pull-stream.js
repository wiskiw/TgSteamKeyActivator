'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.faucet = faucet;
exports.faucetC = faucetC;

var _ramda = require('ramda');

require('most');

var _property = require('./property');

var _property2 = _interopRequireDefault(_property);

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = _mtprotoLogger2.default`pull-stream`;

class PullStream {
  constructor(source, consumer, controlStream) {
    this.buffer = [];
    this.empty = true;
    this.length = 0;
    this.busy = true;
    this.locked = true;
    this.isTerminated = false;
    this.cancel = noop;

    this.source = source;
    this.consumer = consumer(this.next.bind(this), this.fallback.bind(this));
    source.observe(val => {
      log`source`(val);
      this.push(val);
    });
    controlStream.skipRepeats().observe(val => {
      this.locked = !val;
      log`control`(val);
      this.update();
    });
  }
  update() {
    log`update, busy, locked`(this.busy, this.locked);
    this.length = this.buffer.length;
    if (!this.busy && !this.locked) this.feed();
  }
  push(val) {
    this.empty = false;
    this.buffer = Array.isArray(val) ? this.buffer.concat(val) : (0, _ramda.append)(val, this.buffer);
    this.update();
  }
  pushFirst(val) {
    this.empty = false;
    this.buffer = Array.isArray(val) ? val.concat(this.buffer) : (0, _ramda.prepend)(val, this.buffer);
    this.update();
  }
  /**
   * Force push next value into consumer
   *
   * @private
   * @memberof PullStream
   */
  feed() {
    var val = (0, _ramda.head)(this.buffer);
    if (val == null) return;
    this.busy = true;
    this.buffer = (0, _ramda.tail)(this.buffer);
    if (this.buffer.length === 0) this.empty = true;
    this.length = this.buffer.length;
    this.cancel = this.consumer(val);
  }
  /**
   * Callback, used **only** by consumer
   *
   * @private
   * @memberof PullStream
   */
  next() {
    if (this.empty) this.busy = false;else this.feed();
  }
  /**
   * Cancellation callback, used **only** by consumer
   *
   * @private
   * @memberof PullStream
   */
  fallback(val) {
    this.busy = true;
    this.push(val);
  }

  clean() {
    this.empty = true;
    this.length = 0;
    this.buffer = [];
  }
  replace(list) {
    this.clean();
    this.push(list);
  }
  stop() {
    this.clean();
    this.isTerminated = true;
    //$FlowIssue
    this.push = noop;
    //$FlowIssue
    this.feed = noop;
  }
  //$FlowIssue
  *[Symbol.iterator]() {
    yield* this.buffer;
  }
}

exports.default = PullStream;
function faucet(source, controlStream) {
  var init = {};
  var prop = (0, _property2.default)('', init);
  var stream = prop.skip(1).multicast();
  var consumer = (next, fallback) => {
    prop.observe(() => next());
    return val => {
      prop.next(val);
      return () => {};
    };
  };
  new PullStream(source, consumer, controlStream);
  return stream;
}

function faucetC(controlStream) {
  return function (source) {
    return faucet(source, controlStream);
  };
}

function noop() {}
//# sourceMappingURL=pull-stream.js.map