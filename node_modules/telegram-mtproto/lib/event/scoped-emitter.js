'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.emitScope = exports.EventScope = undefined;

var _arrify = require('../util/arrify');

var _arrify2 = _interopRequireDefault(_arrify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var normalizeScope = scope => (0, _arrify2.default)(scope);

var reduceStarter = [];

var combineScope = (...scopes) => scopes.reduce((acc, val) => acc.concat(normalizeScope(val)), reduceStarter);

class ScopedEmitter {
  constructor(scope, parent) {
    this.on = (event, listener) => {
      var fullEvent = this.scope.concat(normalizeScope(event));
      // console.log('on', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))
      return this.root.on(fullEvent, listener);
    };

    this.off = (event, listener) => {
      var fullEvent = [...this.scope, event].join('.');
      return this.root.off(fullEvent, listener);
    };

    this.emit = (event, ...values) => {
      var fullEvent = this.scope.concat(normalizeScope(event));
      // console.log('emit', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))
      return this.root.emit(fullEvent, ...values);
    };

    this.addEventListener = this.on;
    this.removeEventListener = this.off;

    if (parent instanceof ScopedEmitter) {
      this.root = parent.root;
      this.scope = combineScope(parent.scope, scope);
    } else {
      this.scope = normalizeScope(scope);
      this.root = parent;
    }
  }

}

// const Predicate = tagged('Predicate', ['f'])

// Make a Predicate that runs `f` to get
// from `b` to `a`, then uses the original
// Predicate function!
// contramap :: Predicate a ~> (b -> a)
//                          -> Predicate b
// Predicate.prototype.contramap =
//   function(f) {
//     return Predicate(
//       x => this.f(f(x))
//     )
//   }


class EventScope /*ᐸElementTᐳ*/ {
  static of(val) {
    var list = void 0;
    if (Array.isArray(val)) list = val;else list = [val];
    return new EventScope(list);
  }
  map(fn) {
    return EventScope.of(fn(this.value));
  }
  concat(e) {
    return EventScope.of([...this.value, ...e.value]);
  }
  ap(fn) {
    return fn(this.value);
  }
  equals(scope) {
    for (var _iterator = this.value.entries(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var [index, str] = _ref;

      if (str !== scope.value[index]) return false;
    }return true;
  }
  static empty() {
    return EventScope.of([]);
  }
  constructor(val) {
    this.value = val;
    this.joined = val.join('.');
  }
}

exports.EventScope = EventScope;
var emitScope = exports.emitScope = es => em => data => em.emit(es.value, data);

// export const fromScope =
//   (es: EventScope) =>
//     (em: EventEmitterType) =>
//       fromEvents(em, es.joined)

// const ex = EventScope.of(['uid', 'scope'])

// const mp = (val: string[]) => [val[0], 'a']
// const ex1 = ex.map(mp)
exports.default = ScopedEmitter;
//# sourceMappingURL=scoped-emitter.js.map