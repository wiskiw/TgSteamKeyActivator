'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _timeManager = require('../service/time-manager');

var _index = require('../service/networker/index');

var _signal = require('../state/signal');

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var log = _mtprotoLogger2.default`long-poll`;

// let inited = false

var waitToTime = (() => {
  var _ref = _asyncToGenerator(function* (poll) {
    while (!poll.allowLongPoll()) {
      yield new Promise(function (rs) {
        return setTimeout(rs, 500);
      });
    }
  });

  return function waitToTime(_x) {
    return _ref.apply(this, arguments);
  };
})();

class LongPoll {
  constructor(thread) {
    this.maxWait = 25e3;
    this.pendingTime = Date.now();
    this.requestTime = Date.now();
    this.isActive = false;
    this.alreadyWaitPending = false;

    this.thread = thread;
    _signal.active.observe(val => this.isActive = val);
    // if (inited) {
    //   log('Networker')(thread)
    //   //$ FlowIssue
    //   this.request = () => Bluebird.resolve()
    // }
    // inited = true
  }

  setPendingTime() {
    var now = (0, _timeManager.tsNow)();
    this.requestTime = now;
    this.pendingTime = now + this.maxWait;
  }
  request() {
    var _this = this;

    return _asyncToGenerator(function* () {
      var result = yield _this.thread.wrapMtpCall('http_wait', {
        max_delay: 1000,
        wait_after: 500,
        max_wait: _this.maxWait
      }, {
        noResponse: true,
        longPoll: true
        // notContentRelated: true
      });
      _this.thread.checkLongPoll();
      return result;
    })();
  }

  writePollTime() {
    this.requestTime = (0, _timeManager.tsNow)();
  }

  allowLongPoll() {
    var result = this.requestTime + 1500 < (0, _timeManager.tsNow)();
    log`allow long poll`(result);
    return result;
  }
  sending() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.alreadyWaitPending = true;
      yield waitToTime(_this2);
      _this2.alreadyWaitPending = false;
      _this2.setPendingTime();
      var result = yield _this2.request();
      return result;
    })();
  }
  sendLongPool() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      //TODO add base dc check
      if (!_this3.isActive) return false;
      if (_this3.allowLongPoll()) {
        _this3.pending = _this3.sending();
      }

      var result = yield _this3.pending;
      return result;
    })();
  }
}

exports.default = LongPoll;
//# sourceMappingURL=long-poll.js.map