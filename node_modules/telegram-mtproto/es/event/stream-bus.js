function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import { from, of } from 'most';

import Config from '../config-provider';
import { makeEventStream } from './make-event-stream';

import { onRpcError, isMigrateError, getMigrateDc, isFileMigrateError, getFileMigrateDc } from './rpc';
import ApiRequest from '../service/main/request';
import NetworkerThread from '../service/networker';
import { NetMessage } from '../service/networker/net-message';
import { MTError, RpcError } from '../error';
import dcStoreKeys from '../util/dc-store-keys';

import Logger from 'mtproto-logger';
var log = Logger`stream-bus`;

var createStreamBus = ctx => {
  var emitter = Config.rootEmitter(ctx.uid);
  var bus = makeStreamMap(emitter);

  bus.responseRaw.observe(log('raw response'));
  // bus.responseRaw.onError(log('raw error'))

  bus.incomingMessage.observe(log('incoming message'));

  var state = ctx.state;

  bus.incomingMessage.observe(val => {
    // ctx.state.messages.delete(val.message.msg_id)
    var networker = state.threads.get(val.threadID);
    if (networker == null) return;
    log('observer', 'type')(val.message._, networker.dcID);
  });

  bus.newNetworker.observe(networker => {
    log('new networker')(networker);
    state.threads.set(networker.threadID, networker);
  });

  bus.messageIn.observe(log('message in'));

  var apiOnly = bus.messageIn.filter(value => value.isAPI);
  var mtOnly = bus.messageIn.filter(value => !value.isAPI);

  apiOnly.observe(val => {
    ctx.state.messages.set(val.msg_id, val);
  });
  mtOnly.observe(val => {
    ctx.state.messages.set(val.msg_id, val);
  });

  bus.rpcResult.observe((() => {
    var _ref = _asyncToGenerator(function* (data) {
      log('rpc result')(data);
      data.sentMessage.deferred.resolve(data.result);
      ctx.state.messages.delete(data.sentMessage.msg_id);
      var requestID = data.sentMessage.requestID;
      if (typeof requestID !== 'string') return;
      var req = ctx.state.requests.get(requestID);
      if (req) {
        // data.sentMessage.deferred.reject('No such request!')
        req.defer.resolve(data.result);
        ctx.state.requests.delete(requestID);
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  })());

  bus.rpcError.observe(log('rpc error'));

  var isAuthRestart = error => error.code === 500 && error.type === 'AUTH_RESTART';

  bus.rpcError.observe((() => {
    var _ref2 = _asyncToGenerator(function* (_ref3) {
      var { error } = _ref3,
          data = _objectWithoutProperties(_ref3, ['error']);

      if (isFileMigrateError(error)) {
        var newDc = getFileMigrateDc(error);
        if (typeof newDc !== 'number') throw error;
        if (!ctx.state.messages.has(data.message.req_msg_id)) {
          data.sentMessage.deferred.reject(error);
          return log('on file migrate error')(data.message.req_msg_id, 'req_msg_id not found');
        }
        var msg = ctx.state.messages.get(data.message.req_msg_id);
        if (!msg || !msg.requestID || typeof msg.requestID !== 'string') {
          data.sentMessage.deferred.reject(error);
          return log('on file migrate error')('msg', msg);
        }
        var req = ctx.state.requests.get(msg.requestID);
        if (!req) {
          data.sentMessage.deferred.reject(error);
          return log('on file migrate error')('req', req);
        }
        req.options.dc = newDc;
        log('file migrate', 'req')(req);
        log('on file migrate restart')('before end');
        yield ctx.api.invokeNetRequest(req);
      }if (isMigrateError(error)) {
        var _newDc = getMigrateDc(error);
        if (typeof _newDc !== 'number') throw error;
        yield ctx.storage.set('dc', _newDc);
        if (!ctx.state.messages.has(data.message.req_msg_id)) {
          data.sentMessage.deferred.reject(error);
          return log('on migrate error')(data.message.req_msg_id, 'req_msg_id not found');
        }
        var _msg = ctx.state.messages.get(data.message.req_msg_id);
        if (!_msg || !_msg.requestID || typeof _msg.requestID !== 'string') {
          data.sentMessage.deferred.reject(error);
          return log('on migrate error')('msg', _msg);
        }
        var _req = ctx.state.requests.get(_msg.requestID);
        if (!_req) {
          data.sentMessage.deferred.reject(error);
          return log('on migrate error')('req', _req);
        }
        _req.options.dc = _newDc;
        log('migrate', 'req')(_req);
        log('on migrate restart')('before end');
        yield ctx.api.invokeNetRequest(_req);
      } else if (isAuthRestart(error)) {
        if (!ctx.state.messages.has(data.message.req_msg_id)) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'auth restart')(data.message.req_msg_id, 'req_msg_id not found');
        }
        var _msg2 = ctx.state.messages.get(data.message.req_msg_id);
        if (!_msg2 || !_msg2.requestID) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'auth restart')('no requestID msg', _msg2);
        }
        var _req2 = ctx.state.requests.get(_msg2.requestID);
        if (!_req2) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'on auth restart')('no request info', _msg2);
        }
        var { authKey, saltKey } = dcStoreKeys(data.networkerDC);
        log('on auth restart')(authKey, saltKey);
        yield ctx.storage.remove(authKey, saltKey);
        log('on auth restart')('before end');
        yield ctx.api.doAuth();
        yield ctx.api.invokeNetRequest(_req2);
      } else if (error.code === 401) {

        log('rpc', 'auth key unreg')(data.sentMessage);
        var reqId = data.sentMessage.requestID;
        if (!reqId) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'auth key unreg')('no requestID msg', data.sentMessage);
        }
        var _dc = data.sentMessage.dc;
        var _req3 = ctx.state.requests.get(reqId);
        if (!_req3 || !_dc) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'on auth key unreg')('no request info', _dc, reqId);
        }

        // const { authKey, saltKey } = dcStoreKeys(dc)
        // await ctx.storage.remove(authKey)
        var thread = ctx.state.threads.get(data.threadID);
        if (!thread) {
          data.sentMessage.deferred.reject(error);
          return log('error', 'on auth key unreg')('no thread', _dc, data.threadID);
        }
        // thread.connectionInited = false
        ctx.api.authBegin = false;
        log('on auth key unreg')('before end');
        var nearest = yield ctx.storage.get('nearest_dc');
        yield ctx.storage.set('dc', nearest);
        // await new Promise(rs => setTimeout(rs, 1e3))
        _req3.options.dc = nearest;
        yield ctx.api.doAuth();
        yield ctx.api.invokeNetRequest(_req3);
      } else {
        log('rpc', 'unhandled')(data);
        log('rpc', 'unhandled', 'error')(error);
        // data.sentMessage.deferred.reject(error)
      }
    });

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  })());

  // bus.netMessage.observe((message) => {
  //   log('net message')(message)
  //   const req = ctx.state.messages.get(message.msg_id)
  //   log('req')(req)
  // })

  // bus.netMessage.observe(log('new request'))

  bus.newSession.observe((() => {
    var _ref4 = _asyncToGenerator(function* ({
      threadID,
      networkerDC,
      message,
      messageID
    }) {
      var thread = ctx.state.threads.get(threadID);
      if (!thread) {
        log`new session, error, no thread`(threadID, messageID);
        return;
      }
      yield thread.applyServerSalt(message.server_salt);
      thread.ackMessage(messageID);
      thread.processMessageAck(message.first_msg_id);

      log`new session, handled`(messageID, networkerDC);

      var repeatRequest = function (req) {
        return of(req).map(ctx.api.invokeNetRequest).awaitPromises();
      };

      yield from(ctx.state.requests.values()).debounce(30).map(repeatRequest).mergeConcurrently(1).observe(log`recurring requests`);
    });

    return function (_x3) {
      return _ref4.apply(this, arguments);
    };
  })());

  bus.untypedMessage.observe(log`untyped`);

  bus.noAuth.observe((() => {
    var _ref5 = _asyncToGenerator(function* ({
      dc,
      apiReq,
      error
    }) {
      // const mainDc  = await ctx.storage.get('dc')
      // if (dc === mainDc) {

      // } else {

      // }
    });

    return function (_x4) {
      return _ref5.apply(this, arguments);
    };
  })());

  return bus;
};

var an = {};

var pushMessageCast = an;
var responseRawCast = an;
var incomingMessageCast = an;
var newNetworkerCast = an;
var rpcResultCast = an;
var untypedMessageCast = an;

// const netMessageCast     : MtpCall = an
var newRequestCast = an;
var messageInCast = an;
var newSessionCast = an;
var noAuthCast = an;

function makeStreamMap(emitter) {
  var getter = makeEventStream(emitter);

  var pushMessage = getter('push-message', pushMessageCast);
  var responseRaw = getter('response-raw', responseRawCast);
  var incomingMessage = getter('incoming-message', incomingMessageCast);
  var newNetworker = getter('new-networker', newNetworkerCast);
  var rpcError = getter('rpc-error', changeRpcError);
  var rpcResult = getter('rpc-result', rpcResultCast);
  var untypedMessage = getter('untyped-message', untypedMessageCast);
  // const netMessage      = getter('net-message', netMessageCast)
  var newRequest = getter('new-request', newRequestCast);
  var messageIn = getter('message-in', messageInCast);
  var newSession = getter('new-session', newSessionCast);
  var noAuth = getter('no-auth', noAuthCast);

  var streamMap = {
    pushMessage,
    responseRaw,
    incomingMessage,
    newNetworker,
    rpcError,
    untypedMessage,
    // netMessage,
    newRequest,
    messageIn,
    rpcResult,
    newSession,
    noAuth
  };

  return streamMap;
}

function changeRpcError(_ref6) {
  var { error } = _ref6,
      raw = _objectWithoutProperties(_ref6, ['error']);

  var changed = onRpcError(error);
  var result = Object.assign({}, raw, { error: changed });
  return result;
}

/*type ApiCall = {
  type: 'api-call',
  msg_id: string,
  method: string,
  params: Object,
  options: {
    messageID?: string,
    dcID?: number
  }
}*/

// type MtpCall = {
//   type: 'mtp-call',
//   msg_id: string,
//   method: string,
//   params: Object,
//   options: Object
// }

export default createStreamBus;
//# sourceMappingURL=stream-bus.js.map