import { append, prepend, head, tail } from 'ramda';
import 'most';
import Property from './property';
import Logger from 'mtproto-logger';
var log = Logger`pull-stream`;

export default class PullStream {
  constructor(source, consumer, controlStream) {
    this.buffer = [];
    this.empty = true;
    this.length = 0;
    this.busy = true;
    this.locked = true;
    this.isTerminated = false;
    this.cancel = noop;

    this.source = source;
    this.consumer = consumer(this.next.bind(this), this.fallback.bind(this));
    source.observe(val => {
      log`source`(val);
      this.push(val);
    });
    controlStream.skipRepeats().observe(val => {
      this.locked = !val;
      log`control`(val);
      this.update();
    });
  }
  update() {
    log`update, busy, locked`(this.busy, this.locked);
    this.length = this.buffer.length;
    if (!this.busy && !this.locked) this.feed();
  }
  push(val) {
    this.empty = false;
    this.buffer = Array.isArray(val) ? this.buffer.concat(val) : append(val, this.buffer);
    this.update();
  }
  pushFirst(val) {
    this.empty = false;
    this.buffer = Array.isArray(val) ? val.concat(this.buffer) : prepend(val, this.buffer);
    this.update();
  }
  /**
   * Force push next value into consumer
   *
   * @private
   * @memberof PullStream
   */
  feed() {
    var val = head(this.buffer);
    if (val == null) return;
    this.busy = true;
    this.buffer = tail(this.buffer);
    if (this.buffer.length === 0) this.empty = true;
    this.length = this.buffer.length;
    this.cancel = this.consumer(val);
  }
  /**
   * Callback, used **only** by consumer
   *
   * @private
   * @memberof PullStream
   */
  next() {
    if (this.empty) this.busy = false;else this.feed();
  }
  /**
   * Cancellation callback, used **only** by consumer
   *
   * @private
   * @memberof PullStream
   */
  fallback(val) {
    this.busy = true;
    this.push(val);
  }

  clean() {
    this.empty = true;
    this.length = 0;
    this.buffer = [];
  }
  replace(list) {
    this.clean();
    this.push(list);
  }
  stop() {
    this.clean();
    this.isTerminated = true;
    //$FlowIssue
    this.push = noop;
    //$FlowIssue
    this.feed = noop;
  }
  //$FlowIssue
  *[Symbol.iterator]() {
    yield* this.buffer;
  }
}

export function faucet(source, controlStream) {
  var init = {};
  var prop = Property('', init);
  var stream = prop.skip(1).multicast();
  var consumer = (next, fallback) => {
    prop.observe(() => next());
    return val => {
      prop.next(val);
      return () => {};
    };
  };
  new PullStream(source, consumer, controlStream);
  return stream;
}

export function faucetC(controlStream) {
  return function (source) {
    return faucet(source, controlStream);
  };
}

function noop() {}
//# sourceMappingURL=pull-stream.js.map