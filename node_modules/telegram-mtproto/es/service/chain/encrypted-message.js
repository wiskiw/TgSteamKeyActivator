function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import CryptoWorker from '../../crypto';
import getMsgKeyIv from './msg-key';
import { writeInt, writeIntBytes, writeLong } from '../../tl/writer';

import { NetMessage } from '../networker/net-message';
import { TypeWriter } from '../../tl/type-buffer';

// import Logger from 'mtproto-logger'

// const log = Logger`encrypted message`


export var apiMessage = ({ ctx, serverSalt, sessionID, message }) => {
  writeIntBytes(ctx, serverSalt, 64);
  writeIntBytes(ctx, sessionID, 64);
  writeLong(ctx, message.msg_id, 'message_id');
  writeInt(ctx, message.seq_no, 'seq_no');

  writeInt(ctx, message.body.length, 'message_data_length');
  writeIntBytes(ctx, message.body, false);

  var apiBytes = ctx.getBuffer();

  return apiBytes;
};

export var encryptApiBytes = (() => {
  var _ref = _asyncToGenerator(function* ({ bytes, authKey }) {
    var bytesHash = yield CryptoWorker.sha1Hash(bytes);
    var msgKey = new Uint8Array(bytesHash).subarray(4, 20);
    var [aesKey, aesIv] = yield getMsgKeyIv(authKey, msgKey, true);
    var encryptedBytes = yield CryptoWorker.aesEncrypt(bytes, aesKey, aesIv);

    return { encryptedBytes, msgKey };
  });

  return function encryptApiBytes(_x) {
    return _ref.apply(this, arguments);
  };
})();

export var mtMessage = ({ ctx, authKeyID, msgKey, encryptedBytes }) => {
  writeIntBytes(ctx, authKeyID, 64);
  writeIntBytes(ctx, msgKey, 128);
  writeIntBytes(ctx, encryptedBytes, false);

  var mtBytes = ctx.getArray();

  return mtBytes;
};
//# sourceMappingURL=encrypted-message.js.map