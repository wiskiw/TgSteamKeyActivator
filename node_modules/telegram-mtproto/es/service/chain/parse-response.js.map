{"version":3,"sources":["../../../src/service/chain/parse-response.js"],"names":["Deserialization","bytesCmp","bytesToHex","convertToUint8Array","bytesToArrayBuffer","bytesFromArrayBuffer","CryptoWorker","getMsgKeyIv","readLong","readResponse","response","reader","authKeyStored","authKeyID","fetchIntBytes","Error","msgKey","encryptedData","fetchRawBytes","byteLength","getOffset","authKey","aesKey","aesIv","dataWithPadding","aesDecrypt","getDataWithPad","readHash","currentSession","prevSession","sessionID","messageID","typeBuffer","isInvalidSession","console","warn","seqNo","fetchInt","offset","totalLength","messageBodyLength","messageBody","buffer","paddingLength","hashData","subarray","dataHash","sha1Hash","slice","fetchObject","parsedResponse"],"mappings":"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","file":"parse-response.js","sourcesContent":["//@flow\n\nimport { Deserialization } from '../../tl/index'\nimport { bytesCmp, bytesToHex, convertToUint8Array, bytesToArrayBuffer, bytesFromArrayBuffer } from '../../bin'\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { readLong } from '../../tl/reader'\n\ntype ReadResponse = {\n  response: ArrayBuffer | Buffer,\n  reader: Deserialization,\n  authKeyStored: number[]\n}\n\ntype GetDataWithPad = {\n  authKey: Uint8Array,\n  msgKey: Uint8Array,\n  encryptedData: Uint8Array\n}\n\ntype ReadHash = {\n  reader: Deserialization,\n  currentSession: number[],\n  prevSession: number[],\n  dataWithPadding: ArrayBuffer\n}\n\ntype ParsedResponse = {\n  hashData: Uint8Array,\n  msgKey: Uint8Array,\n  reader: Deserialization,\n}\n\n\nexport function readResponse({ response, reader, authKeyStored }: ReadResponse) {\n  const authKeyID = reader.fetchIntBytes(64, 'auth_key_id')\n  if (!bytesCmp(authKeyID, authKeyStored)) {\n    throw new Error(`[MT] Invalid server auth_key_id: ${  bytesToHex(authKeyID)}`)\n  }\n  const msgKey = reader.fetchIntBytes(128, 'msg_key')\n  const encryptedData = reader.fetchRawBytes(\n    response.byteLength - reader.getOffset(),\n    'encrypted_data')\n  return {\n    msgKey,\n    encryptedData\n  }\n}\n\n\nexport async function getDataWithPad({ authKey, msgKey, encryptedData }: GetDataWithPad) {\n  const [aesKey, aesIv] = await getMsgKeyIv(authKey, msgKey, false)\n  const dataWithPadding = await CryptoWorker.aesDecrypt(encryptedData, aesKey, aesIv)\n  return dataWithPadding\n}\n\nexport function readHash({ reader, currentSession, prevSession, dataWithPadding }: ReadHash) {\n  reader.fetchIntBytes(64, 'salt')\n  const sessionID = reader.fetchIntBytes(64, 'session_id')\n  const messageID = readLong(reader.typeBuffer, 'message_id')\n\n  const isInvalidSession = !bytesCmp(sessionID, currentSession) && (!prevSession\n    //eslint-disable-next-line\n    || !bytesCmp(sessionID, prevSession));\n  if (isInvalidSession) {\n    console.warn('Sessions', sessionID, currentSession, prevSession)\n    throw new Error(`[MT] Invalid server session_id: ${ bytesToHex(sessionID) }`)\n  }\n\n  const seqNo = reader.fetchInt('seq_no')\n\n  let offset = reader.getOffset()\n  const totalLength = dataWithPadding.byteLength\n\n  const messageBodyLength = reader.fetchInt('message_data[length]')\n  if (messageBodyLength % 4\n    || messageBodyLength > totalLength - offset) {\n    throw new Error(`[MT] Invalid body length: ${  messageBodyLength}`)\n  }\n  const messageBody = reader.fetchRawBytes(messageBodyLength, 'message_data')\n\n  const buffer = bytesToArrayBuffer(messageBody)\n\n  offset = reader.getOffset()\n  const paddingLength = totalLength - offset\n  if (paddingLength < 0 || paddingLength > 15)\n    throw new Error(`[MT] Invalid padding length: ${paddingLength}`)\n  const hashData =\n    convertToUint8Array(dataWithPadding)\n      .subarray(0, offset)\n\n  return {\n    hashData,\n    seqNo,\n    messageID,\n    sessionID,\n    buffer\n  }\n}\n\n\nexport async function parsedResponse({ hashData, msgKey, reader }: ParsedResponse) {\n  const dataHash = await CryptoWorker.sha1Hash(hashData)\n\n  if (!bytesCmp(msgKey, bytesFromArrayBuffer(dataHash).slice(-16))) {\n    console.warn(msgKey, bytesFromArrayBuffer(dataHash))\n    throw new Error('[MT] server msgKey mismatch')\n  }\n  const response = reader.fetchObject('', 'INPUT')\n\n  return response\n}\n"]}