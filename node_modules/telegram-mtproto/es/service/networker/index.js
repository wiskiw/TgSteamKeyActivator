function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Bluebird from 'bluebird';
import uuid from 'uuid/v4';

import { is, contains, mapObjIndexed } from 'ramda';

import { tsNow, generateID, applyServerTime } from '../time-manager';
import random from '../secure-random';
import { NetMessage, NetContainer } from './net-message';
import State from './state';
import { smartTimeout, immediate } from 'mtproto-shared';

import { Serialization, Deserialization } from '../../tl';
import { readResponse, getDataWithPad, readHash, parsedResponse } from '../chain/parse-response';
import { writeInnerMessage } from '../chain/perform-request';
import Config from '../../config-provider';

import Logger from 'mtproto-logger';

var log = Logger`networker`;

import { convertToUint8Array, convertToArrayBuffer, sha1BytesSync, bytesToHex, longToBytes, rshift32 } from '../../bin';

import { TypeWriter } from '../../tl';
import { writeInt, writeBytes, writeLong } from '../../tl/writer';


import LongPoll from '../../plugins/long-poll';
import { NET, NETWORKER_STATE, AUTH } from '../../state/action';

import { dispatch } from '../../state/core';

var updatesProcessor = void 0;
var iii = 0;
var akStopped = false;

//eslint-disable-next-line
// const xhrSendBuffer = !isNode && !('ArrayBufferView' in window)

var storeIntString = writer => (value, field) => {
  switch (typeof value) {
    case 'string':
      return writeBytes(writer, value);
    case 'number':
      return writeInt(writer, value, field);
    default:
      throw new Error(`tl storeIntString field ${field} value type ${typeof value}`);
  }
};

export class NetworkerThread {
  constructor({
    appConfig,
    storage
  }, dc, authKey, serverSalt, uid) {
    var _this = this;

    this.threadID = uuid();
    this.pendingAcks = [];
    this.state = new State();
    this.connectionInited = false;
    this.checkConnectionPeriod = 0;
    this.lastServerMessages = [];

    this.checkLongPollCond = () => this.longPoll.pendingTime > tsNow() || !!this.offline || akStopped;

    this.checkLongPollAfterDcCond = (isClean, baseDc) => isClean && (this.dcID !== baseDc || this.upload || this.sleepAfter && this.sleepAfter < tsNow());

    this.checkLongPoll = _asyncToGenerator(function* () {
      var isClean = _this.cleanupSent();
      if (_this.checkLongPollCond()) return false;

      var baseDc = yield _this.storage.get('dc');
      if (_this.checkLongPollAfterDcCond(isClean, baseDc))
        // console.warn(dTime(), 'Send long-poll for DC is delayed', this.dcID, this.sleepAfter)
        return;
      return _this.longPoll.sendLongPool();
    });

    this.performSheduledRequest = () => {
      //TODO extract huge method
      // console.log(dTime(), 'sheduled', this.dcID, this.iii)
      if (this.offline || akStopped) {
        log(`Cancel sheduled`)(``);
        return Bluebird.resolve(false);
      }
      delete this.nextReq;
      if (this.pendingAcks.length) {
        var ackMsgIDs = [];
        for (var _iterator = this.pendingAcks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var ack = _ref2;

          ackMsgIDs.push(ack);
        }log('acking messages')(ackMsgIDs);
        this.wrapMtpMessage({
          _: 'msgs_ack',
          msg_ids: ackMsgIDs
        }, {
          notContentRelated: true,
          noShedule: true
        }); //TODO WTF Why we make wrapped message and doesnt use it?
        // const res = await msg.deferred.promise
        // log(`AWAITED`, `ack`)(res)
      }

      this.performResend();

      var messages = [];
      var message = void 0;
      var messagesByteLen = 0;
      // const currentTime = tsNow()
      var lengthOverflow = false;
      var singlesCount = 0;
      var logGroup = log.group('perform sheduled request');
      var pendingIds = [];
      for (var _iterator2 = this.state.pendingIterator(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref3 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref3 = _i2.value;
        }

        var [_messageID, value] = _ref3;

        if (value && value < tsNow()) continue;
        this.state.deletePending(_messageID);
        pendingIds.push(_messageID);
        if (!this.state.hasSent(_messageID)) continue;
        message = this.state.getSent(_messageID);
        logGroup('message')(message);
        logGroup('messageID, value')(_messageID, value);
        var messageByteLength = message.size() + 32;
        var cond1 = !message.notContentRelated && lengthOverflow;
        var cond2 = !message.notContentRelated && messagesByteLen + messageByteLength > 655360; // 640 Kb
        if (cond1) continue;
        if (cond2) {
          lengthOverflow = true;
          continue;
        }
        if (message.singleInRequest) {
          singlesCount++;
          if (singlesCount > 1) continue;
        }
        messages.push(message);
        messagesByteLen += messageByteLength;
      }
      dispatch(NETWORKER_STATE.PENDING.DEL(pendingIds, this.dcID));
      logGroup('message, final')(message);
      logGroup('messages')(messages);
      messages.map(msg => this.emit('message-in', msg));

      if (!message) return Bluebird.resolve(false);

      if (message.isAPI && !message.longPoll) {
        var serializer = new Serialization({ mtproto: true }, this.uid);
        var params = {
          max_delay: 1000,
          wait_after: 550,
          max_wait: 3000
        };
        serializer.storeMethod('http_wait', params);
        var netMessage = new NetMessage(this.uid, this.generateSeqNo(), serializer.getBytes());
        this.longPoll.writePollTime();
        // this.emit('net-message', {
        //   type   : 'mtp-call',
        //   msg_id : netMessage.msg_id,
        //   message: netMessage,
        //   method : 'http_wait',
        //   params,
        //   options: {}
        // })
        messages.push(netMessage);
      }

      if (!messages.length) {
        // console.log('no sheduled messages')
        return Bluebird.resolve();
      }

      var noResponseMsgs = [];

      if (messages.length > 1) {
        var container = new Serialization({ mtproto: true, startMaxLength: messagesByteLen + 64 }, this.uid);
        var contBox = container.writer;
        writeInt(contBox, 0x73f1f8dc, 'CONTAINER[id]');
        writeInt(contBox, messages.length, 'CONTAINER[count]');

        var {
          innerMessages,
          noResponseMessages
        } = writeInnerMessage({
          writer: contBox,
          messages
        });
        noResponseMsgs = noResponseMessages;

        message = new NetContainer(this.uid, this.generateSeqNo(true), container.getBytes(true), innerMessages);

        logGroup(`Container`)(innerMessages, noResponseMessages, message.msg_id, message.seq_no);
      } else {
        if (message.noResponse) noResponseMsgs.push(message.msg_id);
      }
      logGroup.groupEnd();
      this.state.addSent(message);

      this.pendingAcks = []; //TODO WTF,he just clear and forget them at all?!?
      if (lengthOverflow || singlesCount > 1) this.sheduleRequest();
      dispatch(NET.SEND({
        message,
        options: {},
        threadID: this.threadID,
        thread: this,
        noResponseMsgs
      }, this.dcID));
      return;
    };

    this.getMsgById = ({ req_msg_id }) => this.state.getSent(req_msg_id);

    this.processMessageAck = messageID => {
      var sentMessage = this.state.getSent(messageID);
      if (sentMessage && !sentMessage.acked) {
        delete sentMessage.body;
        sentMessage.acked = true;
        return true;
      }
      return false;
    };

    this.uid = uid;
    this.appConfig = appConfig;
    this.storage = storage;
    var emitter = Config.rootEmitter(this.uid);
    this.emit = emitter.emit;
    this.dcID = dc;
    this.iii = iii++;

    this.longPoll = new LongPoll(this);
    dispatch(AUTH.SET_AUTH_KEY(authKey, this.dcID));
    this.authKey = authKey;
    this.authKeyUint8 = convertToUint8Array(authKey);
    this.authKeyBuffer = convertToArrayBuffer(authKey);
    this.authKeyID = sha1BytesSync(authKey).slice(-8);

    //$FlowIssue
    this.wrapApiCall = this.wrapApiCall.bind(this);

    // this.checkLongPollCond = this.checkLongPollCond.bind(this)
    this.serverSalt = serverSalt;
    dispatch(AUTH.SET_SERVER_SALT(serverSalt, this.dcID));

    this.upload = false; //options.fileUpload || options.fileDownload || false

    emitter.emit('new-networker', this);

    this.updateSession();

    setInterval(this.checkLongPoll, 10000); //NOTE make configurable interval
    this.checkLongPoll();
  }
  updateSession() {
    this.seqNo = 0;
    this.prevSessionID = this.sessionID;
    this.sessionID = new Array(8);
    random(this.sessionID);
    dispatch(AUTH.SET_SESSION_ID(this.sessionID, this.dcID));
  }

  updateSentMessage(sentMessageID) {
    if (!this.state.hasSent(sentMessageID)) return false;
    var sentMessage = this.state.getSent(sentMessageID);

    if (sentMessage instanceof NetContainer) {
      var newInner = [];
      for (var _iterator3 = sentMessage.inner, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref4 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref4 = _i3.value;
        }

        var innerID = _ref4;

        var innerSentMessage = this.updateSentMessage(innerID);
        if (innerSentMessage) newInner.push(innerSentMessage.msg_id);
      }
      sentMessage.inner = newInner;
    }
    dispatch(NETWORKER_STATE.SENT.DEL([sentMessage], this.dcID));
    this.state.deleteSent(sentMessage);
    var newId = generateID(this.uid);
    sentMessage.msg_id = newId;
    sentMessage.seq_no = this.generateSeqNo(sentMessage.notContentRelated || sentMessage.container);
    this.state.addSent(sentMessage);
    dispatch(NETWORKER_STATE.SENT.ADD(sentMessage, this.dcID));
    return sentMessage;
  }

  generateSeqNo(notContentRelated) {
    var seqNo = this.seqNo * 2;

    if (!notContentRelated) {
      seqNo++;
      this.seqNo++;
    }

    return seqNo;
  }

  wrapMtpCall(method, params, options) {
    var serializer = new Serialization({ mtproto: true }, this.uid);

    serializer.storeMethod(method, params);
    var seqNo = this.generateSeqNo();
    var message = new NetMessage(this.uid, seqNo, serializer.getBytes(true));
    var logGroup = log.group('Wrap mtp call');
    logGroup`Call method, msg_id, seqNo`(method, message.msg_id, seqNo);
    logGroup`Call method, params`(params);
    logGroup.groupEnd();
    this.pushMessage(message, options);
    // this.emit('net-message', {
    //   type  : 'mtp-call',
    //   msg_id: message.msg_id,
    //   message,
    //   method,
    //   params,
    //   options
    // })
    return message.deferred.promise;
  }

  wrapMtpMessage(object, options = {}) {

    var serializer = new Serialization({ mtproto: true }, this.uid);
    serializer.storeObject(object, 'Object', 'wrap_message');

    var seqNo = this.generateSeqNo(options.notContentRelated);
    var message = new NetMessage(this.uid, seqNo, serializer.getBytes(true));

    var logGroup = log.group('Wrap mtp message');
    var isAcks = object._ === 'msgs_ack';
    logGroup`MT message, msg_id, seqNo`(message.msg_id, seqNo);
    logGroup`MT message, result`(object);
    logGroup`is acks`(isAcks);
    logGroup.groupEnd();
    verifyInnerMessages(object.msg_ids);
    this.pushMessage(message, options);
    // this.emit('net-message', {
    //   type  : 'mtp-message',
    //   msg_id: message.msg_id,
    //   message,
    //   object,
    //   options
    // })
    return message;
  }

  wrapApiCall(method, params = {}, options, requestID = null) {
    var serializer = new Serialization(options, this.uid);
    var serialBox = serializer.writer;
    if (!this.connectionInited) {
      // serializer.storeInt(0xda9b0d0d, 'invokeWithLayer')
      // serializer.storeInt(Config.Schema.API.layer, 'layer')
      // serializer.storeInt(0x69796de9, 'initConnection')
      // serializer.storeInt(Config.App.id, 'api_id')
      // serializer.storeString(navigator.userAgent || 'Unknown UserAgent', 'device_model')
      // serializer.storeString(navigator.platform || 'Unknown Platform', 'system_version')
      // serializer.storeString(Config.App.version, 'app_version')
      // serializer.storeString(navigator.language || 'en', 'lang_code')
      var mapper = storeIntString(serialBox);
      mapObjIndexed(mapper, this.appConfig);
    }

    if (options.afterMessageID) {
      writeInt(serialBox, 0xcb9f372d, 'invokeAfterMsg');
      writeLong(serialBox, options.afterMessageID, 'msg_id');
    }

    options.resultType = serializer.storeMethod(method, params);

    var seqNo = this.generateSeqNo();
    var message = new NetMessage(this.uid, seqNo, serializer.getBytes(true));
    message.isAPI = true;
    message.requestID = requestID;
    log(`Api call`)(method);
    log(`|      |`, `msg_id`, `seqNo`)(message.msg_id, seqNo);
    log(`|      |`, `params`)(params);
    log(`|      |`, `options`)(options);
    this.pushMessage(message, options);
    // this.emit('net-message', {
    //   type  : 'api-call',
    //   msg_id: message.msg_id,
    //   message,
    //   method,
    //   params,
    //   options
    // })
    return message.deferred.promise;
  }

  pushMessage(message, options = {}) {
    message.copyOptions(options);
    dispatch(NETWORKER_STATE.SENT.ADD(message, this.dcID));
    dispatch(NETWORKER_STATE.PENDING.ADD([message.msg_id], this.dcID));
    this.emit('push-message', {
      threadID: this.threadID,
      message,
      options
    });
    this.state.addSent(message);
    this.state.setPending(message.msg_id);

    if (!options.noShedule) this.sheduleRequest();
    if (is(Object, options)) options.messageID = message.msg_id;
  }

  pushResend(messageID, delay = 0) {
    var value = tsNow() + delay;
    var sentMessage = this.state.getSent(messageID);
    if (sentMessage instanceof NetContainer) {
      for (var _iterator4 = sentMessage.inner, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref5 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref5 = _i4.value;
        }

        var msg = _ref5;

        this.state.setPending(msg, value);
      }
      dispatch(NETWORKER_STATE.PENDING.ADD(sentMessage.inner, this.dcID));
    } else {
      dispatch(NETWORKER_STATE.PENDING.ADD([messageID], this.dcID));
      this.state.setPending(messageID, value);
    }
    this.sheduleRequest(delay);
  }

  checkConnection() {
    return _asyncToGenerator(function* () {})();
  }

  toggleOffline(enabled) {
    // console.log('toggle ', enabled, this.dcID, this.iii)
    if (!this.offline !== undefined && this.offline == enabled) return false;

    this.offline = enabled;

    if (this.offline) {
      smartTimeout.cancel(this.nextReqPromise);
      delete this.nextReq;

      if (this.checkConnectionPeriod < 1.5) this.checkConnectionPeriod = 0;

      this.checkConnectionPromise = smartTimeout(this.checkConnection, parseInt(this.checkConnectionPeriod * 1000));
      this.checkConnectionPeriod = Math.min(30, (1 + this.checkConnectionPeriod) * 1.5);

      this.onOnlineCb = this.checkConnection;
      this.emit('net.offline', this.onOnlineCb);
    } else {
      this.longPoll.pendingTime = Date.now();
      //NOTE check long state was here
      this.checkLongPoll().then(() => {});
      this.sheduleRequest();

      if (this.onOnlineCb) this.emit('net.online', this.onOnlineCb);

      smartTimeout.cancel(this.checkConnectionPromise);
    }
  }
  performResend() {
    if (this.state.hasResends()) {
      var resendMsgIDs = [...this.state.getResends()];
      var resendOpts = { noShedule: true, notContentRelated: true
        // console.log('resendReq messages', resendMsgIDs)
      };var msg = this.wrapMtpMessage({
        _: 'msg_resend_req',
        msg_ids: resendMsgIDs
      }, resendOpts);
      this.lastResendReq = { req_msg_id: msg.msg_id, resend_msg_ids: resendMsgIDs };
    }
  }


  requestPerformer(message, noResponseMsgs, response) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        _this2.toggleOffline(false);
        // const response = await this.parseResponse(result.data)
        log(`Server response`, `dc${_this2.dcID}`)(response);
        log(`message`)(message);

        yield _this2.processMessage(response.response, response.messageID, response.sessionID);
        var sentDel = [];
        for (var _iterator5 = noResponseMsgs, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
          var _ref6;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref6 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref6 = _i5.value;
          }

          var msgID = _ref6;

          if (_this2.state.hasSent(msgID)) {
            var msg = _this2.state.getSent(msgID);
            sentDel.push(msg);
            _this2.state.deleteSent(msg);
            msg.deferred.resolve();
          }
        }dispatch(NETWORKER_STATE.SENT.DEL(sentDel, _this2.dcID));
        _this2.checkConnectionPeriod = Math.max(1.1, Math.sqrt(_this2.checkConnectionPeriod));

        //return
        _this2.checkLongPoll(); //TODO Bluebird warning here
      } catch (error) {
        console.log('Encrypted request failed', error);
        var noRespPending = [];
        var noRespSent = [];
        if (message instanceof NetContainer) {
          for (var _iterator6 = message.inner, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
            var _ref7;

            if (_isArray6) {
              if (_i6 >= _iterator6.length) break;
              _ref7 = _iterator6[_i6++];
            } else {
              _i6 = _iterator6.next();
              if (_i6.done) break;
              _ref7 = _i6.value;
            }

            var _msgID = _ref7;

            _this2.state.setPending(_msgID);
          }
          noRespSent.push(message);
          dispatch(NETWORKER_STATE.PENDING.ADD(message.inner, _this2.dcID));
          _this2.state.deleteSent(message);
        } else {
          dispatch(NETWORKER_STATE.PENDING.ADD([message.msg_id], _this2.dcID));
          _this2.state.setPending(message.msg_id);
        }

        for (var _iterator7 = noResponseMsgs, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
          var _ref8;

          if (_isArray7) {
            if (_i7 >= _iterator7.length) break;
            _ref8 = _iterator7[_i7++];
          } else {
            _i7 = _iterator7.next();
            if (_i7.done) break;
            _ref8 = _i7.value;
          }

          var _msgID2 = _ref8;

          if (_this2.state.hasSent(_msgID2)) {
            var _msg = _this2.state.getSent(_msgID2);
            noRespPending.push(_msgID2);
            noRespSent.push(_msg);
            _this2.state.deleteSent(_msg);
            _this2.state.deletePending(_msgID2);
            _msg.deferred.reject();
          }
        }dispatch(NETWORKER_STATE.SENT.DEL(noRespSent, _this2.dcID));
        dispatch(NETWORKER_STATE.PENDING.DEL(noRespPending, _this2.dcID));
        _this2.toggleOffline(true);
        return Bluebird.reject(error);
      }
    })();
  }

  parseResponse(responseBuffer) {
    var _this3 = this;

    return _asyncToGenerator(function* () {

      var { msgKey, encryptedData } = readResponse({
        reader: new Deserialization(responseBuffer, {}, _this3.uid),
        response: responseBuffer,
        authKeyStored: _this3.authKeyID
      });

      var dataWithPadding = yield getDataWithPad({
        authKey: _this3.authKeyUint8,
        msgKey,
        encryptedData
      });

      var {
        hashData,
        seqNo,
        messageID,
        buffer,
        sessionID
      } = readHash({
        reader: new Deserialization(dataWithPadding, { mtproto: true }, _this3.uid),
        currentSession: _this3.sessionID,
        prevSession: _this3.prevSessionID,
        dataWithPadding
      });

      var deserializerOptions = {
        mtproto: true,
        getter: _this3.getMsgById
        //$FlowIssue
      };var response = yield parsedResponse({
        hashData,
        msgKey,
        reader: new Deserialization(buffer, deserializerOptions, _this3.uid)
      });

      return {
        response,
        messageID,
        sessionID,
        seqNo
      };
    })();
  }

  applyServerSalt(newServerSalt) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var serverSalt = longToBytes(newServerSalt);
      yield _this4.storage.set(`dc${_this4.dcID}_server_salt`, bytesToHex(serverSalt));

      dispatch(AUTH.SET_SERVER_SALT(serverSalt, _this4.dcID));
      _this4.serverSalt = serverSalt;
      return true;
    })();
  }

  sheduleRequest(delay = 0) {
    if (this.offline) this.checkConnection();
    var nextReq = tsNow() + delay;

    if (delay && this.nextReq && this.nextReq <= nextReq) return false;

    // console.log(dTime(), 'shedule req', delay)
    // console.trace()
    smartTimeout.cancel(this.nextReqPromise);
    if (delay > 0) this.nextReqPromise = smartTimeout(this.performSheduledRequest, delay);else immediate(this.performSheduledRequest);

    this.nextReq = nextReq;
  }

  ackMessage(msgID) {
    /*console.trace(msgID)
    if (this.pendingAcks.includes(msgID)) {
      debugger
    }*/
    // console.log('ack message', msgID)
    if (contains(msgID, this.pendingAcks)) return;
    this.pendingAcks.push(msgID);
    this.sheduleRequest(30000);
  }

  reqResendMessage(msgID) {
    log(`Req resend`)(msgID);
    this.state.addResend(msgID);
    this.sheduleRequest(100);
  }

  cleanupSent() {
    var notEmpty = false;
    // console.log('clean start', this.dcID/*, this.state.sent*/)
    var sentDel = [];
    for (var _iterator8 = this.state.sentIterator(), _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
      var _ref9;

      if (_isArray8) {
        if (_i8 >= _iterator8.length) break;
        _ref9 = _iterator8[_i8++];
      } else {
        _i8 = _iterator8.next();
        if (_i8.done) break;
        _ref9 = _i8.value;
      }

      var [msgID, message] = _ref9;

      var complete = true;
      if (message.notContentRelated && !this.state.hasPending(msgID)) {
        sentDel.push(message);
        // console.log('clean notContentRelated', msgID)
        this.state.deleteSent(message);
      } else if (message instanceof NetContainer) {
        for (var _iterator9 = message.inner, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
          var _ref10;

          if (_isArray9) {
            if (_i9 >= _iterator9.length) break;
            _ref10 = _iterator9[_i9++];
          } else {
            _i9 = _iterator9.next();
            if (_i9.done) break;
            _ref10 = _i9.value;
          }

          var inner = _ref10;

          if (this.state.hasSent(inner)) {
            // console.log('clean failed, found', msgID, message.inner[i],
            // this.state.getSent(message.inner[i]).seq_no)
            notEmpty = true;
            complete = false;
            break;
          }
        }
        // console.log('clean container', msgID)
        if (complete) {
          sentDel.push(message);
          this.state.deleteSent(message);
        }
      } else notEmpty = true;
    }
    dispatch(NETWORKER_STATE.SENT.DEL(sentDel, this.dcID));
    return !notEmpty;
  }

  processMessage(message, messageID, sessionID) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      if (!isFinite(messageID)) {
        throw new TypeError(`Message ID should be finite ${messageID} ${typeof messageID}`);
      }
      var msgidInt = parseInt(messageID, 10);
      if (msgidInt % 2) {
        console.warn('[MT] Server even message id: ', messageID, message);
        return;
      }
      _this5.emit('incoming-message', {
        threadID: _this5.threadID,
        message,
        messageID,
        sessionID
      });
      switch (message._) {
        case 'msg_container':
          {
            for (var _iterator10 = message.messages, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
              var _ref11;

              if (_isArray10) {
                if (_i10 >= _iterator10.length) break;
                _ref11 = _iterator10[_i10++];
              } else {
                _i10 = _iterator10.next();
                if (_i10.done) break;
                _ref11 = _i10.value;
              }

              var inner = _ref11;

              yield _this5.processMessage(inner, inner.msg_id, sessionID);
            }break;
          }
        case 'bad_server_salt':
          {
            log(`Bad server salt`)(message);
            var sentMessage = _this5.state.getSent(message.bad_msg_id);
            if (!sentMessage || sentMessage.seq_no != message.bad_msg_seqno) {
              log(`invalid message`)(message.bad_msg_id, message.bad_msg_seqno);
              throw new Error('[MT] Bad server salt for invalid message');
            }

            yield _this5.applyServerSalt(message.new_server_salt);
            _this5.pushResend(message.bad_msg_id);
            _this5.ackMessage(messageID);
            break;
          }
        case 'bad_msg_notification':
          {
            log(`Bad msg notification`)(message);
            var _sentMessage = _this5.state.getSent(message.bad_msg_id);
            if (!_sentMessage || _sentMessage.seq_no != message.bad_msg_seqno) {
              log(`invalid message`)(message.bad_msg_id, message.bad_msg_seqno);
              throw new Error('[MT] Bad msg notification for invalid message');
            }

            if (message.error_code == 16 || message.error_code == 17) {
              if (applyServerTime(_this5.uid, rshift32(messageID))) {
                log(`Update session`)();
                _this5.updateSession();
              }
              var badMessage = _this5.updateSentMessage(message.bad_msg_id);
              if (badMessage instanceof NetMessage) _this5.pushResend(badMessage.msg_id);
              _this5.ackMessage(messageID);
            }
            break;
          }
        case 'message':
          {
            if (_this5.lastServerMessages.indexOf(messageID) != -1) {
              // console.warn('[MT] Server same messageID: ', messageID)
              _this5.ackMessage(messageID);
              return;
            }
            _this5.lastServerMessages.push(messageID);
            if (_this5.lastServerMessages.length > 100) {
              _this5.lastServerMessages.shift();
            }
            yield _this5.processMessage(message.body, message.msg_id, sessionID);
            break;
          }
        case 'new_session_created':
          {
            // this.ackMessage(messageID)

            // this.processMessageAck(message.first_msg_id)
            // await this.applyServerSalt(message.server_salt)

            _this5.emit('new-session', {
              threadID: _this5.threadID,
              networkerDC: _this5.dcID,
              messageID,
              message
            });

            // const baseDcID = await this.storage.get('dc')
            // const updateCond =
            //   baseDcID === this.dcID &&
            //   !this.upload &&
            //   updatesProcessor
            // if (updateCond)
            //   updatesProcessor(message, true)

            break;
          }
        case 'msgs_ack':
          {
            message.msg_ids.forEach(_this5.processMessageAck);
            break;
          }
        case 'msg_detailed_info':
          {
            if (!_this5.state.hasSent(message.msg_id)) {
              _this5.ackMessage(message.answer_msg_id);
              break;
            }
            break;
          }
        case 'msg_new_detailed_info':
          {
            _this5.ackMessage(message.answer_msg_id);
            _this5.reqResendMessage(message.answer_msg_id);
            break;
          }
        case 'msgs_state_info':
          {
            _this5.ackMessage(message.answer_msg_id);
            var spliceCond = _this5.lastResendReq &&
            //eslint-disable-next-line
            _this5.lastResendReq.req_msg_id == message.req_msg_id;
            if (spliceCond) {
              var resendDel = [];
              for (var _iterator11 = _this5.lastResendReq.resend_msg_ids, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
                var _ref12;

                if (_isArray11) {
                  if (_i11 >= _iterator11.length) break;
                  _ref12 = _iterator11[_i11++];
                } else {
                  _i11 = _iterator11.next();
                  if (_i11.done) break;
                  _ref12 = _i11.value;
                }

                var badMsgID = _ref12;

                resendDel.push(badMsgID);
                _this5.state.deleteResent(badMsgID);
              }
              dispatch(NETWORKER_STATE.RESEND.DEL(resendDel, _this5.dcID));
            }
            break;
          }
        case 'rpc_result':
          {
            _this5.ackMessage(messageID);

            var sentMessageID = message.req_msg_id;
            var _sentMessage2 = _this5.state.getSent(sentMessageID);

            _this5.processMessageAck(sentMessageID);
            if (!_sentMessage2) break;

            if (message.result._ == 'rpc_error') {
              _this5.emit('rpc-error', {
                threadID: _this5.threadID,
                networkerDC: _this5.dcID,
                error: message.result,
                sentMessage: _sentMessage2,
                message
              });
            } else {
              _this5.emit('rpc-result', {
                threadID: _this5.threadID,
                networkerDC: _this5.dcID,
                message,
                sentMessage: _sentMessage2,
                result: message.result
              });
              if (_sentMessage2.isAPI) _this5.connectionInited = true;
            }
            dispatch(NETWORKER_STATE.SENT.DEL([_sentMessage2], _this5.dcID));
            _this5.state.deleteSent(_sentMessage2);
            break;
          }
        default:
          {
            _this5.ackMessage(messageID);
            _this5.emit('untyped-message', {
              threadID: _this5.threadID,
              networkerDC: _this5.dcID,
              message,
              messageID,
              sessionID,
              result: message.result
            });
            if (updatesProcessor) updatesProcessor(message, true);
            break;
          }
      }
    })();
  }
}

export var startAll = () => {
  if (akStopped) {
    akStopped = false;
    updatesProcessor({ _: 'new_session_created' }, true);
  }
};

export var stopAll = () => akStopped = true;

export var setUpdatesProcessor = callback => updatesProcessor = callback;

var verifyInnerMessages = messages => {
  if (messages.length !== new Set(messages).size) {
    console.log(`!!!!!!WARN!!!!!!`, 'container check failed', messages);
    // throw new Error('Container bug')
  }
};

export default NetworkerThread;
//# sourceMappingURL=index.js.map