{"version":3,"sources":["../../../src/service/authorizer/rsa-keys-manger.js"],"names":["Serialization","writeBytes","bytesToHex","sha1BytesSync","bytesFromHex","strDecToHex","KeyManager","uid","publisKeysHex","publicKeysParsed","prepared","mapPrepare","modulus","exponent","RSAPublicKey","rsaBox","writer","buffer","getBuffer","fingerprintBytes","slice","reverse","key","prepareRsaKeys","forEach","selectRsaKeyByFingerPrint","fingerprints","fingerprintHex","foundKey","fingerprint","Error","prepare","select"],"mappings":"AAEA,OAA+B,iBAA/B;AACA,OAA4B,wBAA5B;AACA,SAASA,aAAT,QAA8B,UAA9B;;AAEA,SAASC,UAAT,QAA2B,iBAA3B;;AAEA,SAASC,UAAT,EAAqBC,aAArB,EACEC,YADF,EACgBC,WADhB,QACmC,WADnC;;AAIA,OAAO,SAASC,UAAT,CACLC,GADK,EAELC,aAFK,EAGLC,gBAHK,EAIL;AACA,MAAIC,WAAW,KAAf;;AAEA,WAASC,UAAT,CAAoB,EAAEC,OAAF,EAAWC,QAAX,EAApB,EAAsD;AACpD,QAAMC,eAAe,IAAId,aAAJ,CAAkB,EAAlB,EAAsBO,GAAtB,CAArB;AACA,QAAMQ,SAASD,aAAaE,MAA5B;AACAf,eAAWc,MAAX,EAAmBX,aAAaQ,OAAb,CAAnB,CAAwC,SAAxC;AACAX,eAAWc,MAAX,EAAmBX,aAAaS,QAAb,CAAnB,CAAyC,SAAzC;;AAEA,QAAMI,SAASF,OAAOG,SAAP,EAAf;;AAEA,QAAMC,mBAAmBhB,cAAcc,MAAd,EAAsBG,KAAtB,CAA4B,CAAC,CAA7B,CAAzB;AACAD,qBAAiBE,OAAjB;AACA,QAAMC,MAAMpB,WAAWiB,gBAAX,CAAZ;AACA;AACAV,qBAAiBa,GAAjB,IAAwB;AACtBV,aADsB;AAEtBC;AAFsB,KAAxB;AAID;;AAED,WAASU,cAAT,GAA0B;AACxB,QAAIb,QAAJ,EAAc;AACdF,kBAAcgB,OAAd,CAAsBb,UAAtB;;AAEAD,eAAW,IAAX;AACD;;AAED,WAASe,yBAAT,CAAmCC,YAAnC,EAA2D;AACzDH;;AAEA,QAAII,uBAAJ;AAAA,QAAoBC,iBAApB;AACA,yBAA0BF,YAA1B,kHAAwC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,UAA7BG,WAA6B;;AACtCF,uBAAiBtB,YAAYwB,WAAZ,CAAjB;AACA;AACAD,iBAAWnB,iBAAiBkB,cAAjB,CAAX;AACA,UAAIC,QAAJ,EACE,uBAASC,WAAT,IAAyBD,QAAzB;AACH;AACD,UAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;AACD;;AAED,SAAO;AACLC,aAASR,cADJ;AAELS,YAASP;AAFJ,GAAP;AAID;;AAED,eAAenB,UAAf","file":"rsa-keys-manger.js","sourcesContent":["//@flow\n\nimport { type PublicKey } from '../main/index.h'\nimport { type Cached } from '../api-manager/index.h'\nimport { Serialization } from '../../tl'\n\nimport { writeBytes } from '../../tl/writer'\n\nimport { bytesToHex, sha1BytesSync,\n  bytesFromHex, strDecToHex } from '../../bin'\n\n\nexport function KeyManager(\n  uid: string,\n  publisKeysHex: PublicKey[],\n  publicKeysParsed: Cached<PublicKey>\n) {\n  let prepared = false\n\n  function mapPrepare({ modulus, exponent }: PublicKey) {\n    const RSAPublicKey = new Serialization({}, uid)\n    const rsaBox = RSAPublicKey.writer\n    writeBytes(rsaBox, bytesFromHex(modulus)/*, 'n'*/)\n    writeBytes(rsaBox, bytesFromHex(exponent)/*, 'e'*/)\n\n    const buffer = rsaBox.getBuffer()\n\n    const fingerprintBytes = sha1BytesSync(buffer).slice(-8)\n    fingerprintBytes.reverse()\n    const key = bytesToHex(fingerprintBytes)\n    //$FlowIssue obj[number] === obj[stringNumber]\n    publicKeysParsed[key] = {\n      modulus,\n      exponent\n    }\n  }\n\n  function prepareRsaKeys() {\n    if (prepared) return\n    publisKeysHex.forEach(mapPrepare)\n\n    prepared = true\n  }\n\n  function selectRsaKeyByFingerPrint(fingerprints: string[]) {\n    prepareRsaKeys()\n\n    let fingerprintHex, foundKey\n    for (const fingerprint of fingerprints) {\n      fingerprintHex = strDecToHex(fingerprint)\n      //$FlowIssue obj[number] === obj[stringNumber]\n      foundKey = publicKeysParsed[fingerprintHex]\n      if (foundKey)\n        return { fingerprint, ...foundKey }\n    }\n    throw new Error('[Key manager] No public key found')\n  }\n\n  return {\n    prepare: prepareRsaKeys,\n    select : selectRsaKeyByFingerPrint\n  }\n}\n\nexport default KeyManager\n"]}