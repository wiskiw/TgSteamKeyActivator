function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Bluebird from 'bluebird';

import blueDefer from '../../util/defer';
import { immediate } from 'mtproto-shared';
import '../main/index.h';
import '../api-manager/index.h';
import Config from '../../config-provider';
import { Serialization, Deserialization } from '../../tl';

import random from '../secure-random';
import { applyServerTime, tsNow } from '../time-manager';

import { bytesCmp, bytesToHex, sha1BytesSync, aesEncryptSync, rsaEncrypt, aesDecryptSync, bytesToArrayBuffer, bytesFromHex, bytesXor, generateNonce } from '../../bin';
import { bpe, str2bigInt, one, dup, sub_, sub, greater } from '../../vendor/leemon';

import primeHex from './prime-hex';
import KeyManager from './rsa-keys-manger';

import Logger from 'mtproto-logger';

var log = Logger`auth`;

// import { ErrorBadResponse } from '../../error'

import SendPlainReq from './send-plain-req';
import { TypeWriter } from '../../tl/type-buffer';

var concat = (e1, e2) => [...e1, ...e2];

var tmpAesKey = (serverNonce, newNonce) => {
  var arr1 = concat(newNonce, serverNonce);
  var arr2 = concat(serverNonce, newNonce);
  var key1 = sha1BytesSync(arr1);
  var key2 = sha1BytesSync(arr2).slice(0, 12);
  return key1.concat(key2);
};

var tmpAesIv = (serverNonce, newNonce) => {
  var arr1 = concat(serverNonce, newNonce);
  var arr2 = concat(newNonce, newNonce);
  var arr3 = newNonce.slice(0, 4);
  var key1 = sha1BytesSync(arr1);
  var key2 = sha1BytesSync(arr2);
  var res = key1.slice(12).concat(key2, arr3);
  return res;
};

var minSize = Math.ceil(64 / bpe) + 1;

var getTwoPow = () => {
  //Dirty cheat to count 2^(2048 - 64)
  //This number contains 496 zeroes in hex
  var arr = Array(496).fill('0');
  arr.unshift('1');
  var hex = arr.join('');
  var res = str2bigInt(hex, 16, minSize);
  return res;
};

var leemonTwoPow = getTwoPow();

var reqPqRequest = (() => {
  var _ref = _asyncToGenerator(function* (prepare, dcUrl, reqBox, sendPlainReq) {
    prepare();
    var deserializer = yield sendPlainReq(dcUrl, reqBox.getBuffer());
    //$FlowIssue
    var response = deserializer.fetchObject('ResPQ', 'ResPQ');
    return response;
  });

  return function reqPqRequest(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
})();

export function Auth(uid, publisKeysHex, publicKeysParsed) {
  var mtpSendReqPQ = (() => {
    var _ref2 = _asyncToGenerator(function* (auth) {
      var deferred = auth.deferred;
      log('Send req_pq')(bytesToHex(auth.nonce));

      var request = new Serialization({ mtproto: true }, uid);
      var reqBox = request.writer;
      request.storeMethod('req_pq', { nonce: auth.nonce });

      /*let deserializer
      try {
        await prepare()
        deserializer = await sendPlainReq(auth.dcUrl, reqBox.getBuffer())
      } catch (err) {
        console.error(dTime(), 'req_pq error', err.message)
        deferred.reject(err)
        throw err
      }*/
      try {
        var response = yield reqPqRequest(prepare, auth.dcUrl, reqBox, sendPlainReq);

        if (response._ !== 'resPQ') {
          var error = new Error(`[MT] resPQ response invalid: ${response._}`);
          deferred.reject(error);
          return Bluebird.reject(error);
        }
        if (!bytesCmp(auth.nonce, response.nonce)) {
          var _error = new Error('[MT] resPQ nonce mismatch');
          deferred.reject(_error);
          return Bluebird.reject(_error);
        }
        auth.serverNonce = response.server_nonce;
        auth.pq = response.pq;
        auth.fingerprints = response.server_public_key_fingerprints;

        log('Got ResPQ')(bytesToHex(auth.serverNonce), bytesToHex(auth.pq), auth.fingerprints);

        var key = select(auth.fingerprints);
        auth.publicKey = key;

        log('PQ factorization start')(auth.pq);
        var [_p, _q, it] = yield Config.common.Crypto.factorize({ bytes: auth.pq });

        auth.p = _p;
        auth.q = _q;
        log('PQ factorization done')(it);
      } catch (error) {
        log('Worker error')(error, error.stack);
        deferred.reject(error);
        throw error;
      }

      return auth;
    });

    return function mtpSendReqPQ(_x5) {
      return _ref2.apply(this, arguments);
    };
  })();

  var mtpSendReqDhParams = (() => {
    var _ref3 = _asyncToGenerator(function* (auth) {
      var deferred = auth.deferred;

      auth.newNonce = new Array(32);
      random(auth.newNonce);

      var data = new Serialization({ mtproto: true }, uid);
      var dataBox = data.writer;
      data.storeObject({
        _: 'p_q_inner_data',
        pq: auth.pq,
        p: auth.p,
        q: auth.q,
        nonce: auth.nonce,
        server_nonce: auth.serverNonce,
        new_nonce: auth.newNonce
      }, 'P_Q_inner_data', 'DECRYPTED_DATA');

      //$FlowIssue
      var hash = data.getBytes();
      var dataWithHash = sha1BytesSync(dataBox.getBuffer()).concat(hash);

      var request = new Serialization({ mtproto: true }, uid);
      var reqBox = request.writer;
      request.storeMethod('req_DH_params', {
        nonce: auth.nonce,
        server_nonce: auth.serverNonce,
        p: auth.p,
        q: auth.q,
        public_key_fingerprint: auth.publicKey.fingerprint,
        encrypted_data: rsaEncrypt(auth.publicKey, dataWithHash)
      });

      log('afterReqDH')('Send req_DH_params');

      var deserializer = void 0;
      try {
        deserializer = yield sendPlainReq(auth.dcUrl, reqBox.getBuffer());
      } catch (error) {
        deferred.reject(error);
        throw error;
      }

      //$FlowIssue
      var response = deserializer.fetchObject('Server_DH_Params', 'RESPONSE');

      if (response._ !== 'server_DH_params_fail' && response._ !== 'server_DH_params_ok') {
        var error = new Error(`[MT] Server_DH_Params response invalid: ${response._}`);
        deferred.reject(error);
        throw error;
      }

      if (!bytesCmp(auth.nonce, response.nonce)) {
        var _error2 = new Error('[MT] Server_DH_Params nonce mismatch');
        deferred.reject(_error2);
        throw _error2;
      }

      if (!bytesCmp(auth.serverNonce, response.server_nonce)) {
        var _error3 = new Error('[MT] Server_DH_Params server_nonce mismatch');
        deferred.reject(_error3);
        throw _error3;
      }

      if (response._ === 'server_DH_params_fail') {
        var newNonceHash = sha1BytesSync(auth.newNonce).slice(-16);
        if (!bytesCmp(newNonceHash, response.new_nonce_hash)) {
          var _error5 = new Error('[MT] server_DH_params_fail new_nonce_hash mismatch');
          deferred.reject(_error5);
          throw _error5;
        }
        var _error4 = new Error('[MT] server_DH_params_fail');
        deferred.reject(_error4);
        throw _error4;
      }

      // try {
      mtpDecryptServerDhDataAnswer(auth, response.encrypted_answer);
      // } catch (e) {
      //   deferred.reject(e)
      //   return false
      // }

      return auth;
    });

    return function mtpSendReqDhParams(_x6) {
      return _ref3.apply(this, arguments);
    };
  })();

  var mtpSendSetClientDhParams = (() => {
    var _ref4 = _asyncToGenerator(function* (auth) {
      var deferred = auth.deferred;
      var gBytes = bytesFromHex(auth.g.toString(16));

      auth.b = new Array(256);
      random(auth.b);

      var gB = yield Config.common.Crypto.modPow({
        x: gBytes,
        y: auth.b,
        m: auth.dhPrime
      });
      var data = new Serialization({ mtproto: true }, uid);

      data.storeObject({
        _: 'client_DH_inner_data',
        nonce: auth.nonce,
        server_nonce: auth.serverNonce,
        retry_id: [0, auth.retry++],
        g_b: gB
      }, 'Client_DH_Inner_Data', 'client_DH');

      //$FlowIssue
      var hash = data.getBytes();
      var dataWithHash = sha1BytesSync(data.writer.getBuffer()).concat(hash);

      var encryptedData = aesEncryptSync(dataWithHash, auth.tmpAesKey, auth.tmpAesIv);

      var request = new Serialization({ mtproto: true }, uid);

      request.storeMethod('set_client_DH_params', {
        nonce: auth.nonce,
        server_nonce: auth.serverNonce,
        encrypted_data: encryptedData
      });

      log('onGb')('Send set_client_DH_params');

      var deserializer = yield sendPlainReq(auth.dcUrl, request.writer.getBuffer());

      //$FlowIssue
      var response = deserializer.fetchObject('Set_client_DH_params_answer', 'client_dh');

      if (response._ != 'dh_gen_ok' && response._ != 'dh_gen_retry' && response._ != 'dh_gen_fail') {
        var error = new Error(`[MT] Set_client_DH_params_answer response invalid: ${response._}`);
        deferred.reject(error);
        throw error;
      }

      if (!bytesCmp(auth.nonce, response.nonce)) {
        var _error6 = new Error('[MT] Set_client_DH_params_answer nonce mismatch');
        deferred.reject(_error6);
        throw _error6;
      }

      if (!bytesCmp(auth.serverNonce, response.server_nonce)) {
        var _error7 = new Error('[MT] Set_client_DH_params_answer server_nonce mismatch');
        deferred.reject(_error7);
        throw _error7;
      }

      var authKey = yield Config.common.Crypto.modPow({
        x: auth.gA,
        y: auth.b,
        m: auth.dhPrime
      });

      var authKeyHash = sha1BytesSync(authKey),
          authKeyAux = authKeyHash.slice(0, 8),
          authKeyID = authKeyHash.slice(-8);

      log('Got Set_client_DH_params_answer')(response._);
      switch (response._) {
        case 'dh_gen_ok':
          {
            var newNonceHash1 = sha1BytesSync(auth.newNonce.concat([1], authKeyAux)).slice(-16);

            if (!bytesCmp(newNonceHash1, response.new_nonce_hash1)) {
              deferred.reject(new Error('[MT] Set_client_DH_params_answer new_nonce_hash1 mismatch'));
              return false;
            }

            var _serverSalt = bytesXor(auth.newNonce.slice(0, 8), auth.serverNonce.slice(0, 8));
            // console.log('Auth successfull!', authKeyID, authKey, serverSalt)

            auth.authKeyID = authKeyID;
            auth.authKey = authKey;
            auth.serverSalt = _serverSalt;

            deferred.resolve(auth);
            break;
          }
        case 'dh_gen_retry':
          {
            var newNonceHash2 = sha1BytesSync(auth.newNonce.concat([2], authKeyAux)).slice(-16);
            if (!bytesCmp(newNonceHash2, response.new_nonce_hash2)) {
              deferred.reject(new Error('[MT] Set_client_DH_params_answer new_nonce_hash2 mismatch'));
              return false;
            }

            return mtpSendSetClientDhParams(auth);
          }
        case 'dh_gen_fail':
          {
            var newNonceHash3 = sha1BytesSync(auth.newNonce.concat([3], authKeyAux)).slice(-16);
            if (!bytesCmp(newNonceHash3, response.new_nonce_hash3)) {
              deferred.reject(new Error('[MT] Set_client_DH_params_answer new_nonce_hash3 mismatch'));
              return false;
            }

            deferred.reject(new Error('[MT] Set_client_DH_params_answer fail'));
            return false;
          }
      }
    });

    return function mtpSendSetClientDhParams(_x7) {
      return _ref4.apply(this, arguments);
    };
  })();

  var sendPlainReq = SendPlainReq(uid);
  var { prepare, select } = KeyManager(uid, publisKeysHex, publicKeysParsed);

  function mtpDecryptServerDhDataAnswer(auth, encryptedAnswer) {
    auth.tmpAesKey = tmpAesKey(auth.serverNonce, auth.newNonce);
    auth.tmpAesIv = tmpAesIv(auth.serverNonce, auth.newNonce);

    var answerWithHash = aesDecryptSync(encryptedAnswer, auth.tmpAesKey, auth.tmpAesIv);

    var hash = answerWithHash.slice(0, 20);
    var answerWithPadding = answerWithHash.slice(20);
    var buffer = bytesToArrayBuffer(answerWithPadding);

    var deserializer = new Deserialization(buffer, { mtproto: true }, uid);

    //$FlowIssue
    var response = deserializer.fetchObject('Server_DH_inner_data', 'server_dh');

    if (response._ !== 'server_DH_inner_data') throw new Error(`[MT] server_DH_inner_data response invalid`);

    if (!bytesCmp(auth.nonce, response.nonce)) throw new Error('[MT] server_DH_inner_data nonce mismatch');

    if (!bytesCmp(auth.serverNonce, response.server_nonce)) throw new Error('[MT] server_DH_inner_data serverNonce mismatch');

    log('DecryptServerDhDataAnswer')('Done decrypting answer');
    auth.g = response.g;
    auth.dhPrime = response.dh_prime;
    auth.gA = response.g_a;
    auth.serverTime = response.server_time;
    auth.retry = 0;

    mtpVerifyDhParams(auth.g, auth.dhPrime, auth.gA);

    var offset = deserializer.getOffset();

    if (!bytesCmp(hash, sha1BytesSync(answerWithPadding.slice(0, offset)))) throw new Error('[MT] server_DH_inner_data SHA1-hash mismatch');

    auth.localTime = tsNow();
    applyServerTime(uid, auth.serverTime, auth.localTime);
  }

  var innerLog = log('VerifyDhParams');

  function mtpVerifyDhParams(g, dhPrime, gA) {
    innerLog('begin');
    var dhPrimeHex = bytesToHex(dhPrime);
    if (g !== 3 || dhPrimeHex !== primeHex)
      // The verified value is from https://core.telegram.org/mtproto/security_guidelines
      throw new Error('[MT] DH params are not verified: unknown dhPrime');
    innerLog('dhPrime cmp OK');

    var dhPrimeLeemon = str2bigInt(dhPrimeHex, 16, minSize);
    var gALeemon = str2bigInt(bytesToHex(gA), 16, minSize);
    var dhDec = dup(dhPrimeLeemon);
    sub_(dhDec, one);
    var case1 = !greater(gALeemon, one);
    var case2 = !greater(dhDec, gALeemon);
    if (case1) throw new Error('[MT] DH params are not verified: gA <= 1');

    if (case2) throw new Error('[MT] DH params are not verified: gA >= dhPrime - 1');
    var case3 = !!greater(leemonTwoPow, gALeemon);
    var dhSubPow = dup(dhPrimeLeemon);
    sub(dhSubPow, leemonTwoPow);
    var case4 = !greater(dhSubPow, gALeemon);
    if (case3) throw new Error('[MT] DH params are not verified: gA < 2^{2048-64}');
    if (case4) throw new Error('[MT] DH params are not verified: gA > dhPrime - 2^{2048-64}');
    innerLog('2^{2048-64} < gA < dhPrime-2^{2048-64} OK');

    return true;
  }

  var authChain = auth => mtpSendReqPQ(auth).then(mtpSendReqDhParams).then(mtpSendSetClientDhParams);

  function mtpAuth(dcID, cached, dcUrl) {
    if (cached[dcID]) return cached[dcID].promise;
    log('mtpAuth', 'dcID', 'dcUrl')(dcID, dcUrl);
    var nonce = generateNonce();

    if (!dcUrl) return Bluebird.reject(new Error(`[MT] No server found for dc ${dcID} url ${dcUrl}`));

    var auth = {
      dcID,
      dcUrl,
      nonce,
      deferred: blueDefer()
    };

    var onFail = err => {
      log('authChain', 'error')(err);
      cached[dcID].reject(err);
      delete cached[dcID];
      return Bluebird.reject(err);
    };

    try {
      immediate(authChain, auth);
    } catch (err) {
      return onFail(err);
    }

    cached[dcID] = auth.deferred;

    cached[dcID].promise.catch(onFail);

    return cached[dcID].promise;
  }

  return mtpAuth;
}
export default Auth;
//# sourceMappingURL=index.js.map