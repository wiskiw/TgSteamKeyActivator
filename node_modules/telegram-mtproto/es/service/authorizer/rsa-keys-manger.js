import '../main/index.h';
import '../api-manager/index.h';
import { Serialization } from '../../tl';

import { writeBytes } from '../../tl/writer';

import { bytesToHex, sha1BytesSync, bytesFromHex, strDecToHex } from '../../bin';

export function KeyManager(uid, publisKeysHex, publicKeysParsed) {
  var prepared = false;

  function mapPrepare({ modulus, exponent }) {
    var RSAPublicKey = new Serialization({}, uid);
    var rsaBox = RSAPublicKey.writer;
    writeBytes(rsaBox, bytesFromHex(modulus) /*, 'n'*/);
    writeBytes(rsaBox, bytesFromHex(exponent) /*, 'e'*/);

    var buffer = rsaBox.getBuffer();

    var fingerprintBytes = sha1BytesSync(buffer).slice(-8);
    fingerprintBytes.reverse();
    var key = bytesToHex(fingerprintBytes);
    //$FlowIssue obj[number] === obj[stringNumber]
    publicKeysParsed[key] = {
      modulus,
      exponent
    };
  }

  function prepareRsaKeys() {
    if (prepared) return;
    publisKeysHex.forEach(mapPrepare);

    prepared = true;
  }

  function selectRsaKeyByFingerPrint(fingerprints) {
    prepareRsaKeys();

    var fingerprintHex = void 0,
        foundKey = void 0;
    for (var _iterator = fingerprints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var fingerprint = _ref;

      fingerprintHex = strDecToHex(fingerprint);
      //$FlowIssue obj[number] === obj[stringNumber]
      foundKey = publicKeysParsed[fingerprintHex];
      if (foundKey) return Object.assign({ fingerprint }, foundKey);
    }
    throw new Error('[Key manager] No public key found');
  }

  return {
    prepare: prepareRsaKeys,
    select: selectRsaKeyByFingerPrint
  };
}

export default KeyManager;
//# sourceMappingURL=rsa-keys-manger.js.map