{"version":3,"sources":["../src/pull-stream.js"],"names":["append","prepend","head","tail","Property","Logger","log","PullStream","constructor","source","consumer","controlStream","buffer","empty","length","busy","locked","isTerminated","cancel","noop","next","bind","fallback","observe","val","push","skipRepeats","update","feed","Array","isArray","concat","pushFirst","clean","replace","list","stop","Symbol","iterator","faucet","init","prop","stream","skip","multicast","faucetC"],"mappings":"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","file":"pull-stream.js","sourcesContent":["//@flow\n\nimport { append, prepend, head, tail } from 'ramda'\nimport { type Stream } from 'most'\nimport Property from './property'\nimport Logger from 'mtproto-logger'\nconst log = Logger`pull-stream`\n\nexport interface Consumer<T> {\n  (next: () => void, fallback: (val: T) => void): (val: T) => () => void\n}\n\nexport default class PullStream<T> {\n  source: Stream<T>\n  consumer: (val: T) => () => void\n  buffer: T[] = []\n  empty: boolean = true\n  length: number = 0\n  busy: boolean = true\n  locked: boolean = true\n  isTerminated: boolean = false\n  $SymbolIterator: Iterator<T>\n  constructor(source: Stream<T>, consumer: Consumer<T>, controlStream: Stream<boolean>) {\n    this.source = source\n    this.consumer = consumer(\n      this.next.bind(this),\n      this.fallback.bind(this)\n    )\n    source.observe((val: T) => {\n      log`source`(val)\n      this.push(val)\n    })\n    controlStream\n      .skipRepeats()\n      .observe(val => {\n        this.locked = !val\n        log`control`(val)\n        this.update()\n      })\n  }\n  update() {\n    log`update, busy, locked`(this.busy, this.locked)\n    this.length = this.buffer.length\n    if (!this.busy && !this.locked)\n      this.feed()\n  }\n  push<-E: T | T[]>(val: E) {\n    this.empty = false\n    this.buffer = Array.isArray(val)\n      ? this.buffer.concat(val)\n      : append(val, this.buffer)\n    this.update()\n  }\n  pushFirst(val: T | T[]) {\n    this.empty = false\n    this.buffer = Array.isArray(val)\n      ? val.concat(this.buffer)\n      : prepend(val, this.buffer)\n    this.update()\n  }\n  /**\n   * Force push next value into consumer\n   *\n   * @private\n   * @memberof PullStream\n   */\n  feed() {\n    const val = head(this.buffer)\n    if (val == null) return\n    this.busy = true\n    this.buffer = tail(this.buffer)\n    if (this.buffer.length === 0)\n      this.empty = true\n    this.length = this.buffer.length\n    this.cancel = this.consumer(val)\n  }\n  /**\n   * Callback, used **only** by consumer\n   *\n   * @private\n   * @memberof PullStream\n   */\n  next() {\n    if (this.empty)\n      this.busy = false\n    else\n      this.feed()\n  }\n  /**\n   * Cancellation callback, used **only** by consumer\n   *\n   * @private\n   * @memberof PullStream\n   */\n  fallback(val: T) {\n    this.busy = true\n    this.push(val)\n  }\n  cancel: () => void = noop\n  clean() {\n    this.empty = true\n    this.length = 0\n    this.buffer = []\n  }\n  replace(list: T[]) {\n    this.clean()\n    this.push(list)\n  }\n  stop() {\n    this.clean()\n    this.isTerminated = true\n    //$FlowIssue\n    this.push = noop\n    //$FlowIssue\n    this.feed = noop\n  }\n  //$FlowIssue\n  * [Symbol.iterator]() {\n    yield* this.buffer\n  }\n}\n\nexport function faucet<T>(source: Stream<T>, controlStream: Stream<boolean>): Stream<T> {\n  const init: T = ({}: any)\n  const prop = Property('', init)\n  const stream = prop.skip(1).multicast()\n  const consumer: Consumer<T> =\n    (next: () => void, fallback: (val: T) => void) => {\n      prop.observe(() => next())\n      return (val: T) => {\n        prop.next(val)\n        return () => {}\n      }\n    }\n  new PullStream(source, consumer, controlStream)\n  return stream\n}\n\nexport function faucetC(controlStream: Stream<boolean>) {\n  return function<T>(source: Stream<T>): Stream<T> {\n    return faucet(source, controlStream)\n  }\n}\n\nfunction noop() {}\n\n"]}