{"version":3,"sources":["../../../src/state/epic/net-request.js"],"names":["Stream","of","awaitPromises","equals","Logger","log","API","NET","NetMessage","apiMessage","encryptApiBytes","mtMessage","Config","NetworkerThread","Serialization","httpClient","homeDc","uid","whenActive","jsonError","makeApiBytes","message","thread","ctx","startMaxLength","body","length","writer","serverSalt","sessionID","encryptedBytes","opts","bytes","authKey","authKeyUint8","onNewRequest","action","thru","NEW_REQUEST","stream","combine","data","skipRepeatsWith","old","fresh","payload","map","CALL_TASK","onNewTask","tap","val","netReq","invoke","filter","netRequest","SEND","options","responseType","msgKey","rest","request","byteLength","mtBytes","authKeyID","url","dcMap","dcID","noResponseMsgs","result","post","RECEIVE_RESPONSE","recoverWith","err","NETWORK_ERROR","delay"],"mappings":"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","file":"net-request.js","sourcesContent":["//@flow\n\nimport { Stream, of, awaitPromises } from 'most'\nimport { equals } from 'ramda'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`net-request`\n\nimport { API, NET } from '../action'\nimport { NetMessage } from '../../service/networker/net-message'\nimport { apiMessage, encryptApiBytes, mtMessage } from '../../service/chain/encrypted-message'\nimport Config from '../../config-provider'\nimport NetworkerThread from '../../service/networker/index'\nimport { Serialization } from '../../tl/index'\nimport { httpClient } from '../../http'\nimport { homeDc, uid, whenActive } from '../signal'\nimport jsonError from '../../util/json-error'\n// import ApiRequest from '../../service/main/request'\n\nfunction makeApiBytes({ message, thread }: {\n  message: NetMessage,\n  thread: NetworkerThread }\n) {\n  return apiMessage({\n    ctx       : new Serialization({ startMaxLength: message.body.length + 64 }, thread.uid).writer,\n    serverSalt: thread.serverSalt,\n    sessionID : thread.sessionID,\n    message\n  })\n}\n\nfunction encryptedBytes(opts: *): Promise<{|\n  encryptedBytes: ArrayBuffer,\n  msgKey: Uint8Array,\n|}> {\n  return encryptApiBytes({\n    bytes  : makeApiBytes(opts),\n    authKey: opts.thread.authKeyUint8\n  })\n}\n\ntype NetRequestPayload = {\n  payload: {\n    message: NetMessage,\n    options: Object,\n    threadID: string,\n    thread: NetworkerThread,\n  },\n  type: 'net/send',\n}\n// process.on('unhandledRejection', val => {\n//   console.log(val)\n//   console.trace('on')\n// })\n\nexport const onNewRequest = (action: Stream<any>) => action\n  .thru(API.NEW_REQUEST.stream)\n  .thru(whenActive)\n  .combine((data, homeDc) => ({ ...data, homeDc }), homeDc)\n  .combine((data, uid) => ({ ...data, uid }), uid)\n  .skipRepeatsWith((old, fresh) => equals(old.payload, fresh.payload))\n  .map(API.CALL_TASK)\n\nexport const onNewTask = (action: Stream<any>) => action\n  .thru(API.CALL_TASK.stream)\n  .thru(whenActive)\n  .map(({ payload }) => payload)\n  // .delay(50)\n  .tap(val => val.payload.netReq.invoke())\n  .filter(() => false)\n\nconst netRequest = (action: Stream<any>) => action\n  .thru(NET.SEND.stream)\n  .thru(whenActive)\n  .map(({ payload }: NetRequestPayload) => payload)\n  .map(async({ options, ...data }) => ({\n    ...data,\n    options: {\n      responseType: 'arraybuffer',\n      ...options,\n    },\n    data: await encryptedBytes(data)\n  }))\n  .thru(awaitPromises)\n  .map(({ data, ...opts }) => ({ ...data, ...opts }))\n  .map(({ encryptedBytes, thread, msgKey, ...rest }) => {\n    const request = new Serialization({\n      startMaxLength: encryptedBytes.byteLength + 256\n    }, thread.uid).writer\n\n    const mtBytes = mtMessage({\n      ctx      : request,\n      authKeyID: thread.authKeyID,\n      msgKey,\n      encryptedBytes\n    })\n    const url = Config.dcMap(thread.uid, thread.dcID)\n    return { thread, mtBytes, url, ...rest } })\n  .map(async({ options, mtBytes, message, thread, noResponseMsgs, url }) => ({\n    message,\n    thread,\n    noResponseMsgs,\n    result: await httpClient.post(url, mtBytes, options)\n  }))\n  .thru(awaitPromises)\n  .map(NET.RECEIVE_RESPONSE)\n  .recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))).delay(15))\n\n\nexport default netRequest\n"]}