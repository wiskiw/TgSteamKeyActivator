function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import { Stream, of, awaitPromises } from 'most';
import choose from 'mezza';

import Logger from 'mtproto-logger';
var log = Logger`epic-task`;

import { RpcApiError } from '../../error';
import { NET, API } from '../action';
import { whenActive, networker } from '../signal';
import jsonError from '../../util/json-error';
import { Left, Right, Either } from '../../util/either';

var requestMap = id => networker.map(net => net.get(id)).map(net => net && net.requestMap).startWith({}).filter(val => val != null).skipRepeats();

export var onTaskEnd = action => action.thru(e => API.CALL_RESULT.stream(e)).thru(whenActive).map(val => val.payload).combine((val, map) => Object.assign({}, val, {
  messages:
  // console.log(val.result),
  // console.log('map', map),
  chooseType(map)(val.result)
}), requestMap(2))
// .tap(val => console.log('val.messages', val.messages))
.map(val => Object.assign({}, val, {
  messages: Array.isArray(val.messages) ? val.messages.map(detectErrors) : val.messages
})).map(API.DONE_REQUEST);

export var receiveResponse = action => action.thru(e => NET.RECEIVE_RESPONSE.stream(e)).thru(whenActive).map(val => val.payload).map((() => {
  var _ref = _asyncToGenerator(function* ({ result, thread, message, noResponseMsgs }) {
    return {
      result: yield thread.parseResponse(result.data),
      noResponseMsgs,
      thread,
      message
    };
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
})()).thru(awaitPromises).map((() => {
  var _ref2 = _asyncToGenerator(function* ({ result, thread, message, noResponseMsgs }) {
    yield thread.requestPerformer(message, noResponseMsgs, result);
    return {
      result,
      thread,
      message
    };
  });

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
})()).thru(awaitPromises).map(API.CALL_RESULT).recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))).delay(15));

class MsgId {
  constructor(real, box, req, map) {
    this.real = real;
    this.box = box;
    this.req = req;
    this.linked = map[req];
  }
  static container(box, map) {
    return new MsgId(box, box, box, map);
  }
  static single(real, req, map) {
    return new MsgId(real, real, req, map);
  }
  static of(real, box, req, map) {
    return new MsgId(real, box, req, map);
  }
}

var chooseType = map => choose({
  Single: val => isObject(val) && isObject(val.response) && val.response._ === 'rpc_result',
  Container: val => isObject(val) && isObject(val.response) && val.response._ === 'msg_container'
}, {
  Single(val) {
    var type = val.response._;
    var data = val.response;
    if (isObject(val.response.result)) {
      type = val.response.result._;
      data = val.response.result;
    }
    return [{
      ids: MsgId.single(val.messageID, val.response.req_msg_id, map),
      type,
      meta: {},
      data
    }];
  },
  Container(val) {
    var container = {
      ids: MsgId.container(val.messageID, map),
      type: 'msg_container',
      meta: {},
      data: val.response.messages.map(msg => msg.msg_id)
    };
    var result = [container];
    for (var _iterator = val.response.messages, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref3 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref3 = _i.value;
      }

      var message = _ref3;

      var isSingleMessage = message.body._ === 'rpc_result';
      var _ids = isSingleMessage ? MsgId.of(message.msg_id, val.messageID, message.body.req_msg_id, map) : MsgId.of(message.msg_id, val.messageID, message.msg_id, map);
      var _data = isSingleMessage ? message.body.result : message.body;
      result.push({
        ids: _ids,
        type: message.body._,
        meta: {},
        data: _data
      });
    }
    return result;
  },
  _: val => ({ type: 'Other', val })
});

function detectErrors(message) {
  var type = message.type;
  if (type === 'rpc_error') {
    //$FlowIssue
    var _data2 = RpcApiError.of(message.data);
    //$FlowIssue
    return Left(Object.assign({}, message, { data: _data2, type }));
  } else {
    //$FlowIssue
    var cast = message;
    return Right(cast);
  }
}

function isObject(obj) {
  return typeof obj === 'object' && obj != null;
}
//# sourceMappingURL=task.js.map