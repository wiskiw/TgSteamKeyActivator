{"version":3,"sources":["../../../src/state/epic/task.js"],"names":["Stream","of","awaitPromises","choose","Logger","log","RpcApiError","NET","API","whenActive","networker","jsonError","Left","Right","Either","requestMap","id","map","net","get","startWith","filter","val","skipRepeats","onTaskEnd","action","thru","e","CALL_RESULT","stream","payload","combine","messages","chooseType","result","Array","isArray","detectErrors","DONE_REQUEST","receiveResponse","RECEIVE_RESPONSE","thread","message","noResponseMsgs","parseResponse","data","requestPerformer","recoverWith","err","NETWORK_ERROR","delay","MsgId","constructor","real","box","req","linked","container","single","Single","isObject","response","_","Container","type","ids","messageID","req_msg_id","meta","msg","msg_id","isSingleMessage","body","push","cast","obj"],"mappings":"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","file":"task.js","sourcesContent":["//@flow\n\nimport { Stream, of, awaitPromises } from 'most'\nimport choose from 'mezza'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`epic-task`\n\nimport { RpcApiError } from '../../error'\nimport { NET, API } from '../action'\nimport { whenActive, networker } from '../signal'\nimport jsonError from '../../util/json-error'\nimport { Left, Right, Either } from '../../util/either'\n\nexport type TaskEndData = {\n  messages: Either<UniMessageR, UniMessageL>[]\n}\n\nconst requestMap = (id: number) => networker\n  .map(net => net.get(id))\n  .map(net => net && net.requestMap)\n  .startWith({})\n  .filter(val => val != null)\n  .skipRepeats()\n\nexport const onTaskEnd = (action: Stream<any>) => action\n  .thru(e => API.CALL_RESULT.stream(e))\n  .thru(whenActive)\n  .map(val => val.payload)\n  .combine((val, map) => ({\n    ...val,\n    messages: (\n      // console.log(val.result),\n      // console.log('map', map),\n      chooseType(map)(val.result))\n  }), requestMap(2))\n  // .tap(val => console.log('val.messages', val.messages))\n  .map(val => ({\n    ...val,\n    messages: Array.isArray(val.messages)\n      ? val.messages.map(detectErrors)\n      : val.messages\n  }))\n  .map(API.DONE_REQUEST)\n\nexport const receiveResponse = (action: Stream<any>) => action\n  .thru(e => NET.RECEIVE_RESPONSE.stream(e))\n  .thru(whenActive)\n  .map(val => val.payload)\n  .map(async({ result, thread, message, noResponseMsgs }) => ({\n    result: await thread.parseResponse(result.data),\n    noResponseMsgs,\n    thread,\n    message\n  }))\n  .thru(awaitPromises)\n  .map(async({ result, thread, message, noResponseMsgs }) => {\n    await thread.requestPerformer(message, noResponseMsgs, result)\n    return {\n      result,\n      thread,\n      message\n    }\n  })\n  .thru(awaitPromises)\n  .map(API.CALL_RESULT)\n  .recoverWith(err => of(NET.NETWORK_ERROR(jsonError(err))).delay(15))\n\nclass MsgId {\n  real: string\n  box: string\n  req: string\n  linked: string | void\n  constructor(real: string, box: string, req: string, map: { [req: string]: string }) {\n    this.real = real\n    this.box = box\n    this.req = req\n    this.linked = map[req]\n  }\n  static container(box: string, map: { [req: string]: string }) {\n    return new MsgId(box, box, box, map)\n  }\n  static single(real: string, req: string, map: { [req: string]: string }) {\n    return new MsgId(real, real, req, map)\n  }\n  static of(real: string, box: string, req: string, map: { [req: string]: string }) {\n    return new MsgId(real, box, req, map)\n  }\n}\n\ntype TaskResult<Response> = {\n  messageID: string,\n  seqNo: number,\n  response: Response,\n}\n\ntype SingleMessage = {\n  _: 'rpc_result',\n  req_msg_id: string,\n  result: Object,\n}\n\ntype ContainerMessage = {\n  _: 'msg_container',\n  messages: InnerMessage[]\n}\n\ntype InnerMessage = {\n  _: 'message',\n  msg_id: string,\n  seqno: number,\n  body: SingleMessage | Object,\n}\n\ntype UniMessageL = {\n  ids: MsgId,\n  type: 'rpc_error',\n  meta: {[key: string]: mixed},\n  data: RpcApiError,\n}\n\ntype UniMessageR = {\n  ids: MsgId,\n  type: 'rpc_result' | 'msg_container' | 'message',\n  meta: {[key: string]: mixed},\n  data: Object | string[],\n}\n\ntype UniMessage = {\n  ids: MsgId,\n  //$FlowIssue\n  type: 'rpc_result' | 'msg_container' | 'message' | 'rpc_error',\n  meta: {[key: string]: mixed},\n  data: Object | string[] | RpcApiError,\n}\n\ntype TaskResultRaw = TaskResult<SingleMessage | ContainerMessage>\n\ntype ChooseType =\n  (map: { [req: string]: string }) =>\n    (val: TaskResultRaw) =>\n      UniMessage[]\n\nconst chooseType: ChooseType = (map) => choose({\n  Single: (val: ?TaskResultRaw) =>\n    isObject(val)\n    && isObject(val.response)\n    && val.response._ === 'rpc_result',\n  Container: (val: ?TaskResultRaw) =>\n    isObject(val)\n    && isObject(val.response)\n    && val.response._ === 'msg_container',\n}, {\n  Single(val: TaskResult<SingleMessage>): UniMessage[] {\n    let type = val.response._\n    let data = val.response\n    if (isObject(val.response.result)) {\n      type = val.response.result._\n      data = val.response.result\n    }\n    return [{\n      ids : MsgId.single(val.messageID, val.response.req_msg_id, map),\n      type,\n      meta: {},\n      data,\n    }]\n  },\n  Container(val: TaskResult<ContainerMessage>): UniMessage[] {\n    const container = {\n      ids : MsgId.container(val.messageID, map),\n      type: 'msg_container',\n      meta: {},\n      data: val.response.messages.map(msg => msg.msg_id),\n    }\n    const result: UniMessage[] = [container]\n    for (const message of val.response.messages) {\n      const isSingleMessage = message.body._ === 'rpc_result'\n      const ids = isSingleMessage\n        ? MsgId.of(message.msg_id, val.messageID, message.body.req_msg_id, map)\n        : MsgId.of(message.msg_id, val.messageID, message.msg_id, map)\n      const data = isSingleMessage\n        ? message.body.result\n        : message.body\n      result.push({\n        ids,\n        type: message.body._,\n        meta: {},\n        data\n      })\n    }\n    return result\n  },\n  _: (val) => ({ type: 'Other', val }),\n})\n\nfunction detectErrors(message: UniMessage): Either<UniMessageR, UniMessageL> {\n  const type = message.type\n  if (type === 'rpc_error') {\n    //$FlowIssue\n    const data = RpcApiError.of(message.data)\n    //$FlowIssue\n    return Left({ ...message, data, type })\n  } else {\n    //$FlowIssue\n    const cast: UniMessageR = message\n    return Right(cast)\n  }\n}\n\nfunction isObject(obj: mixed): boolean %checks {\n  return (\n    typeof obj === 'object'\n    && obj != null\n  )\n}\n"]}