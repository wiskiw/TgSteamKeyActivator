{"version":3,"sources":["../src/timeout.js"],"names":["immediateWrap","cancelToken","Symbol","timeoutRefs","WeakSet","pause","delay","r","setTimeout","smartTimeout","fn","args","newToken","checkRun","has","delete","promise","then","cancel","token","immediate","resolve","arg"],"mappings":";;;;;;QAqCgBA,a,GAAAA,a;;AAnChB;;;;;;AAEA,MAAMC,cAAcC,OAAO,cAAP,CAApB;;AAEA,MAAMC,cAAc,IAAIC,OAAJ,EAApB;;AAEO,MAAMC,wBAASC,KAAD,IAAkC,uBAAaC,KAAKC,WAAWD,CAAX,EAAcD,KAAd,CAAlB,CAAhD;;AAEA,MAAMG,sCAAe,CAAyBC,EAAzB,EAAmDJ,QAAiB,CAApE,EAAuE,GAAGK,IAA1E,KAAyF;AACnH,QAAMC,WAAWV,OAAO,WAAP,CAAjB;AACA,QAAMW,WAAW,MAAM;AACrB,QAAIV,YAAYW,GAAZ,CAAgBF,QAAhB,CAAJ,EAA+B;AAC7BT,kBAAYY,MAAZ,CAAmBH,QAAnB;AACA,aAAOF,GAAG,GAAGC,IAAN,CAAP;AACD,KAHD,MAGO,OAAO,KAAP;AACR,GALD;AAMA,QAAMK,UAAUX,MAAMC,KAAN,EAAaW,IAAb,CAAkBJ,QAAlB,CAAhB;AACA;AACAG,UAAQf,WAAR,IAAuBW,QAAvB;AACA,SAAOI,OAAP;AACD,CAZM;;AAcP,MAAME,SAASF,WAAW;AACxB,MAAI,CAACA,OAAD,IAAY,CAACA,QAAQf,WAAR,CAAjB,EAAuC,OAAO,KAAP;AACvC,QAAMkB,QAAQH,QAAQf,WAAR,CAAd;AACA,SAAOE,YAAYW,GAAZ,CAAgBK,KAAhB,IACHhB,YAAYY,MAAZ,CAAmBI,KAAnB,CADG,GAEH,KAFJ;AAGD,CAND;;AAQO,MAAMC,gCAAY,CAAyBV,EAAzB,EAAmD,GAAGC,IAAtD,KACvB,mBACGU,OADH,GAEGJ,IAFH,CAEQ,MAAMP,GAAG,GAAGC,IAAN,CAFd,CADK;;AAKA,SAASX,aAAT,CAA6BU,EAA7B,EAAwE;AAC7E,SAAQY,GAAD,IAAwB,mBAASD,OAAT,GAAmBJ,IAAnB,CAAwB,MAAMP,GAAGY,GAAH,CAA9B,CAA/B;AACD;;AAEDb,aAAaW,SAAb,GAAyBA,SAAzB;AACAX,aAAaS,MAAb,GAAsBA,MAAtB;;kBAEeT,Y","file":"timeout.js","sourcesContent":["//@flow\n\nimport Bluebird from 'bluebird'\n\nconst cancelToken = Symbol('cancel token')\n\nconst timeoutRefs = new WeakSet\n\nexport const pause = (delay: number): Promise<void> => new Bluebird(r => setTimeout(r, delay))\n\nexport const smartTimeout = <T, +A, +Args: Array<A>>(fn: (...args: Args) => T, delay?: number = 0, ...args: Args) => {\n  const newToken = Symbol('cancel id')\n  const checkRun = () => {\n    if (timeoutRefs.has(newToken)) {\n      timeoutRefs.delete(newToken)\n      return fn(...args)\n    } else return false\n  }\n  const promise = pause(delay).then(checkRun)\n  //$FlowIssue\n  promise[cancelToken] = newToken\n  return promise\n}\n\nconst cancel = promise => {\n  if (!promise || !promise[cancelToken]) return false\n  const token = promise[cancelToken]\n  return timeoutRefs.has(token)\n    ? timeoutRefs.delete(token)\n    : false\n}\n\nexport const immediate = <T, +A, +Args: Array<A>>(fn: (...args: Args) => T, ...args: Args): Promise<T> =>\n  Bluebird\n    .resolve()\n    .then(() => fn(...args))\n\nexport function immediateWrap<T, A>(fn: (arg: A) => T): (arg: A) => Promise<T> {\n  return (arg: A): Promise<T> => Bluebird.resolve().then(() => fn(arg))\n}\n\nsmartTimeout.immediate = immediate\nsmartTimeout.cancel = cancel\n\nexport default smartTimeout"]}