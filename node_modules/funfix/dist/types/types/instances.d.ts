import { Try, Option, Either } from "../core/disjunctions";
import { Eval } from "../effect/eval";
import { Future } from "../exec/future";
import { HK } from "./kinds";
import { Monad, MonadError } from "./monad";
import { Eq } from "./eq";
/**
 * Alias used for encoding higher-kinded types when implementing
 * type class instances.
 */
export declare type OptionK<A> = HK<Option<any>, A>;
/**
 * Type class instances provided by default for [[Option]].
 */
export declare class OptionInstances implements Monad<Option<any>>, Eq<Option<any>> {
    private __unit;
    eqv(lh: Option<any>, rh: Option<any>): boolean;
    pure<A>(a: A): Option<A>;
    unit(): Option<void>;
    ap<A, B>(fa: OptionK<A>, ff: OptionK<(a: A) => B>): Option<B>;
    map<A, B>(fa: OptionK<A>, f: (a: A) => B): Option<B>;
    map2<A, B, Z>(fa: OptionK<A>, fb: OptionK<B>, f: (a: A, b: B) => Z): Option<Z>;
    product<A, B>(fa: OptionK<A>, fb: OptionK<B>): Option<[A, B]>;
    flatMap<A, B>(fa: OptionK<A>, f: (a: A) => OptionK<B>): Option<B>;
    tailRecM<A, B>(a: A, f: (a: A) => OptionK<Either<A, B>>): Option<B>;
    followedBy: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<B>;
    followedByL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<B>;
    forEffect: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<A>;
    forEffectL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<A>;
    static readonly global: OptionInstances;
}
/**
 * Alias used for encoding higher-kinded types when implementing
 * type class instances.
 */
export declare type TryK<A> = HK<Try<any>, A>;
/**
 * Type class instances provided by default for [[Option]].
 */
export declare class TryInstances implements MonadError<Try<any>, any>, Eq<Try<any>> {
    private __unit;
    eqv(lh: Try<any>, rh: Try<any>): boolean;
    pure<A>(a: A): Try<A>;
    unit(): Try<void>;
    ap<A, B>(fa: TryK<A>, ff: TryK<(a: A) => B>): Try<B>;
    map<A, B>(fa: TryK<A>, f: (a: A) => B): Try<B>;
    map2<A, B, Z>(fa: TryK<A>, fb: TryK<B>, f: (a: A, b: B) => Z): Try<Z>;
    product<A, B>(fa: TryK<A>, fb: TryK<B>): Try<[A, B]>;
    flatMap<A, B>(fa: TryK<A>, f: (a: A) => TryK<B>): Try<B>;
    tailRecM<A, B>(a: A, f: (a: A) => TryK<Either<A, B>>): Try<B>;
    raise<A>(e: any): Try<A>;
    attempt<A>(fa: TryK<A>): Try<Either<any, A>>;
    recoverWith<A>(fa: TryK<A>, f: (e: any) => TryK<A>): Try<A>;
    recover<A>(fa: TryK<A>, f: (e: any) => A): Try<A>;
    followedBy: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<B>;
    followedByL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<B>;
    forEffect: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<A>;
    forEffectL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<A>;
    static global: TryInstances;
}
/**
 * Alias used for encoding higher-kinded types when implementing
 * type class instances.
 */
export declare type EitherK<L, R> = HK<Either<L, any>, R>;
/**
 * Type class instances provided by default for [[Either]].
 */
export declare class EitherInstances<L> implements Monad<Either<L, any>>, Eq<Either<L, any>> {
    private __unit;
    eqv(lh: Either<L, any>, rh: Either<L, any>): boolean;
    pure<A>(a: A): Either<L, A>;
    unit(): Either<L, void>;
    ap<A, B>(fa: EitherK<L, A>, ff: EitherK<L, (a: A) => B>): Either<L, B>;
    map<A, B>(fa: EitherK<L, A>, f: (a: A) => B): Either<L, B>;
    map2<A, B, Z>(fa: EitherK<L, A>, fb: EitherK<L, B>, f: (a: A, b: B) => Z): Either<L, Z>;
    product<A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>): Either<L, [A, B]>;
    flatMap<A, B>(fa: HK<Either<L, any>, A>, f: (a: A) => HK<Either<L, any>, B>): HK<Either<L, any>, B>;
    tailRecM<A, B>(a: A, f: (a: A) => HK<Either<L, any>, Either<A, B>>): HK<Either<L, any>, B>;
    followedBy: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, B>;
    followedByL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, B>;
    forEffect: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, A>;
    forEffectL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, A>;
    static global: EitherInstances<any>;
}
/**
 * Alias used for encoding higher-kinded types when implementing
 * type class instances.
 */
export declare type EvalK<A> = HK<Eval<any>, A>;
/**
 * Type class instances provided by default for [[Eval]].
 */
export declare class EvalInstances implements MonadError<Eval<any>, any> {
    pure<A>(a: A): Eval<A>;
    flatMap<A, B>(fa: EvalK<A>, f: (a: A) => EvalK<B>): Eval<B>;
    tailRecM<A, B>(a: A, f: (a: A) => EvalK<Either<A, B>>): Eval<B>;
    ap<A, B>(fa: EvalK<A>, ff: EvalK<(a: A) => B>): Eval<B>;
    map<A, B>(fa: EvalK<A>, f: (a: A) => B): Eval<B>;
    unit(): Eval<void>;
    raise<A>(e: any): Eval<A>;
    attempt<A>(fa: EvalK<A>): Eval<Either<any, A>>;
    recoverWith<A>(fa: EvalK<A>, f: (e: any) => EvalK<A>): Eval<A>;
    recover<A>(fa: EvalK<A>, f: (e: any) => A): Eval<A>;
    map2: <A, B, Z>(fa: EvalK<A>, fb: EvalK<B>, f: (a: A, b: B) => Z) => Eval<Z>;
    product: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => EvalK<[A, B]>;
    followedBy: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<B>;
    followedByL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<B>;
    forEffect: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<A>;
    forEffectL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<A>;
    static global: EvalInstances;
}
/**
 * Alias used for encoding higher-kinded types when implementing
 * type class instances.
 */
export declare type FutureK<A> = HK<Future<any>, A>;
/**
 * Type class instances provided by default for {@link Future}.
 */
export declare class FutureInstances implements MonadError<Future<any>, any> {
    pure<A>(a: A): Future<A>;
    flatMap<A, B>(fa: FutureK<A>, f: (a: A) => FutureK<B>): Future<B>;
    tailRecM<A, B>(a: A, f: (a: A) => FutureK<Either<A, B>>): Future<B>;
    ap<A, B>(fa: FutureK<A>, ff: FutureK<(a: A) => B>): Future<B>;
    map<A, B>(fa: FutureK<A>, f: (a: A) => B): Future<B>;
    unit(): Future<void>;
    raise<A>(e: any): Future<A>;
    attempt<A>(fa: FutureK<A>): Future<Either<any, A>>;
    recoverWith<A>(fa: FutureK<A>, f: (e: any) => FutureK<A>): Future<A>;
    recover<A>(fa: FutureK<A>, f: (e: any) => A): Future<A>;
    map2<A, B, Z>(fa: FutureK<A>, fb: FutureK<B>, f: (a: A, b: B) => Z): Future<Z>;
    product: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => FutureK<[A, B]>;
    followedBy: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<B>;
    followedByL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<B>;
    forEffect: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<A>;
    forEffectL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<A>;
    static global: FutureInstances;
}
