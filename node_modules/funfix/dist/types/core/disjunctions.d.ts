/**
 * Exposes data types for expression disjunctions:
 *
 * - {@link Either}: data type for expressing results with two possible
 *   outcome types (a disjoint union)
 * - {@link Option}: data type for expressing optional values
 * - {@link Try}: data type for representing the result of computations
 *   that may result in either success or failure
 *
 * Ã€ la carte imports work, assuming an ECMAScript 2015 compatible environment,
 * including ES2015 modules and `import` syntax:
 *
 * ```typescript
 * import { Either } from "funfix/dist/core/disjunction"
 * // ... or ...
 * import { Either } from "funfix"
 * ```
 *
 * In absence of ES2015 compatibility, you can still rely on working with the
 * packaged (`pkg.main`) universal distribution that works within all browsers
 * and environments.
 *
 * @module core/disjunction
 */
/***/
import * as std from "./std";
/**
 * Represents a value of one of two possible types (a disjoint union).
 *
 * A common use of Either is as an alternative to [[Option]] for dealing
 * with possible missing values. In this usage [[Option.none]] is replaced
 * with [[Either.left]] which can contain useful information and
 * [[Option.some]] is replaced with [[Either.right]].
 *
 * Convention dictates that `left` is used for failure and `right` is used
 * for success. Note that this `Either` type is right-biased, meaning that
 * operations such as `map`, `flatMap` and `filter` work on the `right` value
 * and if you want to work on the `left` value, then you need to do a `swap`.
 *
 * For example, you could use `Either<String, Int>` to detect whether an
 * input is a string or an number:
 *
 * ```typescript
 * function tryParseInt(str: string): Either<string, number> {
 *   const i = parseInt(value)
 *   return isNaN(i) ? Left(str) : Right(i)
 * }
 *
 * const result = tryParseInt("not an int")
 * if (result.isRight()) {
 *   console.log(`Increment: ${result.get}`)
 * } else {
 *   console.log(`ERROR: could not parse ${result.swap.get}`)
 * }
 * ```
 *
 * @final
 */
export declare class Either<L, R> implements std.IEquals<Either<L, R>> {
    private _isRight;
    private _rightRef;
    private _leftRef;
    private constructor();
    /**
     * Returns `true` if this is a `left`, `false` otherwise.
     *
     * ```typescript
     * Left("hello").isLeft() // true
     * Right(10).isLeft() // false
     * ```
     */
    isLeft(): boolean;
    /**
     * If the source is a `left` value, then returns it unchanged
     * and casted as a `Left`, otherwise throw exception.
     *
     * WARNING!
     *
     * This function is partial, the reference must be a `Left,
     * otherwise a runtime exception will get thrown. Use with care.
     *
     * @throws NoSuchElementError
     */
    left(): Either<L, never>;
    /**
     * Returns `true` if this is a `right`, `false` otherwise.
     *
     * ```typescript
     * Left("hello").isRight() // false
     * Right(10).isRight() // true
     * ```
     */
    isRight(): boolean;
    /**
     * If the source is a `right` value, then returns it unchanged
     * and casted as a `Right`, otherwise throw exception.
     *
     * WARNING!
     *
     * This function is partial, the reference must be a `Right,
     * otherwise a runtime exception will get thrown. Use with care.
     *
     * @throws NoSuchElementError
     */
    right(): Either<never, R>;
    /**
     * Returns true if this is a Right and its value is equal to `elem`
     * (as determined by the `equals` protocol), returns `false` otherwise.
     *
     * ```typescript
     * // True
     * Right("something").contains("something")
     *
     * // False because the values are different
     * Right("something").contains("anything") // false
     *
     * // False because the source is a `left`
     * Left("something").contains("something") // false
     * ```
     */
    contains(elem: R): boolean;
    /**
     * Returns `false` if the source is a `left`, or returns the result
     * of the application of the given predicate to the `right` value.
     *
     * ```typescript
     * // True, because it is a right and predicate holds
     * Right(20).exists(n => n > 10)
     *
     * // False, because the predicate returns false
     * Right(10).exists(n => n % 2 != 0)
     *
     * // False, because it is a left
     * Left(10).exists(n => n == 10)
     * ```
     */
    exists(p: (r: R) => boolean): boolean;
    /**
     * Filters `right` values with the given predicate, returning
     * the value generated by `zero` in case the source is a `right`
     * value and the predicate doesn't hold.
     *
     * Possible outcomes:
     *
     *  - Returns the existing value of `right` if this is a `right` value and the
     *    given predicate `p` holds for it
     *  - Returns `Left(zero())` if this is a `right` value
     *    and the given predicate `p` does not hold
     *  - Returns the current "left" value, if the source is a `Left`
     *
     * ```typescript
     * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)
     * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)
     * Left(7).filterOrElse(x => false, () => -1)    // Left(7)
     * ```
     */
    filterOrElse(p: (r: R) => boolean, zero: () => L): Either<L, R>;
    /**
     * Binds the given function across `right` values.
     *
     * This operation is the monadic "bind" operation.
     * It can be used to *chain* multiple `Either` references.
     */
    flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S>;
    /**
     * Applies the `left` function to [[Left]] values, and the
     * `right` function to [[Right]] values and returns the result.
     *
     * ```typescript
     * const maybeNum: Either<string, number> =
     *   tryParseInt("not a number")
     *
     * const result: string =
     *   maybeNum.fold(
     *     str => `Could not parse string: ${str}`,
     *     num => `Success: ${num}`
     *   )
     * ```
     */
    fold<S>(left: (l: L) => S, right: (r: R) => S): S;
    /**
     * Returns true if the source is a `left` or returns
     * the result of the application of the given predicate to the
     * `right` value.
     *
     * ```typescript
     * // True, because it is a `left`
     * Left("hello").forAll(x => x > 10)
     *
     * // True, because the predicate holds
     * Right(20).forAll(x => x > 10)
     *
     * // False, it's a right and the predicate doesn't hold
     * Right(7).forAll(x => x > 10)
     * ```
     */
    forAll(p: (r: R) => boolean): boolean;
    /**
     * Returns the `Right` value, if the source has one,
     * otherwise throws an exception.
     *
     * WARNING!
     *
     * This function is partial, the `Either` must be a `Right`, otherwise
     * a runtime exception will get thrown. Use with care.
     *
     * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`
     */
    get(): R;
    /**
     * Returns the value from this `right` or the given `fallback`
     * value if this is a `left`.
     *
     * ```typescript
     * Right(10).getOrElse(27) // 10
     * Left(10).getOrElse(27)  // 27
     * ```
     */
    getOrElse<RR>(fallback: RR): R | RR;
    /**
     * Returns the value from this `right` or a value generated
     * by the given `thunk` if this is a `left`.
     *
     * ```typescript
     * Right(10).getOrElseL(() => 27) // 10
     * Left(10).getOrElseL(() => 27)  // 27
     * ```
     */
    getOrElseL<RR>(thunk: () => RR): R | RR;
    /**
     * Transform the source if it is a `right` with the given
     * mapping function.
     *
     * ```typescript
     * Right(10).map(x => x + 17) // right(27)
     * Left(10).map(x => x + 17)  // left(10)
     * ```
     */
    map<C>(f: (r: R) => C): Either<L, C>;
    /**
     * Executes the given side-effecting function if the
     * source is a `right` value.
     *
     * ```typescript
     * Right(12).forAll(console.log) // prints 12
     * Left(10).forAll(console.log)  // silent
     * ```
     */
    forEach(cb: (r: R) => void): void;
    /**
     * If this is a `left`, then return the left value as a `right`
     * or vice versa.
     *
     * ```typescript
     * Right(10).swap() // left(10)
     * Left(20).swap()  // right(20)
     * ```
     */
    swap(): Either<R, L>;
    /**
     * Returns an `Option.some(right)` if the source is a `right` value,
     * or `Option.none` in case the source is a `left` value.
     */
    toOption(): Option<R>;
    /** Implements {@link IEquals.equals}. */
    equals(other: Either<L, R>): boolean;
    /** Implements {@link IEquals.hashCode}. */
    hashCode(): number;
    readonly _funKindF: Either<L, any>;
    readonly _funKindA: R;
    static readonly _funErasure: Either<any, any>;
    static left<L, R>(value: L): Either<L, R>;
    static right<L, R>(value: R): Either<L, R>;
    /**
     * Maps 2 `Either` values by the mapping function, returning a new
     * `Either` reference that is a `Right` only if both `Either` values are
     * `Right` values, otherwise it returns the first `Left` value noticed.
     *
     * ```typescript
     * // Yields Right(3)
     * Try.map2(Right(1), Right(2),
     *   (a, b) => a + b
     * )
     *
     * // Yields Left, because the second arg is a Left
     * Try.map2(Right(1), Left("error"),
     *   (a, b) => a + b
     * )
     * ```
     *
     * This operation is the `Applicative.map2`.
     */
    static map2<A1, A2, L, R>(fa1: Either<L, A1>, fa2: Either<L, A2>, f: (a1: A1, a2: A2) => R): Either<L, R>;
    /**
     * Maps 3 `Either` values by the mapping function, returning a new
     * `Either` reference that is a `Right` only if all 3 `Either` values are
     * `Right` values, otherwise it returns the first `Left` value noticed.
     *
     * ```typescript
     * // Yields Right(6)
     * Try.map3(Right(1), Right(2), Right(3),
     *   (a, b, c) => a + b + c
     * )
     *
     * // Yields Left, because the second arg is a Left
     * Try.map3(Right(1), Left("error"), Right(3),
     *   (a, b, c) => a + b + c
     * )
     * ```
     */
    static map3<A1, A2, A3, L, R>(fa1: Either<L, A1>, fa2: Either<L, A2>, fa3: Either<L, A3>, f: (a1: A1, a2: A2, a3: A3) => R): Either<L, R>;
    /**
     * Maps 4 `Either` values by the mapping function, returning a new
     * `Either` reference that is a `Right` only if all 4 `Either` values are
     * `Right` values, otherwise it returns the first `Left` value noticed.
     *
     * ```typescript
     * // Yields Right(10)
     * Try.map4(Right(1), Right(2), Right(3), Right(4),
     *   (a, b, c, d) => a + b + c + d
     * )
     *
     * // Yields Left, because the second arg is a Left
     * Try.map4(Right(1), Left("error"), Right(3), Right(4),
     *   (a, b, c, d) => a + b + c + d
     * )
     * ```
     */
    static map4<A1, A2, A3, A4, L, R>(fa1: Either<L, A1>, fa2: Either<L, A2>, fa3: Either<L, A3>, fa4: Either<L, A4>, f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Either<L, R>;
    /**
     * Maps 5 `Either` values by the mapping function, returning a new
     * `Either` reference that is a `Right` only if all 5 `Either` values are
     * `Right` values, otherwise it returns the first `Left` value noticed.
     *
     * ```typescript
     * // Yields Right(15)
     * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5),
     *   (a, b, c, d, e) => a + b + c + d + e
     * )
     *
     * // Yields Left, because the second arg is a Left
     * Try.map5(Right(1), Left("error"), Right(3), Right(4), Right(5),
     *   (a, b, c, d, e) => a + b + c + d + e
     * )
     * ```
     */
    static map5<A1, A2, A3, A4, A5, L, R>(fa1: Either<L, A1>, fa2: Either<L, A2>, fa3: Either<L, A3>, fa4: Either<L, A4>, fa5: Either<L, A5>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Either<L, R>;
    /**
     * Maps 6 `Either` values by the mapping function, returning a new
     * `Either` reference that is a `Right` only if all 6 `Either` values are
     * `Right` values, otherwise it returns the first `Left` value noticed.
     *
     * ```typescript
     * // Yields Right(21)
     * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5), Right(6),
     *   (a, b, c, d, e, f) => a + b + c + d + e + f
     * )
     *
     * // Yields Left, because the second arg is a Left
     * Try.map5(Right(1), Left("error"), Right(3), Right(4), Right(5), Right(6),
     *   (a, b, c, d, e, f) => a + b + c + d + e + f
     * )
     * ```
     */
    static map6<A1, A2, A3, A4, A5, A6, L, R>(fa1: Either<L, A1>, fa2: Either<L, A2>, fa3: Either<L, A3>, fa4: Either<L, A4>, fa5: Either<L, A5>, fa6: Either<L, A6>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Either<L, R>;
    /**
     * Keeps calling `f` until a `Right(b)` is returned.
     *
     * Based on Phil Freeman's
     * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.
     *
     * Described in {@link FlatMap.tailRecM}.
     */
    static tailRecM<L, A, B>(a: A, f: (a: A) => Either<L, Either<A, B>>): Either<L, B>;
}
/**
 * The `Left` data constructor represents the left side of the
 * [[Either]] disjoint union, as opposed to the [[Right]] side.
 */
export declare function Left<L>(value: L): Either<L, never>;
/**
 * The `Right` data constructor represents the right side of the
 * [[Either]] disjoint union, as opposed to the [[Left]] side.
 */
export declare function Right<R>(value: R): Either<never, R>;
/**
 * Represents optional values, inspired by Scala's `Option` and by
 * Haskell's `Maybe` data types.
 *
 * Option is an immutable data type, represented as a sum type, being
 * either a [[Some]], in case it contains a single element, or a [[None]],
 * in case it is empty.
 *
 * The most idiomatic way to use an `Option` instance is to treat it
 * as a collection or monad and use `map`,`flatMap`, `filter`,
 * or `forEach`.
 *
 * @final
 */
export declare class Option<A> implements std.IEquals<Option<A>> {
    private _isEmpty;
    private _ref;
    private constructor();
    /**
     * Returns the option's value.
     *
     * WARNING!
     *
     * This function is partial, the option must be non-empty, otherwise
     * a runtime exception will get thrown. Use with care.
     *
     * @throws [[NoSuchElementError]] in case the option is empty
     */
    get(): A;
    /**
     * Returns the option's value if the option is nonempty, otherwise
     * return the given `fallback`.
     *
     * See [[Option.getOrElseL]] for a lazy alternative.
     */
    getOrElse<AA>(fallback: AA): A | AA;
    /**
     * Returns the option's value if the option is nonempty, otherwise
     * return `null`.
     */
    orNull(): A | null;
    /**
     * Returns the option's value if the option is nonempty, otherwise
     * return the result of evaluating `thunk`.
     *
     * See [[Option.getOrElse]] for a strict alternative.
     */
    getOrElseL<AA>(thunk: () => AA): A | AA;
    /**
     * Returns this option if it is nonempty, otherwise returns the
     * given `fallback`.
     */
    orElse<AA>(fallback: Option<AA>): Option<A | AA>;
    /**
     * Returns this option if it is nonempty, otherwise returns the
     * given result of evaluating the given `thunk`.
     *
     * @param thunk a no-params function that gets evaluated and
     *        whose result is returned in case this option is empty
     */
    orElseL<AA>(thunk: () => Option<AA>): Option<A | AA>;
    /**
     * Returns `true` if the option is empty, `false` otherwise.
     */
    isEmpty(): boolean;
    /**
     * Returns `true` if the option is not empty, `false` otherwise.
     */
    nonEmpty(): boolean;
    /**
     * Returns an option containing the result of applying `f` to
     * this option's value, or an empty option if the source is empty.
     *
     * NOTE: this is similar with `flatMap`, except with `map` the
     * result of `f` doesn't need to be wrapped in an `Option`.
     *
     * @param f the mapping function that will transform the value
     *          of this option if nonempty.
     *
     * @return a new option instance containing the value of the
     *         source mapped by the given function
     */
    map<B>(f: (a: A) => B): Option<B>;
    /**
     * Returns an optioning containing the result of the source mapped
     * by the given function `f`.
     *
     * Similar to `map`, except that if the mapping function `f` returns
     * `null`, then the final result returned will be [[Option.none]].
     *
     * Comparison:
     *
     * ```typescript
     * Option.of(1).mapN(x => null) // None
     * Option.of(1).map(x => null)  // Some(null)
     *
     * Option.of(1).mapN(x => x+1)  // 2
     * Option.of(1).map(x => x+1)   // 2
     * ```
     *
     * What this operation does is to allow for safe chaining of multiple
     * method calls or functions that might produce `null` results:
     *
     * ```typescript
     * Option.of(user)
     *   .mapN(_ => _.contacts)
     *   .mapN(_ => _.length)
     * ```
     */
    mapN<B>(f: (a: A) => B): Option<B>;
    /**
     * Returns the result of applying `f` to this option's value if
     * the option is nonempty, otherwise returns an empty option.
     *
     * NOTE: this is similar with `map`, except that `flatMap` the
     * result returned by `f` is expected to be boxed in an `Option`
     * already.
     *
     * Example:
     *
     * ```typescript
     * const opt = Option.of(10)
     *
     * opt.flatMap(num => {
     *   if (num % 2 == 0)
     *     Some(num + 1)
     *   else
     *     None
     * })
     * ```
     *
     * @param f the mapping function that will transform the value
     *          of this option if nonempty.
     *
     * @return a new option instance containing the value of the
     *         source mapped by the given function
     */
    flatMap<B>(f: (a: A) => Option<B>): Option<B>;
    /** Alias for [[flatMap]]. */
    chain<B>(f: (a: A) => Option<B>): Option<B>;
    /**
     * Returns this option if it is nonempty AND applying the
     * predicate `p` to the underlying value yields `true`,
     * otherwise return an empty option.
     *
     * @param p is the predicate function that is used to
     *        apply filtering on the option's value
     *
     * @return a new option instance containing the value of the
     *         source filtered with the given predicate
     */
    filter(p: (a: A) => boolean): Option<A>;
    /**
     * Returns the result of applying `f` to this option's value,
     * or in case the option is empty, the return the result of
     * evaluating the `fallback` function.
     *
     * This function is equivalent with:
     *
     * ```typescript
     * opt.map(f).getOrElseL(fallback)
     * ```
     *
     * @param fallback is the function to be evaluated in case this
     *        option is empty
     *
     * @param f is the mapping function for transforming this option's
     *        value in case it is nonempty
     */
    fold<B>(fallback: () => B, f: (a: A) => B): B;
    /**
     * Returns true if this option is nonempty and the value it
     * holds is equal to the given `elem`.
     */
    contains(elem: A): boolean;
    /**
     * Returns `true` if this option is nonempty and the given
     * predicate returns `true` when applied on this option's value.
     *
     * @param p is the predicate function to test
     */
    exists(p: (a: A) => boolean): boolean;
    /**
     * Returns true if this option is empty or the given predicate
     * returns `true` when applied on this option's value.
     *
     * @param p is the predicate function to test
     */
    forAll(p: (a: A) => boolean): boolean;
    /**
     * Apply the given procedure `cb` to the option's value if
     * this option is nonempty, otherwise do nothing.
     *
     * @param cb the procedure to apply
     */
    forEach(cb: (a: A) => void): void;
    equals(that: Option<A>): boolean;
    hashCode(): number;
    readonly _funKindF: Option<any>;
    readonly _funKindA: A;
    static readonly _funErasure: Option<any>;
    /**
     * Builds an [[Option]] reference that contains the given value.
     *
     * If the given value is `null` or `undefined` then the returned
     * option will be empty.
     */
    static of<A>(value: A | null | undefined): Option<A>;
    /**
     * Builds an [[Option]] reference that contains the given reference.
     *
     * Note that `value` is allowed to be `null` or `undefined`, the
     * returned option will still be non-empty. Use [[Option.of]]
     * if you want to avoid this problem. This means:
     *
     * ```typescript
     * const opt = Some<number | null>(null)
     *
     * opt.isEmpty()
     * //=> false
     *
     * opt.get()
     * //=> null
     * ```
     */
    static some<A>(value: A): Option<A>;
    /**
     * Returns an empty [[Option]].
     *
     * NOTE: Because `Option` is immutable, this function returns the
     * same cached reference is on different calls.
     */
    static none(): Option<never>;
    /**
     * Returns an empty [[Option]].
     *
     * Similar to [[Option.none]], but this one allows specifying a
     * type parameter (in the context of TypeScript or Flow or other
     * type system).
     *
     * NOTE: Because `Option` is immutable, this function returns the
     * same cached reference is on different calls.
     */
    static empty<A>(): Option<A>;
    /**
     * Alias for [[Some]].
     */
    static pure<A>(value: A): Option<A>;
    /**
     * Maps 2 optional values by the mapping function, returning a new
     * optional reference that is `Some` only if both option values are
     * `Some`, otherwise it returns a `None`.
     *
     * ```typescript
     * // Yields Some(3)
     * Option.map2(Some(1), Some(2),
     *   (a, b) => a + b
     * )
     *
     * // Yields None, because the second arg is None
     * Option.map2(Some(1), None,
     *   (a, b) => a + b
     * )
     * ```
     *
     * This operation is the `Applicative.map2`.
     */
    static map2<A1, A2, R>(fa1: Option<A1>, fa2: Option<A2>, f: (a1: A1, a2: A2) => R): Option<R>;
    /**
     * Maps 3 optional values by the mapping function, returning a new
     * optional reference that is `Some` only if all 3 option values are
     * `Some`, otherwise it returns a `None`.
     *
     * ```typescript
     * // Yields Some(6)
     * Option.map3(Some(1), Some(2), Some(3),
     *   (a, b, c) => a + b + c
     * )
     *
     * // Yields None, because the second arg is None
     * Option.map3(Some(1), None, Some(3),
     *   (a, b, c) => a + b + c
     * )
     * ```
     */
    static map3<A1, A2, A3, R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, f: (a1: A1, a2: A2, a3: A3) => R): Option<R>;
    /**
     * Maps 4 optional values by the mapping function, returning a new
     * optional reference that is `Some` only if all 4 option values are
     * `Some`, otherwise it returns a `None`.
     *
     * ```typescript
     * // Yields Some(10)
     * Option.map4(Some(1), Some(2), Some(3), Some(4),
     *   (a, b, c, d) => a + b + c + d
     * )
     *
     * // Yields None, because the second arg is None
     * Option.map4(Some(1), None, Some(3), Some(4),
     *   (a, b, c, d) => a + b + c + d
     * )
     * ```
     */
    static map4<A1, A2, A3, A4, R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Option<R>;
    /**
     * Maps 5 optional values by the mapping function, returning a new
     * optional reference that is `Some` only if all 5 option values are
     * `Some`, otherwise it returns a `None`.
     *
     * ```typescript
     * // Yields Some(15)
     * Option.map5(Some(1), Some(2), Some(3), Some(4), Some(5),
     *   (a, b, c, d, e) => a + b + c + d + e
     * )
     *
     * // Yields None, because the second arg is None
     * Option.map5(Some(1), None, Some(3), Some(4), Some(5),
     *   (a, b, c, d, e) => a + b + c + d + e
     * )
     * ```
     */
    static map5<A1, A2, A3, A4, A5, R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Option<R>;
    /**
     * Maps 6 optional values by the mapping function, returning a new
     * optional reference that is `Some` only if all 6 option values are
     * `Some`, otherwise it returns a `None`.
     *
     * ```typescript
     * // Yields Some(21)
     * Option.map6(Some(1), Some(2), Some(3), Some(4), Some(5), Some(6),
     *   (a, b, c, d, e, f) => a + b + c + d + e + f
     * )
     *
     * // Yields None, because the second arg is None
     * Option.map6(Some(1), None, Some(3), Some(4), Some(5), Some(6),
     *   (a, b, c, d, e, f) => a + b + c + d + e + f
     * )
     * ```
     */
    static map6<A1, A2, A3, A4, A5, A6, R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, fa6: Option<A6>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Option<R>;
    /**
     * Keeps calling `f` until a `Right(b)` is returned.
     *
     * Based on Phil Freeman's
     * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.
     *
     * Described in {@link FlatMap.tailRecM}.
     */
    static tailRecM<A, B>(a: A, f: (a: A) => Option<Either<A, B>>): Option<B>;
}
/**
 * The `Some<A>` data constructor for [[Option]] represents existing
 * values of type `A`.
 *
 * Using this function is equivalent with [[Option.some]].
 */
export declare function Some<A>(value: A): Option<A>;
/**
 * The `None` data constructor for [[Option]] represents non-existing
 * values for any type.
 *
 * Using this reference directly is equivalent with [[Option.none]].
 */
export declare const None: Option<never>;
/**
 * The `Try` type represents a computation that may either result in an
 * exception, or return a successfully computed value. It's similar to,
 * but semantically different from the [[Either]] type.
 *
 * `Try` is a sum type and so instances of `Try` are either instances
 * of [[Success]] or of [[Failure]].
 *
 * For example, `Try` can be used to perform division on a user-defined
 * input, without the need to do explicit exception-handling in all of
 * the places that an exception might occur.
 *
 * Example:
 *
 * ```typescript
 * function divide(dividendS: string, divisorS: string): string {
 *   const dividend = Try(() => parseInt(dividendS))
 *     .filter(_ => _ === _) // filter out NaN
 *   const divisor = Try(() => parseInt(divisorS))
 *     .filter(_ => _ === _)  // filter out NaN
 *
 *   // map2 executes the given function only if both results are
 *   // successful; we could also express this with flatMap / chain
 *   const result = Try.map2(dividend, divisor,
 *     (a, b) => a / b
 *   )
 *
 *   result.fold(
 *     error => `failure: ${error}`
 *     result => `result: ${result}`
 *   )
 * }
 * ```
 *
 * An important property of `Try` is its ability to pipeline, or chain,
 * operations, catching exceptions along the way. The `flatMap` and `map`
 * combinators each essentially pass off either their successfully completed
 * value, wrapped in the [[Success]] type for it to be further operated upon
 * by the next combinator in the chain, or the exception wrapped in the
 * [[Failure]] type usually to be simply passed on down the chain.
 * Combinators such as `recover` and `recoverWith` are designed to provide
 * some type of global behavior in the case of failure.
 *
 * NOTE: all `Try` combinators will catch exceptions and return failure
 * unless otherwise specified in the documentation.
 */
export declare class Try<A> implements std.IEquals<Try<A>> {
    private _isSuccess;
    private _successRef;
    private _failureRef;
    private constructor();
    /**
     * Returns `true` if the source is a [[Success]] result,
     * or `false` in case it is a [[Failure]].
     */
    isSuccess(): boolean;
    /**
     * Returns `true` if the source is a [[Failure]],
     * or `false` in case it is a [[Success]] result.
     */
    isFailure(): boolean;
    /**
     * Returns a Try's successful value if it's a [[Success]] reference,
     * otherwise throws an exception if it's a [[Failure]].
     *
     * WARNING!
     *
     * This function is partial, the option must be non-empty, otherwise
     * a runtime exception will get thrown. Use with care.
     */
    get(): A;
    /**
     * Returns the value from a `Success` or the given `fallback`
     * value if this is a `Failure`.
     *
     * ```typescript
     * Success(10).getOrElse(27) // 10
     * Failure("error").getOrElse(27)  // 27
     * ```
     */
    getOrElse<AA>(fallback: AA): A | AA;
    /**
     * Returns the value from a `Success` or the value generated
     * by a given `thunk` in case this is a `Failure`.
     *
     * ```typescript
     * Success(10).getOrElseL(() => 27) // 10
     * Failure("error").getOrElseL(() => 27)  // 27
     * ```
     */
    getOrElseL<AA>(thunk: () => AA): A | AA;
    /**
     * Returns the current value if it's a [[Success]], or
     * if the source is a [[Failure]] then return `null`.
     *
     * ```typescript
     * Success(10).orNull()      // 10
     * Failure("error").orNull() // null
     * ```
     *
     * This can be useful for use-cases such as:
     *
     * ```typescript
     * Try.of(() => dict.user.profile.name).orNull()
     * ```
     */
    orNull(): A | null;
    /**
     * Returns the current value if it's a [[Success]], or if
     * the source is a [[Failure]] then return the `fallback`.
     *
     * ```typescript
     * Success(10).orElse(Success(17))      // 10
     * Failure("error").orElse(Success(17)) // 17
     * ```
     */
    orElse<AA>(fallback: Try<AA>): Try<A | AA>;
    /**
     * Returns the current value if it's a [[Success]], or if the source
     * is a [[Failure]] then return the value generated by the given
     * `thunk`.
     *
     * ```typescript
     * Success(10).orElseL(() => Success(17))      // 10
     * Failure("error").orElseL(() => Success(17)) // 17
     * ```
     */
    orElseL<AA>(thunk: () => Try<AA>): Try<A | AA>;
    /**
     * Inverts this `Try`. If this is a [[Failure]], returns its exception wrapped
     * in a [[Success]]. If this is a `Success`, returns a `Failure` containing a
     * [[NoSuchElementError]].
     */
    failed(): Try<any>;
    /**
     * Applies the `failure` function to [[Failure]] values, and the
     * `success` function to [[Success]] values and returns the result.
     *
     * ```typescript
     * const maybeNum: Try<number> =
     *   tryParseInt("not a number")
     *
     * const result: string =
     *   maybeNum.fold(
     *     error => `Could not parse string: ${error}`,
     *     num => `Success: ${num}`
     *   )
     * ```
     */
    fold<R>(failure: (error: any) => R, success: (a: A) => R): R;
    /**
     * Returns a [[Failure]] if the source is a [[Success]], but the
     * given `p` predicate is not satisfied.
     *
     * @throws NoSuchElementError in case the predicate doesn't hold
     */
    filter(p: (a: A) => boolean): Try<A>;
    /**
     * Returns the given function applied to the value if this is
     * a [[Success]] or returns `this` if this is a [[Failure]].
     *
     * This operation is the monadic "bind" operation.
     * It can be used to *chain* multiple `Try` references.
     *
     * ```typescript
     * Try.of(() => parse(s1)).flatMap(num1 =>
     *   Try.of(() => parse(s2)).map(num2 =>
     *     num1 / num2
     *   ))
     * ```
     */
    flatMap<B>(f: (a: A) => Try<B>): Try<B>;
    /** Alias for [[flatMap]]. */
    chain<B>(f: (a: A) => Try<B>): Try<B>;
    /**
     * Returns a `Try` containing the result of applying `f` to
     * this option's value, but only if it's a `Success`, or
     * returns the current `Failure` without any modifications.
     *
     * NOTE: this is similar with `flatMap`, except with `map` the
     * result of `f` doesn't need to be wrapped in a `Try`.
     *
     * @param f the mapping function that will transform the value
     *          of this `Try` if successful.
     *
     * @return a new `Try` instance containing the value of the
     *         source mapped by the given function
     */
    map<B>(f: (a: A) => B): Try<B>;
    /**
     * Applies the given function `cb` if this is a [[Success]], otherwise
     * returns `void` if this is a [[Failure]].
     */
    forEach(cb: (a: A) => void): void;
    /**
     * Applies the given function `f` if this is a `Failure`, otherwise
     * returns `this` if this is a `Success`.
     *
     * This is like `map` for the exception.
     *
     * In the following example, if the `user.profile.email` exists,
     * then it is returned as a successful value, otherwise
     *
     * ```typescript
     * Try.of(() => user.profile.email).recover(e => {
     *   // Access error? Default to empty.
     *   if (e instanceof TypeError) return ""
     *   throw e // We don't know what it is, rethrow
     * })
     *
     * Note that on rethrow, the error is being caught in `recover` and
     * it still returns it as a `Failure(e)`.
     * ```
     */
    recover<AA>(f: (error: any) => AA): Try<A | AA>;
    /**
     * Applies the given function `f` if this is a `Failure`, otherwise
     * returns `this` if this is a `Success`.
     *
     * This is like `map` for the exception.
     *
     * In the following example, if the `user.profile.email` exists,
     * then it is returned as a successful value, otherwise
     *
     * ```typescript
     * Try.of(() => user.profile.email).recover(e => {
     *   // Access error? Default to empty.
     *   if (e instanceof TypeError) return ""
     *   throw e // We don't know what it is, rethrow
     * })
     *
     * Note that on rethrow, the error is being caught in `recover` and
     * it still returns it as a `Failure(e)`.
     * ```
     */
    recoverWith<AA>(f: (error: any) => Try<AA>): Try<A | AA>;
    /**
     * Transforms the source into an [[Option]].
     *
     * In case the source is a `Success(v)`, then it gets translated
     * into a `Some(v)`. If the source is a `Failure(e)`, then a `None`
     * value is returned.
     *
     * ```typescript
     * Success("value").toOption() // Some("value")
     * Failure("error").toOption() // None
     * ```
     */
    toOption(): Option<A>;
    /**
     * Transforms the source into an [[Either]].
     *
     * In case the source is a `Success(v)`, then it gets translated
     * into a `Right(v)`. If the source is a `Failure(e)`, then a `Left(e)`
     * value is returned.
     *
     * ```typescript
     * Success("value").toEither() // Right("value")
     * Failure("error").toEither() // Left("error")
     * ```
     */
    toEither(): Either<any, A>;
    equals(that: Try<A>): boolean;
    hashCode(): number;
    readonly _funKindF: Try<any>;
    readonly _funKindA: A;
    static readonly _funErasure: Try<any>;
    /**
     * Evaluates the given `thunk` and returns either a [[Success]],
     * in case the evaluation succeeded, or a [[Failure]], in case
     * an exception was thrown.
     *
     * Example:
     *
     * ```typescript
     * let effect = 0
     *
     * const e = Try.of(() => { effect += 1; return effect })
     * e.get() // 1
     * ```
     */
    static of<A>(thunk: () => A): Try<A>;
    /** Alias of [[Try.success]]. */
    static pure<A>(value: A): Try<A>;
    /**
     * Shorthand for `now(undefined as void)`, always returning
     * the same reference as optimization.
     */
    static unit(): Try<void>;
    /**
     * Returns a [[Try]] reference that represents a successful result
     * (i.e. wrapped in [[Success]]).
     */
    static success<A>(value: A): Try<A>;
    /**
     * Returns a [[Try]] reference that represents a failure
     * (i.e. an exception wrapped in [[Failure]]).
     */
    static failure<A>(e: any): Try<A>;
    /**
     * Maps 2 `Try` values by the mapping function, returning a new
     * `Try` reference that is a `Success` only if both `Try` values are
     * a `Success`, otherwise it returns the first `Failure` noticed.
     *
     * ```typescript
     * // Yields Success(3)
     * Try.map2(Success(1), Success(2),
     *   (a, b) => a + b
     * )
     *
     * // Yields Failure, because the second arg is a Failure
     * Try.map2(Success(1), Failure("error"),
     *   (a, b) => a + b
     * )
     * ```
     *
     * This operation is the `Applicative.map2`.
     */
    static map2<A1, A2, R>(fa1: Try<A1>, fa2: Try<A2>, f: (a1: A1, a2: A2) => R): Try<R>;
    /**
     * Maps 3 `Try` values by the mapping function, returning a new
     * `Try` reference that is a `Success` only if all 3 `Try` values are
     * a `Success`, otherwise it returns the first `Failure` noticed.
     *
     * ```typescript
     * // Yields Success(6)
     * Try.map3(Success(1), Success(2), Success(3),
     *   (a, b, c) => {
     *     return a + b + c
     *   }
     * )
     *
     * // Yields Failure, because the second arg is a Failure
     * Try.map3(
     *   Success(1),
     *   Failure("error"),
     *   Success(3),
     *
     *   (a, b, c) => {
     *     return a + b + c
     *   }
     * )
     * ```
     */
    static map3<A1, A2, A3, R>(fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, f: (a1: A1, a2: A2, a3: A3) => R): Try<R>;
    /**
     * Maps 4 `Try` values by the mapping function, returning a new
     * `Try` reference that is a `Success` only if all 4 `Try` values are
     * a `Success`, otherwise it returns the first `Failure` noticed.
     *
     * ```typescript
     * // Yields Success(10)
     * Try.map4(Success(1), Success(2), Success(3), Success(4),
     *   (a, b, c, d) => {
     *     return a + b + c + d
     *   }
     * )
     *
     * // Yields Failure, because the second arg is a Failure
     * Try.map3(
     *   Success(1),
     *   Failure("error"),
     *   Success(3),
     *   Success(4),
     *
     *   (a, b, c, d) => {
     *     return a + b + c + d
     *   }
     * )
     * ```
     */
    static map4<A1, A2, A3, A4, R>(fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Try<R>;
    /**
     * Maps 5 `Try` values by the mapping function, returning a new
     * `Try` reference that is a `Success` only if all 5 `Try` values are
     * a `Success`, otherwise it returns the first `Failure` noticed.
     *
     * ```typescript
     * // Yields Success(15)
     * Try.map5(
     *   Success(1),
     *   Success(2),
     *   Success(3),
     *   Success(4),
     *   Success(5),
     *
     *   (a, b, c, d, e) => {
     *     return a + b + c + d + e
     *   }
     * )
     *
     * // Yields Failure, because the second arg is a Failure
     * Try.map5(
     *   Success(1),
     *   Failure("error"),
     *   Success(3),
     *   Success(4),
     *   Success(5),
     *
     *   (a, b, c, d, e) => {
     *     return a + b + c + d + e
     *   }
     * )
     * ```
     */
    static map5<A1, A2, A3, A4, A5, R>(fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Try<R>;
    /**
     * Maps 6 `Try` values by the mapping function, returning a new
     * `Try` reference that is a `Success` only if all 6 `Try` values are
     * a `Success`, otherwise it returns the first `Failure` noticed.
     *
     * ```typescript
     * // Yields Success(21)
     * Try.map6(
     *   Success(1),
     *   Success(2),
     *   Success(3),
     *   Success(4),
     *   Success(5),
     *   Success(6),
     *
     *   (a, b, c, d, e, f) => {
     *     return a + b + c + d + e + f
     *   }
     * )
     *
     * // Yields Failure, because the second arg is a Failure
     * Try.map6(
     *   Success(1),
     *   Failure("error"),
     *   Success(3),
     *   Success(4),
     *   Success(5),
     *   Success(6),
     *
     *   (a, b, c, d, e, f) => {
     *     return a + b + c + d + e + f
     *   }
     * )
     * ```
     */
    static map6<A1, A2, A3, A4, A5, A6, R>(fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, fa6: Try<A6>, f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Try<R>;
    /**
     * Keeps calling `f` until a `Right(b)` is returned.
     *
     * Based on Phil Freeman's
     * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.
     *
     * Described in {@link FlatMap.tailRecM}.
     */
    static tailRecM<A, B>(a: A, f: (a: A) => Try<Either<A, B>>): Try<B>;
}
/**
 * The `Success` data constructor is for building [[Try]] values that
 * are successful results of computations, as opposed to [[Failure]].
 */
export declare function Success<A>(value: A): Try<A>;
/**
 * The `Failure` data constructor is for building [[Try]] values that
 * represent failures, as opposed to [[Success]].
 */
export declare function Failure(e: any): Try<never>;
