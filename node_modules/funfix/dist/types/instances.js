/*
 * Copyright (c) 2017 by The Funfix Project Developers.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines standard instances for types in [core]{@link "core/index"}.
 *
 * Ã€ la carte imports work, assuming an ECMAScript 2015 compatible environment,
 * including ES2015 modules and `import` syntax:
 *
 * ```typescript
 * import { OptionInstances } from "funfix/dist/types/instances"
 * // ... or ...
 * import { OptionInstances } from "funfix"
 * ```
 *
 * In absence of ES2015 compatibility, you can still rely on working with the
 * packaged (`pkg.main`) universal distribution that works within all browsers
 * and environments.
 *
 * @module types/instances
 */
/***/
import { applyMixins } from "../core/std";
import { Try, Success, Option, Some, Either, Right } from "../core/disjunctions";
import { Eval } from "../effect/eval";
import { Future } from "../exec/future";
import { registerTypeClassInstance } from "./kinds";
import { Monad, MonadError } from "./monad";
import { Eq } from "./eq";
/**
 * Type class instances provided by default for [[Option]].
 */
export class OptionInstances {
    constructor() {
        // tslint:disable-next-line:variable-name
        this.__unit = Some(undefined);
    }
    eqv(lh, rh) {
        return lh.equals(rh);
    }
    pure(a) {
        return Some(a);
    }
    unit() {
        return this.__unit;
    }
    ap(fa, ff) {
        return Option.map2(fa, ff, (a, f) => f(a));
    }
    map(fa, f) {
        return fa.map(f);
    }
    map2(fa, fb, f) {
        return Option.map2(fa, fb, f);
    }
    product(fa, fb) {
        return Option.map2(fa, fb, (a, b) => [a, b]);
    }
    flatMap(fa, f) {
        return fa.flatMap(f);
    }
    tailRecM(a, f) {
        return Option.tailRecM(a, f);
    }
}
OptionInstances.global = new OptionInstances();
// Mixins the default implementations
applyMixins(OptionInstances, [Monad]);
// Registering `OptionInstances` as global instances for Option
registerTypeClassInstance(Eq)(Option, OptionInstances.global);
registerTypeClassInstance(Monad)(Option, OptionInstances.global);
/**
 * Type class instances provided by default for [[Option]].
 */
export class TryInstances {
    constructor() {
        // tslint:disable-next-line:variable-name
        this.__unit = Success(undefined);
    }
    eqv(lh, rh) {
        return lh.equals(rh);
    }
    pure(a) {
        return Success(a);
    }
    unit() {
        return Try.unit();
    }
    ap(fa, ff) {
        return Try.map2(fa, ff, (a, f) => f(a));
    }
    map(fa, f) {
        return fa.map(f);
    }
    map2(fa, fb, f) {
        return Try.map2(fa, fb, f);
    }
    product(fa, fb) {
        return Try.map2(fa, fb, (a, b) => [a, b]);
    }
    flatMap(fa, f) {
        return fa.flatMap(f);
    }
    tailRecM(a, f) {
        return Try.tailRecM(a, f);
    }
    raise(e) {
        return Try.failure(e);
    }
    attempt(fa) {
        return Try.success(fa.fold(e => Either.left(e), Either.right));
    }
    recoverWith(fa, f) {
        return fa.recoverWith(f);
    }
    recover(fa, f) {
        return fa.recover(f);
    }
}
TryInstances.global = new TryInstances();
// Mixins the default implementations
applyMixins(TryInstances, [MonadError]);
// Registering `TryInstances` as global instances for Try
registerTypeClassInstance(Eq)(Try, TryInstances.global);
registerTypeClassInstance(MonadError)(Try, TryInstances.global);
/**
 * Type class instances provided by default for [[Either]].
 */
export class EitherInstances {
    constructor() {
        // tslint:disable-next-line:variable-name
        this.__unit = Right(undefined);
    }
    eqv(lh, rh) {
        return lh.equals(rh);
    }
    pure(a) {
        return Right(a);
    }
    unit() {
        return this.__unit;
    }
    ap(fa, ff) {
        const faE = fa;
        const ffE = ff;
        return Either.map2(faE, ffE, (a, f) => f(a));
    }
    map(fa, f) {
        return fa.map(f);
    }
    map2(fa, fb, f) {
        return Either.map2(fa, fb, f);
    }
    product(fa, fb) {
        return Either.map2(fa, fb, (a, b) => [a, b]);
    }
    flatMap(fa, f) {
        return fa.flatMap(f);
    }
    tailRecM(a, f) {
        return Either.tailRecM(a, f);
    }
}
EitherInstances.global = new EitherInstances();
// Mixins the default implementations
applyMixins(EitherInstances, [Monad]);
// Registering `TryInstances` as global instances for Try
registerTypeClassInstance(Eq)(Either, EitherInstances.global);
registerTypeClassInstance(Monad)(Either, EitherInstances.global);
/**
 * Type class instances provided by default for [[Eval]].
 */
export class EvalInstances {
    pure(a) {
        return Eval.now(a);
    }
    flatMap(fa, f) {
        return fa.flatMap(f);
    }
    tailRecM(a, f) {
        return Eval.tailRecM(a, f);
    }
    ap(fa, ff) {
        return fa.flatMap(a => ff.map(f => f(a)));
    }
    map(fa, f) {
        return fa.map(f);
    }
    unit() {
        return Eval.unit();
    }
    raise(e) {
        return Eval.raise(e);
    }
    attempt(fa) {
        return fa.attempt();
    }
    recoverWith(fa, f) {
        return fa.recoverWith(f);
    }
    recover(fa, f) {
        return fa.recover(f);
    }
}
EvalInstances.global = new EvalInstances();
// Mixins the default implementations
applyMixins(EvalInstances, [MonadError]);
// Registering `EvalInstances` as global instances for `Eval`
registerTypeClassInstance(MonadError)(Eval, EvalInstances.global);
/**
 * Type class instances provided by default for {@link Future}.
 */
export class FutureInstances {
    pure(a) {
        return Future.pure(a);
    }
    flatMap(fa, f) {
        return fa.flatMap(f);
    }
    tailRecM(a, f) {
        return Future.tailRecM(a, f);
    }
    ap(fa, ff) {
        return fa.flatMap(a => ff.map(f => f(a)));
    }
    map(fa, f) {
        return fa.map(f);
    }
    unit() {
        return Future.unit();
    }
    raise(e) {
        return Future.raise(e);
    }
    attempt(fa) {
        return fa.attempt();
    }
    recoverWith(fa, f) {
        return fa.recoverWith(f);
    }
    recover(fa, f) {
        return fa.recover(f);
    }
    map2(fa, fb, f) {
        return Future.map2(fa, fb, f);
    }
}
FutureInstances.global = new FutureInstances();
// Mixins the default implementations
applyMixins(FutureInstances, [MonadError]);
// Registering `FutureInstances` as global instances for `Future`
registerTypeClassInstance(MonadError)(Future, FutureInstances.global);
//# sourceMappingURL=instances.js.map