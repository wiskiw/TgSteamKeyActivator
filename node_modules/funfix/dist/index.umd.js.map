{"version":3,"file":"index.umd.js","sources":["../src/core/std.ts","../src/core/errors.ts","../src/core/disjunctions.ts","../src/exec/cancelable.ts","../src/exec/time.ts","../src/exec/ref.ts","../src/exec/internals.ts","../src/exec/scheduler.ts","../src/exec/future.ts","../src/types/kinds.ts","../src/types/eq.ts","../src/types/functor.ts","../src/types/applicative.ts","../src/types/monad.ts","../src/effect/eval.ts","../src/types/instances.ts"],"sourcesContent":["/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Utilities for dealing with universal equality and `hashCode`.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { is, hashCode } from \"funfix/dist/core/std\"\n * // ... or ...\n * import { is, hashCode } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module core/std\n */\n\n/***/\n\n/**\n * Interface for testing the equality of value objects.\n */\nexport interface IEquals<A> {\n  /**\n   * Indicates whether some other object is \"equal to\" this one.\n   *\n   * Properties:\n   *\n   *  - reflexive: for any value, `x.equals(x) == true`\n   *  - symmetric: for any values x and y, `x.equals(y) == y.equals(x)`\n   *  - transitive: `x.equals(y) && y.equals(z) => x.equals(z)`\n   *  - consistent: `x.equals(y)` always yields the same result\n   *\n   * Rule: equal objects MUST have equal hash codes!\n   */\n  equals(other: A): boolean\n\n  /**\n   * Returns a hash code value for this value.\n   *\n   * This method is supported for the benefit of hash tables.\n   *\n   * Properties:\n   *\n   *  - consistent: multiple invocations always yield the same result\n   *  - if `x.equals(y) == true` then `x.hashCode() == y.hashCode()`\n   *  - if `x.equals(y) == false` it is NOT required for their hash codes\n   *    to be equal, i.e. this function is not injective\n   */\n  hashCode(): number\n}\n\n/**\n * Test if the given reference is a value object.\n *\n * Value objects are objects that implement the [[IEquals]]\n * interface.\n *\n * @param ref is the reference to test\n */\nexport function isValueObject(ref: any): boolean {\n  return !!(ref &&\n    typeof ref.equals === \"function\" &&\n    typeof ref.hashCode === \"function\")\n}\n\n/**\n * Tests for universal equality.\n *\n * First attempting a reference check with `===`,\n * after which it tries to fallback on [[IEquals]], if the\n * left-hand side is implementing it.\n *\n * ```typescript\n * equals(10, 10) // true, because 10 === 10\n *\n * class Box implements IEquals<Box> {\n *   constructor(value: number) { this.value = value }\n *\n *   equals(other) { return this.value === other.value  }\n *   hashCode() { return this.value << 2 }\n * }\n *\n * // false, because they are not the same reference\n * new Box(10) === new Box(10)\n *\n * // true, because `Box#equals` gets called\n * equals(new Box(10), new Box(10))\n * ```\n */\nexport function is<A>(lh: A, rh: A): boolean {\n  if (lh === rh || (lh !== lh && rh !== rh)) {\n    return true\n  }\n  if (!lh || !rh) {\n    return false\n  }\n  /* istanbul ignore else */\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (typeof lh.valueOf === \"function\" && typeof rh.valueOf === \"function\") {\n    const lh2 = lh.valueOf()\n    const rh2 = rh.valueOf()\n    if (lh2 === rh2 || (lh2 !== lh2 && rh2 !== rh2)) {\n      return true\n    }\n    if (!lh2 || !rh2) {\n      return false\n    }\n  }\n  // noinspection PointlessBooleanExpressionJS\n  return !!(\n    isValueObject(lh) &&\n    (lh as any).equals(rh)\n  )\n}\n\n/** Alias for [[is]]. */\nexport function equals<A>(lh: A, rh: A): boolean {\n  return is(lh, rh)\n}\n\n/**\n * Universal hash-code function.\n *\n * Depending on the given value, it calculates the hash-code like so:\n *\n *  1. if it's a `number`, then it gets truncated\n *     to an integer and returned\n *  2. if it's a \"value object\" (see [[isValueObject]]), then\n *     its `hashCode` is used\n *  3. if a `valueOf()` function is provided, then the\n *     `hashCode` gets recursively invoked on its result\n *  4. if all else fails, the value gets coerced to a `String`\n *     and a hash code is calculated using [[hashCodeOfString]]\n *\n * @param ref is the value to use for calculating a hash code\n * @return an integer with the aforementioned properties\n */\nexport function hashCode(ref: any): number {\n  if (typeof ref === \"number\") {\n    return ref & ref\n  }\n  /* istanbul ignore else */\n  if (typeof ref.valueOf === \"function\") {\n    const v = ref.valueOf()\n    if (v !== ref) return hashCode(v)\n  }\n  if (isValueObject(ref)) {\n    return (ref as IEquals<any>).hashCode()\n  }\n  return hashCodeOfString(String(ref))\n}\n\n/**\n * Calculates a hash code out of any string.\n */\nexport function hashCodeOfString(str: string): number {\n  let hash = 0\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (str == null || str.length === 0) return hash\n  for (let i = 0; i < str.length; i++) {\n    const character = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + character\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash\n}\n\n/** The identity function. */\nexport function id<A>(a: A): A {\n  return a\n}\n\n/**\n * Utility function for implementing mixins, based on the\n * [TypeScript Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * documentation.\n *\n * Sample:\n *\n * ```typescript\n * class Disposable { ... }\n * class Activatable { ... }\n * class SmartObject implements Disposable, Activatable { ... }\n *\n * applyMixins(SmartObject, [Disposable, Activatable]);\n * ```\n *\n * Using `implements` instead of `extends` for base classes\n * will make the type system treat them like interfaces instead of\n * classes. And by `applyMixins` we can also supply global\n * implementations for the non-abstract members.\n */\nexport function applyMixins(derivedCtor: {prototype: any}, baseCtors: {prototype: any}[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      if (!derivedCtor.prototype[name])\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n    })\n  })\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes standard, reusable error types, that help with some common scenarios,\n * working with error types being preferable to working with strings.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { IllegalStateError } from \"funfix/dist/core/errors\"\n * // ... or ...\n * import { IllegalStateError } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module core/errors\n */\n\n/***/\n\n/**\n * A composite error represents a list of errors that were caught\n * while executing logic which delays re-throwing of errors.\n */\nexport class CompositeError extends Error {\n  private errorsRef: Array<any>\n\n  constructor(errors: Array<any>) {\n    let reasons = \"\"\n    for (const e of errors.slice(0, 2)) {\n      let message = \"\"\n      if (e instanceof Error) {\n        message = `${e.name}(${e.message})`\n      } else {\n        message = `${e}`\n      }\n      reasons += \", \" + message\n    }\n\n    reasons = reasons.slice(2)\n    if (errors.length > 2) reasons = reasons + \", ...\"\n    super(reasons)\n    this.name = \"CompositeError\"\n    this.errorsRef = errors\n  }\n\n  /**\n   * Returns the full list of caught errors.\n   */\n  public errors(): Array<any> { return this.errorsRef.slice() }\n}\n\n/**\n * A dummy error that can be used for testing purposes.\n */\nexport class DummyError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"DummyError\"\n  }\n}\n\n/**\n * Thrown by various accessor methods or partial functions to indicate\n * that the element being requested does not exist.\n */\nexport class NoSuchElementError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NoSuchElementError\"\n  }\n}\n\n/**\n * Error throw in class constructors by implementations that\n * are sealed or final.\n */\nexport class IllegalInheritanceError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalInheritanceError\"\n  }\n}\n\n/**\n * Signals that a function has been invoked at an illegal\n * or inappropriate time.\n *\n * In other words, environment or application is not in an\n * appropriate state for the requested operation.\n */\nexport class IllegalStateError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalStateError\"\n  }\n}\n\n/**\n * Signals that a function has been invoked with illegal\n * arguments.\n */\nexport class IllegalArgumentError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalArgumentError\"\n  }\n}\n\n/**\n * Signals that a function or a method is missing an implementation,\n * which should be provided in the future.\n */\nexport class NotImplementedError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NotImplementedError\"\n  }\n}\n\n/**\n * Signals that completion of a procedure took longer than anticipated.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"TimeoutError\"\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes data types for expression disjunctions:\n *\n * - {@link Either}: data type for expressing results with two possible\n *   outcome types (a disjoint union)\n * - {@link Option}: data type for expressing optional values\n * - {@link Try}: data type for representing the result of computations\n *   that may result in either success or failure\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Either } from \"funfix/dist/core/disjunction\"\n * // ... or ...\n * import { Either } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module core/disjunction\n */\n\n/***/\nimport * as std from \"./std\"\nimport { NoSuchElementError } from \"./errors\"\n\n/**\n * Represents a value of one of two possible types (a disjoint union).\n *\n * A common use of Either is as an alternative to [[Option]] for dealing\n * with possible missing values. In this usage [[Option.none]] is replaced\n * with [[Either.left]] which can contain useful information and\n * [[Option.some]] is replaced with [[Either.right]].\n *\n * Convention dictates that `left` is used for failure and `right` is used\n * for success. Note that this `Either` type is right-biased, meaning that\n * operations such as `map`, `flatMap` and `filter` work on the `right` value\n * and if you want to work on the `left` value, then you need to do a `swap`.\n *\n * For example, you could use `Either<String, Int>` to detect whether an\n * input is a string or an number:\n *\n * ```typescript\n * function tryParseInt(str: string): Either<string, number> {\n *   const i = parseInt(value)\n *   return isNaN(i) ? Left(str) : Right(i)\n * }\n *\n * const result = tryParseInt(\"not an int\")\n * if (result.isRight()) {\n *   console.log(`Increment: ${result.get}`)\n * } else {\n *   console.log(`ERROR: could not parse ${result.swap.get}`)\n * }\n * ```\n *\n * @final\n */\nexport class Either<L, R> implements std.IEquals<Either<L, R>> {\n  private _isRight: boolean\n  private _rightRef: R\n  private _leftRef: L\n\n  private constructor(_leftRef: L, _rightRef: R, _isRight: boolean) {\n    this._isRight = _isRight\n    if (_isRight) this._rightRef = _rightRef\n    else this._leftRef = _leftRef\n  }\n\n  /**\n   * Returns `true` if this is a `left`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isLeft() // true\n   * Right(10).isLeft() // false\n   * ```\n   */\n  isLeft(): boolean { return !this._isRight }\n\n  /**\n   * If the source is a `left` value, then returns it unchanged\n   * and casted as a `Left`, otherwise throw exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the reference must be a `Left,\n   * otherwise a runtime exception will get thrown. Use with care.\n   *\n   * @throws NoSuchElementError\n   */\n  left(): Either<L, never> {\n    if (!this._isRight) return this as any\n    throw new NoSuchElementError(\"either.left\")\n  }\n\n  /**\n   * Returns `true` if this is a `right`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isRight() // false\n   * Right(10).isRight() // true\n   * ```\n   */\n  isRight(): boolean { return this._isRight }\n\n  /**\n   * If the source is a `right` value, then returns it unchanged\n   * and casted as a `Right`, otherwise throw exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the reference must be a `Right,\n   * otherwise a runtime exception will get thrown. Use with care.\n   *\n   * @throws NoSuchElementError\n   */\n  right(): Either<never, R> {\n    if (this._isRight) return this as any\n    throw new NoSuchElementError(\"either.right\")\n  }\n\n  /**\n   * Returns true if this is a Right and its value is equal to `elem`\n   * (as determined by the `equals` protocol), returns `false` otherwise.\n   *\n   * ```typescript\n   * // True\n   * Right(\"something\").contains(\"something\")\n   *\n   * // False because the values are different\n   * Right(\"something\").contains(\"anything\") // false\n   *\n   * // False because the source is a `left`\n   * Left(\"something\").contains(\"something\") // false\n   * ```\n   */\n  contains(elem: R): boolean {\n    return this._isRight && std.is(this._rightRef, elem)\n  }\n\n  /**\n   * Returns `false` if the source is a `left`, or returns the result\n   * of the application of the given predicate to the `right` value.\n   *\n   * ```typescript\n   * // True, because it is a right and predicate holds\n   * Right(20).exists(n => n > 10)\n   *\n   * // False, because the predicate returns false\n   * Right(10).exists(n => n % 2 != 0)\n   *\n   * // False, because it is a left\n   * Left(10).exists(n => n == 10)\n   * ```\n   */\n  exists(p: (r: R) => boolean): boolean {\n    return this._isRight && p(this._rightRef)\n  }\n\n  /**\n   * Filters `right` values with the given predicate, returning\n   * the value generated by `zero` in case the source is a `right`\n   * value and the predicate doesn't hold.\n   *\n   * Possible outcomes:\n   *\n   *  - Returns the existing value of `right` if this is a `right` value and the\n   *    given predicate `p` holds for it\n   *  - Returns `Left(zero())` if this is a `right` value\n   *    and the given predicate `p` does not hold\n   *  - Returns the current \"left\" value, if the source is a `Left`\n   *\n   * ```typescript\n   * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)\n   * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)\n   * Left(7).filterOrElse(x => false, () => -1)    // Left(7)\n   * ```\n   */\n  filterOrElse(p: (r: R) => boolean, zero: () => L): Either<L, R> {\n    return this._isRight\n      ? (p(this._rightRef) ? this.right() : Left(zero()))\n      : this.left()\n  }\n\n  /**\n   * Binds the given function across `right` values.\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Either` references.\n   */\n  flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S> {\n    return this._isRight ? f(this._rightRef) : this.left()\n  }\n\n  /**\n   * Applies the `left` function to [[Left]] values, and the\n   * `right` function to [[Right]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Either<string, number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     str => `Could not parse string: ${str}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<S>(left: (l: L) => S, right: (r: R) => S): S {\n    return this._isRight ? right(this._rightRef) : left(this._leftRef)\n  }\n\n  /**\n   * Returns true if the source is a `left` or returns\n   * the result of the application of the given predicate to the\n   * `right` value.\n   *\n   * ```typescript\n   * // True, because it is a `left`\n   * Left(\"hello\").forAll(x => x > 10)\n   *\n   * // True, because the predicate holds\n   * Right(20).forAll(x => x > 10)\n   *\n   * // False, it's a right and the predicate doesn't hold\n   * Right(7).forAll(x => x > 10)\n   * ```\n   */\n  forAll(p: (r: R) => boolean): boolean {\n    return !this._isRight || p(this._rightRef)\n  }\n\n  /**\n   * Returns the `Right` value, if the source has one,\n   * otherwise throws an exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the `Either` must be a `Right`, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`\n   */\n  get(): R {\n    if (this._isRight) return this._rightRef\n    throw new NoSuchElementError(\"left.get()\")\n  }\n\n  /**\n   * Returns the value from this `right` or the given `fallback`\n   * value if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElse(27) // 10\n   * Left(10).getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<RR>(fallback: RR): R | RR {\n    return this._isRight ? this._rightRef : fallback\n  }\n\n  /**\n   * Returns the value from this `right` or a value generated\n   * by the given `thunk` if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElseL(() => 27) // 10\n   * Left(10).getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<RR>(thunk: () => RR): R | RR {\n    return this._isRight ? this._rightRef : thunk()\n  }\n\n  /**\n   * Transform the source if it is a `right` with the given\n   * mapping function.\n   *\n   * ```typescript\n   * Right(10).map(x => x + 17) // right(27)\n   * Left(10).map(x => x + 17)  // left(10)\n   * ```\n   */\n  map<C>(f: (r: R) => C): Either<L, C> {\n    return this._isRight\n      ? Right(f(this._rightRef))\n      : this.left()\n  }\n\n  /**\n   * Executes the given side-effecting function if the\n   * source is a `right` value.\n   *\n   * ```typescript\n   * Right(12).forAll(console.log) // prints 12\n   * Left(10).forAll(console.log)  // silent\n   * ```\n   */\n  forEach(cb: (r: R) => void): void {\n    if (this._isRight) cb(this._rightRef)\n  }\n\n  /**\n   * If this is a `left`, then return the left value as a `right`\n   * or vice versa.\n   *\n   * ```typescript\n   * Right(10).swap() // left(10)\n   * Left(20).swap()  // right(20)\n   * ```\n   */\n  swap(): Either<R, L> {\n    return this._isRight\n      ? Left(this._rightRef)\n      : Right(this._leftRef)\n  }\n\n  /**\n   * Returns an `Option.some(right)` if the source is a `right` value,\n   * or `Option.none` in case the source is a `left` value.\n   */\n  toOption(): Option<R> {\n    return this._isRight\n      ? Option.some(this._rightRef)\n      : Option.none()\n  }\n\n  /** Implements {@link IEquals.equals}. */\n  equals(other: Either<L, R>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (other == null) return false\n    if (this._isRight) return std.is(this._rightRef, other._rightRef)\n    return std.is(this._leftRef, other._leftRef)\n  }\n\n  /** Implements {@link IEquals.hashCode}. */\n  hashCode(): number {\n    return this._isRight\n      ? std.hashCode(this._rightRef) << 2\n      : std.hashCode(this._leftRef) << 3\n  }\n\n  // Implements HK<F, A>\n  readonly _funKindF: Either<L, any>\n  readonly _funKindA: R\n\n  // Implements Constructor<T>\n  static readonly _funErasure: Either<any, any>\n\n  static left<L, R>(value: L): Either<L, R> {\n    return Left(value)\n  }\n\n  static right<L, R>(value: R): Either<L, R> {\n    return Right(value)\n  }\n\n  /**\n   * Maps 2 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if both `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(3)\n   * Try.map2(Right(1), Right(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map2(Right(1), Left(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,L,R>(fa1: Either<L,A1>, fa2: Either<L,A2>,\n                         f: (a1: A1, a2: A2) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef))\n  }\n\n  /**\n   * Maps 3 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 3 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(6)\n   * Try.map3(Right(1), Right(2), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map3(Right(1), Left(\"error\"), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef))\n  }\n\n  /**\n   * Maps 4 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 4 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(10)\n   * Try.map4(Right(1), Right(2), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map4(Right(1), Left(\"error\"), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef))\n  }\n\n  /**\n   * Maps 5 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 5 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(15)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef))\n  }\n\n  /**\n   * Maps 6 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 6 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(21)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,L,R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>, fa6: Either<L,A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return ((fa1 as any) as Either<L, R>)\n    if (fa2.isLeft()) return ((fa2 as any) as Either<L, R>)\n    if (fa3.isLeft()) return ((fa3 as any) as Either<L, R>)\n    if (fa4.isLeft()) return ((fa4 as any) as Either<L, R>)\n    if (fa5.isLeft()) return ((fa5 as any) as Either<L, R>)\n    if (fa6.isLeft()) return ((fa6 as any) as Either<L, R>)\n    return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef, fa6._rightRef))\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in {@link FlatMap.tailRecM}.\n   */\n  static tailRecM<L, A, B>(a: A, f: (a: A) => Either<L, Either<A, B>>): Either<L, B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isLeft()) return result as any\n\n      const some = result.get()\n      if (some.isRight()) return Right(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Left` data constructor represents the left side of the\n * [[Either]] disjoint union, as opposed to the [[Right]] side.\n */\nexport function Left<L>(value: L): Either<L, never> {\n  return new (Either as any)(value, null as never, false)\n}\n\n/**\n * The `Right` data constructor represents the right side of the\n * [[Either]] disjoint union, as opposed to the [[Left]] side.\n */\nexport function Right<R>(value: R): Either<never, R> {\n  return new (Either as any)(null as never, value, true)\n}\n\n/**\n * Represents optional values, inspired by Scala's `Option` and by\n * Haskell's `Maybe` data types.\n *\n * Option is an immutable data type, represented as a sum type, being\n * either a [[Some]], in case it contains a single element, or a [[None]],\n * in case it is empty.\n *\n * The most idiomatic way to use an `Option` instance is to treat it\n * as a collection or monad and use `map`,`flatMap`, `filter`,\n * or `forEach`.\n *\n * @final\n */\nexport class Option<A> implements std.IEquals<Option<A>> {\n  // tslint:disable-next-line:variable-name\n  private _isEmpty: boolean\n  private _ref: A\n\n  private constructor(ref: A, isEmpty?: boolean) {\n    /* tslint:disable-next-line:strict-type-predicates */\n    this._isEmpty = isEmpty != null ? isEmpty : (ref === null || ref === undefined)\n    this._ref = ref\n  }\n\n  /**\n   * Returns the option's value.\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the option is empty\n   */\n  get(): A {\n    if (!this._isEmpty) return this._ref\n    else throw new NoSuchElementError(\"Option.get\")\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the given `fallback`.\n   *\n   * See [[Option.getOrElseL]] for a lazy alternative.\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return fallback\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `null`.\n   */\n  orNull(): A | null {\n    if (!this._isEmpty) return this._ref\n    else return null\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the result of evaluating `thunk`.\n   *\n   * See [[Option.getOrElse]] for a strict alternative.\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    if (!this._isEmpty) return this._ref\n    else return thunk()\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given `fallback`.\n   */\n  orElse<AA>(fallback: Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return fallback\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given result of evaluating the given `thunk`.\n   *\n   * @param thunk a no-params function that gets evaluated and\n   *        whose result is returned in case this option is empty\n   */\n  orElseL<AA>(thunk: () => Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return thunk()\n  }\n\n  /**\n   * Returns `true` if the option is empty, `false` otherwise.\n   */\n  isEmpty(): boolean { return this._isEmpty }\n\n  /**\n   * Returns `true` if the option is not empty, `false` otherwise.\n   */\n  nonEmpty(): boolean { return !this._isEmpty }\n\n  /**\n   * Returns an option containing the result of applying `f` to\n   * this option's value, or an empty option if the source is empty.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in an `Option`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return this._isEmpty ? None : Some(f(this._ref))\n  }\n\n  /**\n   * Returns an optioning containing the result of the source mapped\n   * by the given function `f`.\n   *\n   * Similar to `map`, except that if the mapping function `f` returns\n   * `null`, then the final result returned will be [[Option.none]].\n   *\n   * Comparison:\n   *\n   * ```typescript\n   * Option.of(1).mapN(x => null) // None\n   * Option.of(1).map(x => null)  // Some(null)\n   *\n   * Option.of(1).mapN(x => x+1)  // 2\n   * Option.of(1).map(x => x+1)   // 2\n   * ```\n   *\n   * What this operation does is to allow for safe chaining of multiple\n   * method calls or functions that might produce `null` results:\n   *\n   * ```typescript\n   * Option.of(user)\n   *   .mapN(_ => _.contacts)\n   *   .mapN(_ => _.length)\n   * ```\n   */\n  mapN<B>(f: (a: A) => B): Option<B> {\n    return this._isEmpty ? None : Option.of(f(this._ref))\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value if\n   * the option is nonempty, otherwise returns an empty option.\n   *\n   * NOTE: this is similar with `map`, except that `flatMap` the\n   * result returned by `f` is expected to be boxed in an `Option`\n   * already.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const opt = Option.of(10)\n   *\n   * opt.flatMap(num => {\n   *   if (num % 2 == 0)\n   *     Some(num + 1)\n   *   else\n   *     None\n   * })\n   * ```\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    if (this._isEmpty) return None\n    else return f(this._ref)\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Option<B>): Option<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns this option if it is nonempty AND applying the\n   * predicate `p` to the underlying value yields `true`,\n   * otherwise return an empty option.\n   *\n   * @param p is the predicate function that is used to\n   *        apply filtering on the option's value\n   *\n   * @return a new option instance containing the value of the\n   *         source filtered with the given predicate\n   */\n  filter(p: (a: A) => boolean): Option<A> {\n    if (this._isEmpty || !p(this._ref)) return None\n    else return this\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value,\n   * or in case the option is empty, the return the result of\n   * evaluating the `fallback` function.\n   *\n   * This function is equivalent with:\n   *\n   * ```typescript\n   * opt.map(f).getOrElseL(fallback)\n   * ```\n   *\n   * @param fallback is the function to be evaluated in case this\n   *        option is empty\n   *\n   * @param f is the mapping function for transforming this option's\n   *        value in case it is nonempty\n   */\n  fold<B>(fallback: () => B, f: (a: A) => B): B {\n    if (this._isEmpty) return fallback()\n    else return f(this._ref)\n  }\n\n  /**\n   * Returns true if this option is nonempty and the value it\n   * holds is equal to the given `elem`.\n   */\n  contains(elem: A): boolean {\n    return !this._isEmpty && std.is(this._ref, elem)\n  }\n\n  /**\n   * Returns `true` if this option is nonempty and the given\n   * predicate returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  exists(p: (a: A) => boolean): boolean {\n    return !this._isEmpty && p(this._ref)\n  }\n\n  /**\n   * Returns true if this option is empty or the given predicate\n   * returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  forAll(p: (a: A) => boolean): boolean {\n    return this._isEmpty || p(this._ref)\n  }\n\n  /**\n   * Apply the given procedure `cb` to the option's value if\n   * this option is nonempty, otherwise do nothing.\n   *\n   * @param cb the procedure to apply\n   */\n  forEach(cb: (a: A) => void): void {\n    if (!this._isEmpty) cb(this._ref)\n  }\n\n  // Implemented from IEquals\n  equals(that: Option<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    if (this.nonEmpty() && that.nonEmpty()) {\n      const l = this.get()\n      const r = that.get()\n      return std.is(l, r)\n    }\n    return this.isEmpty() && that.isEmpty()\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    if (this._isEmpty) return 2433880\n    else if (this._ref == null) return 2433881 << 2\n    else return std.hashCode(this._ref) << 2\n  }\n\n  // Implements HK<F, A>\n  readonly _funKindF: Option<any>\n  readonly _funKindA: A\n\n  // Implements Constructor<T>\n  static readonly _funErasure: Option<any>\n\n  /**\n   * Builds an [[Option]] reference that contains the given value.\n   *\n   * If the given value is `null` or `undefined` then the returned\n   * option will be empty.\n   */\n  static of<A>(value: A | null | undefined): Option<A> {\n    return value != null ? Some(value) : None\n  }\n\n  /**\n   * Builds an [[Option]] reference that contains the given reference.\n   *\n   * Note that `value` is allowed to be `null` or `undefined`, the\n   * returned option will still be non-empty. Use [[Option.of]]\n   * if you want to avoid this problem. This means:\n   *\n   * ```typescript\n   * const opt = Some<number | null>(null)\n   *\n   * opt.isEmpty()\n   * //=> false\n   *\n   * opt.get()\n   * //=> null\n   * ```\n   */\n  static some<A>(value: A): Option<A> {\n    return new Option(value, false)\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static none(): Option<never> {\n    return None\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * Similar to [[Option.none]], but this one allows specifying a\n   * type parameter (in the context of TypeScript or Flow or other\n   * type system).\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static empty<A>(): Option<A> {\n    return None\n  }\n\n  /**\n   * Alias for [[Some]].\n   */\n  static pure<A>(value: A): Option<A> { return Some(value) }\n\n  /**\n   * Maps 2 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if both option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(3)\n   * Option.map2(Some(1), Some(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map2(Some(1), None,\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(fa1: Option<A1>, fa2: Option<A2>,\n                       f: (a1: A1, a2: A2) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get()))\n      : None\n  }\n\n  /**\n   * Maps 3 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 3 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(6)\n   * Option.map3(Some(1), Some(2), Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map3(Some(1), None, Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>,\n                          f: (a1: A1, a2: A2, a3: A3) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get()))\n      : None\n  }\n\n  /**\n   * Maps 4 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 4 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(10)\n   * Option.map4(Some(1), Some(2), Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map4(Some(1), None, Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get()))\n      : None\n  }\n\n  /**\n   * Maps 5 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 5 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(15)\n   * Option.map5(Some(1), Some(2), Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map5(Some(1), None, Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get()))\n      : None\n  }\n\n  /**\n   * Maps 6 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 6 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(21)\n   * Option.map6(Some(1), Some(2), Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map6(Some(1), None, Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, fa6: Option<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() && fa6.nonEmpty()\n      ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get(), fa6.get()))\n      : None\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in {@link FlatMap.tailRecM}.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Option<Either<A, B>>): Option<B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.isEmpty()) return None\n\n      const some = result.get()\n      if (some.isRight()) return Some(some.get())\n      cursor = some.swap().get()\n    }\n  }\n}\n\n/**\n * The `Some<A>` data constructor for [[Option]] represents existing\n * values of type `A`.\n *\n * Using this function is equivalent with [[Option.some]].\n */\nexport function Some<A>(value: A): Option<A> {\n  return new (Option as any)(value, false)\n}\n\n/**\n * The `None` data constructor for [[Option]] represents non-existing\n * values for any type.\n *\n * Using this reference directly is equivalent with [[Option.none]].\n */\nexport const None: Option<never> =\n  (function () {\n    // Ugly workaround to get around the limitation of\n    // Option's private constructor\n    const F: any = Option\n    return new F(null, true) as Option<never>\n  })()\n\n/**\n * The `Try` type represents a computation that may either result in an\n * exception, or return a successfully computed value. It's similar to,\n * but semantically different from the [[Either]] type.\n *\n * `Try` is a sum type and so instances of `Try` are either instances\n * of [[Success]] or of [[Failure]].\n *\n * For example, `Try` can be used to perform division on a user-defined\n * input, without the need to do explicit exception-handling in all of\n * the places that an exception might occur.\n *\n * Example:\n *\n * ```typescript\n * function divide(dividendS: string, divisorS: string): string {\n *   const dividend = Try(() => parseInt(dividendS))\n *     .filter(_ => _ === _) // filter out NaN\n *   const divisor = Try(() => parseInt(divisorS))\n *     .filter(_ => _ === _)  // filter out NaN\n *\n *   // map2 executes the given function only if both results are\n *   // successful; we could also express this with flatMap / chain\n *   const result = Try.map2(dividend, divisor,\n *     (a, b) => a / b\n *   )\n *\n *   result.fold(\n *     error => `failure: ${error}`\n *     result => `result: ${result}`\n *   )\n * }\n * ```\n *\n * An important property of `Try` is its ability to pipeline, or chain,\n * operations, catching exceptions along the way. The `flatMap` and `map`\n * combinators each essentially pass off either their successfully completed\n * value, wrapped in the [[Success]] type for it to be further operated upon\n * by the next combinator in the chain, or the exception wrapped in the\n * [[Failure]] type usually to be simply passed on down the chain.\n * Combinators such as `recover` and `recoverWith` are designed to provide\n * some type of global behavior in the case of failure.\n *\n * NOTE: all `Try` combinators will catch exceptions and return failure\n * unless otherwise specified in the documentation.\n */\nexport class Try<A> implements std.IEquals<Try<A>> {\n  private _isSuccess: boolean\n  private _successRef: A\n  private _failureRef: any\n\n  private constructor(_success: A, _failure: any, _isSuccess: boolean) {\n    this._isSuccess = _isSuccess\n    if (_isSuccess) this._successRef = _success\n    else this._failureRef = _failure\n  }\n\n  /**\n   * Returns `true` if the source is a [[Success]] result,\n   * or `false` in case it is a [[Failure]].\n   */\n  isSuccess(): boolean { return this._isSuccess }\n\n  /**\n   * Returns `true` if the source is a [[Failure]],\n   * or `false` in case it is a [[Success]] result.\n   */\n  isFailure(): boolean { return !this._isSuccess }\n\n  /**\n   * Returns a Try's successful value if it's a [[Success]] reference,\n   * otherwise throws an exception if it's a [[Failure]].\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   */\n  get(): A {\n    if (!this._isSuccess) throw this._failureRef\n    return this._successRef\n  }\n\n  /**\n   * Returns the value from a `Success` or the given `fallback`\n   * value if this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElse(27) // 10\n   * Failure(\"error\").getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    return this._isSuccess ? this._successRef : fallback\n  }\n\n  /**\n   * Returns the value from a `Success` or the value generated\n   * by a given `thunk` in case this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElseL(() => 27) // 10\n   * Failure(\"error\").getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    return this._isSuccess ? this._successRef : thunk()\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `null`.\n   *\n   * ```typescript\n   * Success(10).orNull()      // 10\n   * Failure(\"error\").orNull() // null\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orNull()\n   * ```\n   */\n  orNull(): A | null {\n    if (this._isSuccess) return this._successRef\n    return null\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if\n   * the source is a [[Failure]] then return the `fallback`.\n   *\n   * ```typescript\n   * Success(10).orElse(Success(17))      // 10\n   * Failure(\"error\").orElse(Success(17)) // 17\n   * ```\n   */\n  orElse<AA>(fallback: Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return fallback\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if the source\n   * is a [[Failure]] then return the value generated by the given\n   * `thunk`.\n   *\n   * ```typescript\n   * Success(10).orElseL(() => Success(17))      // 10\n   * Failure(\"error\").orElseL(() => Success(17)) // 17\n   * ```\n   */\n  orElseL<AA>(thunk: () => Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return thunk()\n  }\n\n  /**\n   * Inverts this `Try`. If this is a [[Failure]], returns its exception wrapped\n   * in a [[Success]]. If this is a `Success`, returns a `Failure` containing a\n   * [[NoSuchElementError]].\n   */\n  failed(): Try<any> {\n    return this._isSuccess\n      ? Failure(new NoSuchElementError(\"try.failed()\"))\n      : Success(this._failureRef)\n  }\n\n  /**\n   * Applies the `failure` function to [[Failure]] values, and the\n   * `success` function to [[Success]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Try<number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     error => `Could not parse string: ${error}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<R>(failure: (error: any) => R, success: (a: A) => R): R {\n    return this._isSuccess\n      ? success(this._successRef)\n      : failure(this._failureRef)\n  }\n\n  /**\n   * Returns a [[Failure]] if the source is a [[Success]], but the\n   * given `p` predicate is not satisfied.\n   *\n   * @throws NoSuchElementError in case the predicate doesn't hold\n   */\n  filter(p: (a: A) => boolean): Try<A> {\n    if (!this._isSuccess) return this\n    try {\n      if (p(this._successRef)) return this\n      return Failure(\n        new NoSuchElementError(\n          `Predicate does not hold for ${this._successRef}`\n        ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Returns the given function applied to the value if this is\n   * a [[Success]] or returns `this` if this is a [[Failure]].\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Try` references.\n   *\n   * ```typescript\n   * Try.of(() => parse(s1)).flatMap(num1 =>\n   *   Try.of(() => parse(s2)).map(num2 =>\n   *     num1 / num2\n   *   ))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Try<B>): Try<B> {\n    if (!this._isSuccess) return this as any\n    try {\n      return f(this._successRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Try<B>): Try<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Returns a `Try` containing the result of applying `f` to\n   * this option's value, but only if it's a `Success`, or\n   * returns the current `Failure` without any modifications.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in a `Try`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this `Try` if successful.\n   *\n   * @return a new `Try` instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Try<B> {\n    return this._isSuccess\n      ? Try.of(() => f(this._successRef))\n      : ((this as any) as Try<B>)\n  }\n\n  /**\n   * Applies the given function `cb` if this is a [[Success]], otherwise\n   * returns `void` if this is a [[Failure]].\n   */\n  forEach(cb: (a: A) => void): void {\n    if (this._isSuccess) cb(this._successRef)\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recover<AA>(f: (error: any) => AA): Try<A | AA> {\n    return this._isSuccess ? this : Try.of(() => f(this._failureRef))\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recoverWith<AA>(f: (error: any) => Try<AA>): Try<A | AA> {\n    try {\n      return this._isSuccess ? this : f(this._failureRef)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Transforms the source into an [[Option]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Some(v)`. If the source is a `Failure(e)`, then a `None`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toOption() // Some(\"value\")\n   * Failure(\"error\").toOption() // None\n   * ```\n   */\n  toOption(): Option<A> {\n    return this._isSuccess ? Some(this._successRef) : None\n  }\n\n  /**\n   * Transforms the source into an [[Either]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Right(v)`. If the source is a `Failure(e)`, then a `Left(e)`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toEither() // Right(\"value\")\n   * Failure(\"error\").toEither() // Left(\"error\")\n   * ```\n   */\n  toEither(): Either<any, A> {\n    return this._isSuccess\n      ? Right(this._successRef)\n      : Left(this._failureRef)\n  }\n\n  // Implemented from IEquals\n  equals(that: Try<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    return this._isSuccess\n      ? that._isSuccess && std.is(this._successRef, that._successRef)\n      : !that._isSuccess && std.is(this._failureRef, that._failureRef)\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    return this._isSuccess\n      ? std.hashCode(this._successRef)\n      : std.hashCode(this._failureRef)\n  }\n\n  // Implements HK<F, A>\n  readonly _funKindF: Try<any>\n  readonly _funKindA: A\n\n  // Implements Constructor<T>\n  static readonly _funErasure: Try<any>\n\n  /**\n   * Evaluates the given `thunk` and returns either a [[Success]],\n   * in case the evaluation succeeded, or a [[Failure]], in case\n   * an exception was thrown.\n   *\n   * Example:\n   *\n   * ```typescript\n   * let effect = 0\n   *\n   * const e = Try.of(() => { effect += 1; return effect })\n   * e.get() // 1\n   * ```\n   */\n  static of<A>(thunk: () => A): Try<A> {\n    try {\n      return Success(thunk())\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias of [[Try.success]]. */\n  static pure<A>(value: A): Try<A> {\n    return Try.success(value)\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Try<void> {\n    return tryUnitRef\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a successful result\n   * (i.e. wrapped in [[Success]]).\n   */\n  static success<A>(value: A): Try<A> {\n    return Success(value)\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a failure\n   * (i.e. an exception wrapped in [[Failure]]).\n   */\n  static failure<A>(e: any): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Maps 2 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if both `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(3)\n   * Try.map2(Success(1), Success(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map2(Success(1), Failure(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(\n    fa1: Try<A1>, fa2: Try<A2>,\n    f: (a1: A1, a2: A2) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    try {\n      return Success(f(fa1._successRef, fa2._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 3 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 3 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(6)\n   * Try.map3(Success(1), Success(2), Success(3),\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 4 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 4 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(10)\n   * Try.map4(Success(1), Success(2), Success(3), Success(4),\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 5 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 5 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(15)\n   * Try.map5(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map5(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 6 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 6 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(21)\n   * Try.map6(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map6(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, fa6: Try<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Try<R> {\n\n    if (fa1.isFailure()) return ((fa1 as any) as Try<R>)\n    if (fa2.isFailure()) return ((fa2 as any) as Try<R>)\n    if (fa3.isFailure()) return ((fa3 as any) as Try<R>)\n    if (fa4.isFailure()) return ((fa4 as any) as Try<R>)\n    if (fa5.isFailure()) return ((fa5 as any) as Try<R>)\n    if (fa6.isFailure()) return ((fa6 as any) as Try<R>)\n    try {\n      return Success(f(\n        fa1._successRef,\n        fa2._successRef,\n        fa3._successRef,\n        fa4._successRef,\n        fa5._successRef,\n        fa6._successRef))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in {@link FlatMap.tailRecM}.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Try<Either<A, B>>): Try<B> {\n    let cursor = a\n    while (true) {\n      try {\n        const result = f(cursor) as Try<Either<A, B>>\n        if (result.isFailure()) return result as any\n\n        const some = result.get()\n        if (some.isRight()) return Success(some.get())\n        cursor = some.swap().get()\n      } catch (e) {\n        return Failure(e)\n      }\n    }\n  }\n}\n\n/**\n * The `Success` data constructor is for building [[Try]] values that\n * are successful results of computations, as opposed to [[Failure]].\n */\nexport function Success<A>(value: A): Try<A> {\n  return new (Try as any)(value, null, true)\n}\n\n/**\n * The `Failure` data constructor is for building [[Try]] values that\n * represent failures, as opposed to [[Success]].\n */\nexport function Failure(e: any): Try<never> {\n  return new (Try as any)(null as never, e, false)\n}\n\n/**\n * Reusable reference, to use in {@link Try.unit}.\n *\n * @private\n */\nconst tryUnitRef: Try<void> = Success(undefined)\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Cancelable} interface for dealing with the disposal\n * of resources, along with `Cancelable` implementations for composing\n * cancelable actions.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Cancelable } from \"funfix/dist/exec/cancelable\"\n * // ... or ...\n * import { Cancelable } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module exec/cancelable\n */\n\n/***/\n\nimport { CompositeError, IllegalStateError } from \"../core/errors\"\n\n/**\n * `ICancelable` represents a one-time idempotent action that can be\n * used to cancel async computations, or to release resources that\n * active data sources are holding.\n *\n * It is similar in spirit to `java.io.Closeable`, but without the I/O\n * focus, or to `IDisposable` in Microsoft .NET.\n *\n * ```typescript\n * // Scheduling execution with a 10 seconds delay\n * const ref = setTimeout(() => console.log(\"Hello1\"), 10000)\n * const task = Cancelable.of(() => clearTimeout(ref))\n *\n * // If we change our mind\n * task.cancel()\n * ```\n *\n * In case some API requires the return of an `ICancelable` reference,\n * but there isn't anything that can be canceled, then\n * [[Cancelable.empty]] can be used to return a reusable reference\n * that doesn't do anything when canceled.\n *\n * ```typescript\n * const task = Cancelable.empty()\n *\n * // It's a no-op, doesn't do anything\n * task.cancel()\n * ```\n *\n * Implementation sample:\n *\n * ```typescript\n * class MyCancelable implements ICancelable {\n *   // Idempotency guard\n *   private _isCanceled: boolean = false\n *\n *   cancel() {\n *     // We need an idempotency guarantee, any side-effects\n *     // need to happen only once\n *     if (!this._isCanceled) {\n *       this._isCanceled = true\n *       console.log(\"Was canceled!\")\n *     }\n *   }\n * }\n * ```\n */\nexport interface ICancelable {\n  cancel(): void\n}\n\n/**\n * `Cancelable` is an {@link ICancelable} class providing useful\n * builders for simple cancelable references.\n */\nexport abstract class Cancelable implements ICancelable {\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `Cancelable` reference.\n   *\n   * ```typescript\n   * const task = Cancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  static of(cb: () => void): Cancelable {\n    return new WrapFn(cb)\n  }\n\n  /**\n   * Returns a reusable `Cancelable` reference that doesn't\n   * do anything on `cancel`.\n   */\n  static empty(): Cancelable {\n    return Empty\n  }\n\n  /**\n   * Returns a [[Cancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be canceled\n   * as a group.\n   *\n   * ```typescript\n   * val list = Cancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  static collection(...refs: Array<ICancelable>): Cancelable {\n    return new CollectionCancelable(refs)\n  }\n}\n\n/**\n * Concrete [[Cancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use {@link Cancelable.of}\n * to instantiate it.\n *\n * @Private\n * @Hidden\n */\nclass WrapFn extends Cancelable {\n  protected thunk: null | (() => void)\n\n  constructor(cb: () => void) {\n    super()\n    this.thunk = cb\n  }\n\n  cancel() {\n    if (this.thunk !== null) {\n      const ref = this.thunk\n      this.thunk = null\n      ref()\n    }\n  }\n}\n\n/**\n * Reusable [[Cancelable]] reference that doesn't do anything on\n * cancel.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.empty]].\n *\n * @Hidden\n */\nconst Empty: Cancelable =\n  new (//noinspection JSUnusedLocalSymbols\n    class Empty extends Cancelable {\n      cancel() {}\n    })()\n\n/**\n * `IBoolCancelable` represents a {@link ICancelable} that can be queried\n * for the canceled status.\n */\nexport interface IBoolCancelable extends ICancelable {\n  /**\n   * Return `true` in case this cancelable hasn't been canceled,\n   * or `false` otherwise.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.of()\n   *\n   * ref.isCanceled() // false\n   * ref.cancel()\n   * ref.isCanceled() // true\n   * ```\n   */\n  isCanceled(): boolean\n}\n\n/**\n * `BoolCancelable` is an {@link IBoolCancelable} class providing useful\n * builders for cancelable references that can be queried for their\n * canceled status.\n */\nexport abstract class BoolCancelable implements IBoolCancelable {\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Lifts any callback into a `BoolCancelable` reference.\n   *\n   * ```typescript\n   * const task = BoolCancelable.of(() => {\n   *   console.log(\"I was canceled!\")\n   * })\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * //=> I was canceled!\n   *\n   * task.isCanceled()\n   * //=> true\n   * ```\n   *\n   * The returned reference has guaranteed idempotence, so\n   * calling it multiple times will trigger the given\n   * callback only once.\n   */\n  public static of(cb: () => void): BoolCancelable {\n    return new BoolWrapFn(cb)\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that doesn't do\n   * anything on `cancel` except for changing the status of `isCanceled`\n   * from `false` to `true`.\n   *\n   * ```typescript\n   * const task = BoolCancelable.empty()\n   *\n   * task.isCanceled()\n   * //=> false\n   *\n   * task.cancel()\n   * task.isCanceled()\n   * //=> true\n   * ```\n   */\n  public static empty(): BoolCancelable {\n    return new BoolEmpty()\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] reference that is already canceled.\n   *\n   * ```typescript\n   * const ref = BoolCancelable.alreadyCanceled()\n   *\n   * ref.isCanceled()\n   * //=> true\n   *\n   * // Doesn't do anything, it's a no-op\n   * ref.cancel()\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): BoolCancelable {\n    return AlreadyCanceled\n  }\n\n  /**\n   * Returns a [[BoolCancelable]] implementation that represents an\n   * immutable list of [[Cancelable]] references which can be\n   * canceled as a group.\n   *\n   * ```typescript\n   * val list = BoolCancelable.collection(\n   *   Cancelable.of(() => console.log(\"Cancelled #1\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #2\")),\n   *   Cancelable.of(() => console.log(\"Cancelled #3\"))\n   * )\n   *\n   * list.cancel()\n   * //=> Cancelled #1\n   * //=> Cancelled #2\n   * //=> Cancelled #3\n   * ```\n   *\n   * @param refs is the array of references to cancel when\n   *        cancellation is triggered\n   */\n  public static collection(...refs: Array<ICancelable>): BoolCancelable {\n    return new CollectionCancelable(refs)\n  }\n}\n\n/**\n * [[Cancelable]] implementation that represents an immutable list of\n * [[Cancelable]] references which can be canceled as a group.\n *\n * Implementation is package private, to access it use\n * [[Cancelable.collection]].\n *\n * @Hidden\n */\nclass CollectionCancelable extends BoolCancelable {\n  private _refs: ICancelable[]\n  private _isCanceled: boolean\n\n  constructor(refs: ICancelable[]) {\n    super()\n    this._refs = refs\n    this._isCanceled = false\n  }\n\n  public isCanceled(): boolean {\n    return this._isCanceled\n  }\n\n  public cancel(): void {\n    if (!this._isCanceled) {\n      this._isCanceled = true\n      const errors = []\n      for (const c of this._refs) {\n        try { c.cancel() } catch (e) { errors.push(e) }\n      }\n\n      this._refs = [] // GC purposes\n      if (errors.length === 1) throw errors[0]\n      else if (errors.length > 1) throw new CompositeError(errors)\n    }\n  }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that wraps a callback.\n *\n * Implementation is package private, use [[BoolCancelable.of]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolWrapFn extends WrapFn implements BoolCancelable {\n  isCanceled() { return this.thunk === null }\n}\n\n/**\n * Concrete [[BoolCancelable]] implementation that doesn't do\n * anything on `cancel` except for changing the status of `isCanceled`\n * from `false` to `true`.\n *\n * Implementation is package private, use [[BoolCancelable.empty]]\n * to instantiate it.\n *\n * @Hidden\n */\nclass BoolEmpty extends BoolCancelable {\n  private canceled: boolean = false\n\n  isCanceled(): boolean { return this.canceled }\n  public cancel(): void { this.canceled = true }\n}\n\n/**\n * Reusable [[BoolCancelable]] reference that's already canceled.\n *\n * Implementation is package private, to access it use\n * [[BoolCancelable.alreadyCanceled]].\n *\n * @Hidden\n */\nconst AlreadyCanceled: BoolCancelable =\n  new (//noinspection JSUnusedLocalSymbols\n    class AlreadyCanceled extends BoolCancelable {\n      isCanceled() { return true }\n      cancel() {}\n    })()\n\n/**\n * Represents a type of [[ICancelable]] that can hold\n * an internal reference to another cancelable (and thus\n * has to support the `update` operation).\n *\n * On assignment, if this cancelable is already\n * canceled, then no assignment should happen and the update\n * reference should be canceled as well.\n */\nexport interface IAssignCancelable extends IBoolCancelable {\n  /**\n   * Updates the internal reference of this assignable cancelable\n   * to the given value.\n   *\n   * If this cancelable is already canceled, then `value` is\n   * going to be canceled on assignment as well.\n   */\n  update(value: ICancelable): this\n}\n\n/**\n * `AssignCancelable` is an {@link IAssignCancelable} class providing\n * useful builders for cancelable references that can be assigned.\n */\nexport abstract class AssignCancelable implements IAssignCancelable {\n  /** Inherited from {@link IAssignCancelable.update}. */\n  abstract update(value: ICancelable): this\n\n  /** Inherited from {@link IBoolCancelable.isCanceled}. */\n  abstract isCanceled(): boolean\n\n  /** Inherited from {@link ICancelable.cancel}. */\n  abstract cancel(): void\n\n  /**\n   * Returns an [[AssignCancelable]] reference that is already\n   * canceled.\n   *\n   * ```typescript\n   * const ref = AssignCancelable.alreadyCanceled()\n   * ref.isCanceled() //=> true\n   *\n   * const c = BooleanCancelable.empty()\n   * ref.update(c) // cancels c\n   * c.isCanceled() // true\n   * ```\n   *\n   * The implementation returns the same reusable reference.\n   */\n  public static alreadyCanceled(): AssignCancelable {\n    return AlreadyCanceledAssignable\n  }\n\n  /**\n   * Returns a new [[AssignCancelable]] that's empty.\n   *\n   * The returned reference is an instance of\n   * [[MultiAssignCancelable]], but this is an implementation\n   * detail that may change in the future.\n   */\n  public static empty(): AssignCancelable {\n    return MultiAssignCancelable.empty()\n  }\n\n  /**\n   * Initiates an [[AssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * AssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = AssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): AssignCancelable {\n    return MultiAssignCancelable.of(cb)\n  }\n}\n\n/**\n * Internal reusable reference for [[AssignCancelable]].\n * @Hidden\n */\nconst AlreadyCanceledAssignable: AssignCancelable =\n  new (//noinspection JSUnusedLocalSymbols\n    class AlreadyCanceledAssignable extends AssignCancelable {\n      isCanceled() { return true }\n      cancel() {}\n      update(value: ICancelable) { value.cancel(); return this }\n    })()\n\n/**\n * The `MultiAssignCancelable` is an {@link IAssignCancelable} whose\n * underlying cancelable reference can be swapped for another.\n *\n * Example:\n *\n * ```typescript\n * const ref = MultiAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class MultiAssignCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean { return this._canceled }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * In case the underlying reference is also a `MultiAssignCancelable`, then\n   * collapse its state into this one.\n   *\n   * ```typescript\n   * const c = Cancelable.of(() => console.info(\"Cancelled!\"))\n   *\n   * const mc1 = new MultiAssignCancelable()\n   * mc1.update(c)\n   *\n   * const mc2 = new MultiAssignCancelable()\n   * mc2.update(mc1)\n   *\n   * // After this the underlying reference of `mc2` becomes `c`\n   * mc2.collapse()\n   * ```\n   */\n  public collapse(): this {\n    if (this._underlying && this._underlying instanceof MultiAssignCancelable) {\n      const ref = this._underlying\n      this._underlying = ref._underlying\n      this._canceled = ref._canceled\n    }\n    return this\n  }\n\n  /**\n   * Sets the underlying cancelable reference to `undefined`,\n   * useful for garbage-collecting purposes.\n   */\n  public clear(): this {\n    if (!this._canceled) this._underlying = undefined\n    return this\n  }\n\n  /**\n   * Returns a new [[MultiAssignCancelable]] that's empty.\n   */\n  public static empty(): MultiAssignCancelable {\n    return new MultiAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[MultiAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * MultiAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = MultiAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): MultiAssignCancelable {\n    return new MultiAssignCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SerialCancelable` is an {@link IAssignCancelable} whose underlying\n * cancelable reference can be swapped for another and on each\n * swap the previous reference gets canceled.\n *\n * Example:\n *\n * ```typescript\n * const ref = SerialCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n * ref.update(c2) // cancels c1, swaps the underlying cancelable to c2\n *\n * ref.cancel() // also cancels c2\n * ref := c3 // also cancels c3, because s is already canceled\n * ```\n *\n * Also see [[SerialCancelable]], which is similar, except that it\n * cancels the old cancelable upon assigning a new cancelable.\n */\nexport class SerialCancelable implements IAssignCancelable {\n  private _underlying?: ICancelable\n  private _canceled: boolean\n\n  constructor(initial?: ICancelable) {\n    this._underlying = initial\n    this._canceled = false\n  }\n\n  public update(value: ICancelable): this {\n    if (this._canceled) value.cancel(); else {\n      if (this._underlying) this._underlying.cancel()\n      this._underlying = value\n    }\n    return this\n  }\n\n  public isCanceled(): boolean { return this._canceled }\n\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SerialCancelable]] that's empty.\n   */\n  public static empty(): SerialCancelable {\n    return new SerialCancelable()\n  }\n\n  /**\n   * Initiates an [[SerialCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SerialCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SerialCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SerialCancelable {\n    return new SerialCancelable(Cancelable.of(cb))\n  }\n}\n\n/**\n * The `SingleAssignCancelable` is a [[Cancelable]] that can be\n * assigned only once to another cancelable reference.\n *\n * Example:\n *\n * ```typescript\n * const ref = SingleAssignCancelable()\n * ref.update(c1) // sets the underlying cancelable to c1\n *\n * ref.update(c2) // throws IllegalStateError\n * ```\n *\n * See [[MultiAssignCancelable]] for a similar type that can be\n * assigned multiple types.\n */\nexport class SingleAssignCancelable implements IAssignCancelable {\n  private _wasAssigned: boolean\n  private _canceled: boolean\n  private _underlying?: ICancelable\n\n  constructor() {\n    this._canceled = false\n    this._wasAssigned = false\n  }\n\n  /** @inheritdoc */\n  public update(value: ICancelable): this {\n    if (this._wasAssigned)\n      throw new IllegalStateError(\"SingleAssignCancelable#update multiple times\")\n\n    this._wasAssigned = true\n    if (this._canceled) value.cancel()\n    else this._underlying = value\n    return this\n  }\n\n  /** @inheritdoc */\n  public isCanceled(): boolean { return this._canceled }\n\n  /** @inheritdoc */\n  public cancel(): void {\n    if (!this._canceled) {\n      this._canceled = true\n      if (this._underlying) {\n        this._underlying.cancel()\n        delete this._underlying\n      }\n    }\n  }\n\n  /**\n   * Returns a new [[SingleAssignCancelable]] that's empty.\n   */\n  public static empty(): SingleAssignCancelable {\n    return new SingleAssignCancelable()\n  }\n\n  /**\n   * Initiates an [[SingleAssignCancelable]] reference and assigns it\n   * a reference that wraps the given `cb` callback.\n   *\n   * So this code:\n   *\n   * ```typescript\n   * SingleAssignCancelable.of(() => console.log(\"cancelled\"))\n   * ```\n   *\n   * Is equivalent to this:\n   *\n   * ```typescript\n   * const ref = SingleAssignCancelable.empty()\n   * ref.update(Cancelable.of(() => console.log(\"cancelled\")))\n   * ```\n   */\n  public static of(cb: () => void): SingleAssignCancelable {\n    const ref = new SingleAssignCancelable()\n    ref.update(Cancelable.of(cb))\n    return ref\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Module exporting data types for expressing timespans.\n *\n * See:\n *\n * - {@link TimeUnit}\n * - {@link Duration}\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Duration } from \"funfix/dist/exec/time\"\n * // ... or ...\n * import { Duration } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module exec/time\n */\n\n/***/\n\nimport { IEquals } from \"../core/std\"\nimport { IllegalArgumentError } from \"../core/errors\"\n\n/**\n * A `TimeUnit` represents time durations at a given unit of\n * granularity and provides utility methods to convert across units,\n * and to perform timing and delay operations in these units.\n *\n * A `TimeUnit` does not maintain time information, but only helps\n * organize and use time representations that may be maintained\n * separately across various contexts. A nanosecond is defined as one\n * thousandth of a microsecond, a microsecond as one thousandth of a\n * millisecond, a millisecond as one thousandth of a second, a minute\n * as sixty seconds, an hour as sixty minutes, and a day as twenty\n * four hours.\n *\n * `TimeUnit` is an enumeration and in usage the already defined\n * constants should be used:\n *\n *  - [[NANOSECONDS]]\n *  - [[MICROSECONDS]]\n *  - [[MILLISECONDS]]\n *  - [[SECONDS]]\n *  - [[MINUTES]]\n *  - [[HOURS]]\n *  - [[DAYS]]\n *\n * Example:\n *\n * ```typescript\n * // Converting 10 minutes to nanoseconds\n * MINUTES.toNanos(10)\n * // Equivalent with the above:\n * NANOSECONDS.convert(10, MINUTES)\n * ```\n */\nexport abstract class TimeUnit {\n  /**\n   * Converts the given time duration in the given unit to this unit.\n   * Conversions from finer to coarser granularities truncate, so lose\n   * precision. For example, converting `999` milliseconds to seconds\n   * results in `0`. Conversions from coarser to finer granularities\n   * with arguments that would numerically overflow saturate to\n   * `Number.MAX_VALUE` if negative or `MAX_VALUE` if positive.\n   *\n   * For example, to convert 10 minutes to milliseconds, use:\n   *\n   * ```typescript\n   * MILLISECONDS.convert(10, MINUTES)\n   * // ... or ...\n   * MINUTES.toMillis(10)\n   * ```\n   *\n   * @param duration the time duration in the given `unit`\n   * @param unit the unit of the `duration` argument\n   *\n   * @return the converted duration in this unit, or `Number.MIN_VALUE`\n   * if conversion would negatively overflow, or `Number.MAX_VALUE`\n   * if it would positively overflow\n   */\n  abstract convert(duration: number, unit: TimeUnit): number\n\n  /**\n   * Converts the given `d` value to nanoseconds.\n   *\n   * Equivalent with `NANOSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toNanos(d: number): number\n\n  /**\n   * Converts the given `d` value to microseconds.\n   *\n   * Equivalent with `MICROSECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMicros(d: number): number\n\n  /**\n   * Converts the given `d` value to milliseconds.\n   *\n   * Equivalent with `MILLISECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMillis(d: number): number\n\n  /**\n   * Converts the given `d` value to seconds.\n   *\n   * Equivalent with `SECONDS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toSeconds(d: number): number\n\n  /**\n   * Converts the given `d` value to minutes.\n   *\n   * Equivalent with `MINUTES.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toMinutes(d: number): number\n\n  /**\n   * Converts the given `d` value to hours.\n   *\n   * Equivalent with `HOURS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toHours(d: number): number\n\n  /**\n   * Converts the given `d` value to days.\n   *\n   * Equivalent with `DAYS.convert(duration, this)`.\n   *\n   * @param d is the converted duration\n   * @return the converted duration, or `Number.MAX_SAFE_INTEGER + 1`\n   * (or `2^53`) if it overflows, or `Number.MIN_SAFE_INTEGER - 1` if it\n   * underflows (or `-2^53`).\n   */\n  abstract toDays(d: number): number\n\n  /**\n   * A number representing the unit's ordering in the `TimeUnit`\n   * enumeration, useful for doing comparisons to find out which unit\n   * is more coarse grained.\n   *\n   * ```typescript\n   * MINUTES.ord < DAYS.ord // true\n   * SECONDS.ord > MICROSECONDS.org // true\n   * ```\n   */\n  abstract ord: number\n\n  /**\n   * A human readable label for this unit.\n   */\n  abstract label: string\n\n  /** Override for `Object.toString`. */\n  toString(): string {\n    return this.label.toUpperCase()\n  }\n}\n\n/** @hidden */ const C0 = 1\n/** @hidden */ const C1 = C0 * 1000\n/** @hidden */ const C2 = C1 * 1000\n/** @hidden */ const C3 = C2 * 1000\n/** @hidden */ const C4 = C3 * 60\n/** @hidden */ const C5 = C4 * 60\n/** @hidden */ const C6 = C5 * 24\n\n/** @hidden */ const MIN = -9007199254740992\n/** @hidden */ const MAX = 9007199254740992\n\n/** @hidden */\nconst trunc: (x: number) => number = Math.trunc ||\n  /* istanbul ignore next */\n  function (x) {\n    if (isNaN(x)) return NaN\n    if (x > 0) return Math.floor(x)\n    return Math.ceil(x)\n  }\n\n/** @hidden */\nfunction x(d: number, m: number, over: number): number {\n  if (d > over) return MAX\n  if (d < -over) return MIN\n  return d * m\n}\n\n/** @hidden */\nclass Nanoseconds extends TimeUnit {\n  ord: number = 0\n  label = \"nanoseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toNanos(duration) }\n  toNanos(d: number): number { return d }\n  toMicros(d: number): number { return trunc(d / (C1 / C0)) }\n  toMillis(d: number): number { return trunc(d / (C2 / C0)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C0)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C0)) }\n  toHours(d: number): number { return trunc(d / (C5 / C0)) }\n  toDays(d: number): number { return trunc(d / (C6 / C0)) }\n}\n\n /**\n  * Time unit for representing nanoseconds, where 1 nanosecond is\n  * one thousandth of a microsecond.\n  */\nexport const NANOSECONDS: TimeUnit =\n  new Nanoseconds()\n\n/** @hidden */\nclass Microseconds extends TimeUnit {\n  ord: number = 1\n  label = \"microseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMicros(duration) }\n  toNanos(d: number): number { return x(d, C1 / C0, trunc(MAX / (C1 / C0))) }\n  toMicros(d: number): number { return d }\n  toMillis(d: number): number { return trunc(d / (C2 / C1)) }\n  toSeconds(d: number): number { return trunc(d / (C3 / C1)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C1)) }\n  toHours(d: number): number { return trunc(d / (C5 / C1)) }\n  toDays(d: number): number { return trunc(d / (C6 / C1)) }\n}\n\n /**\n  * Time unit for representing microseconds, where 1 microsecond is\n  * one thousandth of a millisecond.\n  */\nexport const MICROSECONDS: TimeUnit =\n  new Microseconds()\n\n/** @hidden */\nclass Milliseconds extends TimeUnit {\n  ord: number = 2\n  label = \"milliseconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMillis(duration) }\n  toNanos(d: number): number { return x(d, C2 / C0, trunc(MAX / (C2 / C0))) }\n  toMicros(d: number): number { return x(d, C2 / C1, trunc(MAX / (C2 / C1))) }\n  toMillis(d: number): number { return d }\n  toSeconds(d: number): number { return trunc(d / (C3 / C2)) }\n  toMinutes(d: number): number { return trunc(d / (C4 / C2)) }\n  toHours(d: number): number { return trunc(d / (C5 / C2)) }\n  toDays(d: number): number { return trunc(d / (C6 / C2)) }\n}\n\n /**\n  * Time unit for representing milliseconds, where 1 millisecond is\n  * one thousandth of a second.\n  */\nexport const MILLISECONDS: TimeUnit =\n  new Milliseconds()\n\n/** @hidden */\nclass Seconds extends TimeUnit {\n  ord: number = 3\n  label = \"seconds\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toSeconds(duration) }\n  toNanos(d: number): number { return x(d, C3 / C0, trunc(MAX / (C3 / C0))) }\n  toMicros(d: number): number { return x(d, C3 / C1, trunc(MAX / (C3 / C1))) }\n  toMillis(d: number): number { return x(d, C3 / C2, trunc(MAX / (C3 / C2))) }\n  toSeconds(d: number): number { return d }\n  toMinutes(d: number): number { return trunc(d / (C4 / C3)) }\n  toHours(d: number): number { return trunc(d / (C5 / C3)) }\n  toDays(d: number): number { return trunc(d / (C6 / C3)) }\n}\n\n /**\n  * Time unit for representing seconds.\n  */\nexport const SECONDS: TimeUnit =\n  new Seconds()\n\n/** @hidden */\nclass Minutes extends TimeUnit {\n  ord: number = 4\n  label = \"minutes\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toMinutes(duration) }\n  toNanos(d: number): number { return x(d, C4 / C0, trunc(MAX / (C4 / C0))) }\n  toMicros(d: number): number { return x(d, C4 / C1, trunc(MAX / (C4 / C1))) }\n  toMillis(d: number): number { return x(d, C4 / C2, trunc(MAX / (C4 / C2))) }\n  toSeconds(d: number): number { return x(d, C4 / C3, trunc(MAX / (C4 / C3))) }\n  toMinutes(d: number): number { return d }\n  toHours(d: number): number { return trunc(d / (C5 / C4)) }\n  toDays(d: number): number { return trunc(d / (C6 / C4)) }\n}\n\n /**\n  * Time unit for representing minutes.\n  */\nexport const MINUTES: TimeUnit =\n  new Minutes()\n\n/** @hidden */\nclass Hours extends TimeUnit {\n  ord: number = 5\n  label = \"hours\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toHours(duration) }\n  toNanos(d: number): number { return x(d, C5 / C0, trunc(MAX / (C5 / C0))) }\n  toMicros(d: number): number { return x(d, C5 / C1, trunc(MAX / (C5 / C1))) }\n  toMillis(d: number): number { return x(d, C5 / C2, trunc(MAX / (C5 / C2))) }\n  toSeconds(d: number): number { return x(d, C5 / C3, trunc(MAX / (C5 / C3))) }\n  toMinutes(d: number): number { return x(d, C5 / C4, trunc(MAX / (C5 / C4))) }\n  toHours(d: number): number { return d }\n  toDays(d: number): number { return trunc(d / (C6 / C5)) }\n}\n\n /**\n  * Time unit for representing hours.\n  */\nexport const HOURS: TimeUnit =\n  new Hours()\n\n/** @hidden */\nclass Days extends TimeUnit {\n  ord: number = 6\n  label = \"days\"\n  convert(duration: number, unit: TimeUnit): number { return unit.toDays(duration) }\n  toNanos(d: number): number { return x(d, C6 / C0, trunc(MAX / (C6 / C0))) }\n  toMicros(d: number): number { return x(d, C6 / C1, trunc(MAX / (C6 / C1))) }\n  toMillis(d: number): number { return x(d, C6 / C2, trunc(MAX / (C6 / C2))) }\n  toSeconds(d: number): number { return x(d, C6 / C3, trunc(MAX / (C6 / C3))) }\n  toMinutes(d: number): number { return x(d, C6 / C4, trunc(MAX / (C6 / C4))) }\n  toHours(d: number): number { return x(d, C6 / C5, trunc(MAX / (C6 / C5))) }\n  toDays(d: number): number { return d }\n}\n\n /**\n  * Time unit for representing days.\n  */\nexport const DAYS: TimeUnit =\n  new Days()\n\n/**\n * A simple representation for time durations, based on [[TimeUnit]].\n */\nexport class Duration implements IEquals<Duration> {\n  public duration: number\n  public unit: TimeUnit\n\n  constructor(duration: number, unit: TimeUnit) {\n    if (isNaN(duration)) {\n      throw new IllegalArgumentError(\"NaN is not supported for a Duration\")\n    }\n    // Only integers allowed\n    this.duration = trunc(duration)\n    this.unit = unit\n  }\n\n  /**\n   * This method returns `true` if this duration is finite,\n   * or `false otherwise.\n   */\n  isFinite(): boolean { return isFinite(this.duration) }\n\n  /**\n   * Calculates the nanoseconds described by the source [[Duration]].\n   */\n  toNanos(): number {\n    return NANOSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the microseconds described by the source [[Duration]].\n   */\n  toMicros(): number {\n    return MICROSECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the milliseconds described by the source [[Duration]].\n   */\n  toMillis(): number {\n    return MILLISECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the seconds described by the source [[Duration]].\n   */\n  toSeconds(): number {\n    return SECONDS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the minutes described by the source [[Duration]].\n   */\n  toMinutes(): number {\n    return MINUTES.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the hours described by the source [[Duration]].\n   */\n  toHours(): number {\n    return HOURS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Calculates the days described by the source [[Duration]].\n   */\n  toDays(): number {\n    return DAYS.convert(this.duration, this.unit)\n  }\n\n  /**\n   * Returns a new `Duration` value that represents `this` converted\n   * to use the given `unit`.\n   *\n   * Note that this may be a lossy conversion, e.g. when converting\n   * 27 hours to 1 day, there's a loss of fidelity.\n   */\n  convertTo(unit: TimeUnit): Duration {\n    return new Duration(unit.convert(this.duration, this.unit), unit)\n  }\n\n  /**\n   * Negates `this` duration, by changing the sign.\n   */\n  negate(): Duration {\n    switch (this.duration) {\n      case Infinity: return Duration.negInf()\n      case -Infinity: return Duration.inf()\n      default:\n        return new Duration(-this.duration, this.unit)\n    }\n  }\n\n  /**\n   * Return the sum of `this` duration and `other`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two.\n   *\n   * ```typescript\n   * // Result will be 27 hours\n   * Duration.days(1).plus(Duration.hours(3))\n   * ```\n   */\n  plus(other: Duration): Duration {\n    if (!isFinite(this.duration)) {\n      if (!isFinite(other.duration) && this.duration !== other.duration) {\n        throw new IllegalArgumentError(\n          \"cannot deal with two infinities with different signs, \" +\n          \"as that would be a NaN\")\n      }\n      return this\n    } else if (other.duration === 0) {\n      return this\n    } else if (this.duration === 0) {\n      return other\n    }\n\n    if (!isFinite(other.duration)) return other\n\n    let d1: Duration = this\n    let d2: Duration = other\n    if (d2.unit.ord < d1.unit.ord) { d1 = other; d2 = this }\n\n    d2 = d2.convertTo(d1.unit)\n    return new Duration(d1.duration + d2.duration, d1.unit)\n  }\n\n  /**\n   * Subtracts the `other` duration from `this`.\n   *\n   * Note that the `unit` used for the result will be the\n   * more finer grained one out of the two:\n   *\n   * ```typescript\n   * // Result will be 21 hours\n   * Duration.days(1).minus(Duration.hours(3))\n   * ```\n   */\n  minus(other: Duration): Duration {\n    return this.plus(other.negate())\n  }\n\n  /** @inheritdoc */\n  equals(other: Duration): boolean {\n    function cmp(s: Duration, o: Duration) {\n      const n = s.unit.convert(o.duration, o.unit)\n      return n === s.duration\n    }\n\n    if (!isFinite(this.duration)) {\n      return !isFinite(other.duration) &&\n        this.duration === other.duration\n    }\n    return this.unit.ord <= other.unit.ord\n      ? cmp(this, other) : cmp(other, this)\n  }\n\n  /** @inheritdoc */\n  hashCode(): number {\n    if (this.isFinite()) {\n      return this.toNanos()\n    } else if (this.duration === Infinity) {\n      return 7540833725118015\n    } else {\n      return 422082410550358\n    }\n  }\n\n  toString(): string {\n    if (this.isFinite())\n      return `${this.duration} ${this.unit.label}`\n    else if (this.duration >= 0)\n      return \"[end of time]\"\n    else\n      return \"[beginning of time]\"\n  }\n\n  /**\n   * Wraps the argument in a `Duration.millis` reference, in case it's\n   * a number, otherwise returns the argument as is.\n   *\n   * In Javascript code it is customary to express durations with\n   * numbers representing milliseconds and in functions it's good\n   * to still allow developers to do that because it's the standard\n   * convention.\n   *\n   * Thus one can work with a union type like `number | Duration`.\n   * And in case a `number` is given, then it is interpreted as\n   * milliseconds.\n   *\n   * Usage:\n   *\n   * ```typescript\n   * function delay(d: number | Duration, r: () => {}) {\n   *   const millis = Duration.of(d).toMillis()\n   *   return setTimeout(r, millis)\n   * }\n   * ```\n   */\n  static of(value: number | Duration): Duration {\n    return typeof value === \"number\"\n      ? Duration.millis(value)\n      : value\n  }\n\n  /** Returns a zero length duration. */\n  static zero(): Duration {\n    return new Duration(0, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing positive infinite. */\n  static inf(): Duration {\n    return new Duration(Infinity, DAYS)\n  }\n\n  /** Returns a [[Duration]] representing negative infinite. */\n  static negInf(): Duration {\n    return new Duration(-Infinity, DAYS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * nanoseconds.\n   */\n  static nanos(d: number): Duration {\n    return new Duration(d, NANOSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * microseconds.\n   */\n  static micros(d: number): Duration {\n    return new Duration(d, MICROSECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * milliseconds.\n   */\n  static millis(d: number): Duration {\n    return new Duration(d, MILLISECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * seconds.\n   */\n  static seconds(d: number): Duration {\n    return new Duration(d, SECONDS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * minutes.\n   */\n  static minutes(d: number): Duration {\n    return new Duration(d, MINUTES)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * hours.\n   */\n  static hours(d: number): Duration {\n    return new Duration(d, HOURS)\n  }\n\n  /**\n   * Constructs a `Duration` instance out of a value representing\n   * days.\n   */\n  static days(d: number): Duration {\n    return new Duration(d, DAYS)\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes {@link DynamicRef} for dynamically bound references.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Ref } from \"funfix/dist/exec/ref\"\n * // ... or ...\n * import { Ref } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module exec/ref\n */\n\n/***/\n\n/**\n * `DynamicRef` provides a binding mechanism where the current value is\n * found through dynamic scope, but where access to the variable itself is\n * resolved through static scope.\n *\n * The current value can be retrieved with the {@link DynamicRef.get} method.\n * New values should be pushed using the {@link DynamicRef.bind} method.\n *\n * Values pushed via `bind` only stay valid while its second argument,\n * a parameterless function (the `thunk`), executes. When that thunk finishes\n * execution, the reference reverts to the previous value.\n *\n * See {@link DynamicRef.bind} for a usage sample.\n *\n * @final\n */\nexport class DynamicRef<A> {\n  /** Returns the current value of this `DynamicRef`. */\n  get: () => A\n\n  private constructor(fn: () => A) {\n    this.get = fn\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (strict) `value` that's going to be\n   * visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bind(\"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bindL]{@link DynamicRef.bindL} for binding a non-strict value instead.\n   *\n   * @param value is the value to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bind<R>(value: A, thunk: () => R): R {\n    return this.bindL(() => value, thunk)\n  }\n\n  /**\n   * Binds this `DynamicRef` to a different (non-strict) `value` that's going\n   * to be visible while executing `thunk` and then it will get reverted to\n   * its previous value.\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const ref = DynamicRef.of(() => \"original\")\n   *\n   * ref.get() // original\n   *\n   * ref.bindL(() => \"modified\", () => {\n   *   ref.get() // modified\n   * })\n   *\n   * ref.get() // original\n   * ```\n   *\n   * @see [bind]{@link DynamicRef.bindL} for binding a strict value instead.\n   *\n   * @param value is the value generator to bind to this reference within `thunk`'s execution\n   * @param thunk is a parameterless function to execute\n   *\n   * @return the result of executing `thunk`\n   */\n  bindL<R>(value: () => A, thunk: () => R): R {\n    const oldFn = this.get\n    try {\n      (this as any).get = value\n      return thunk()\n    } finally {\n      (this as any).get = oldFn\n    }\n  }\n\n  /**\n   * Builds a {@link DynamicRef}, where the given parameterless function\n   * is going to be the generator for the default value of the returned\n   *\n   *\n   */\n  static of<A>(fn: () => A): DynamicRef<A> {\n    return new DynamicRef(fn)\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Internal utilities used in the Funfix implementation.\n *\n * @module exec/internals\n * @hidden\n */\n\n/***/\n\n/**\n * Given a sorted array, searches for an insert position for a given search\n * element such that, if inserted in the array at the returned position,\n * the array would remain sorted.\n */\nexport function arrayBSearchInsertPos<A>(array: Array<A>, f: (a: A) => number):\n  ((search: number) => number) {\n\n  return search => {\n    let minIndex = 0\n    let maxIndex = array.length - 1\n\n    while (minIndex <= maxIndex) {\n      const index = (minIndex + maxIndex) / 2 | 0\n      const current = f(array[index])\n      const next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined\n\n      if (current <= search && (next === undefined || search < next)) {\n        return index + 1\n      } else if (current <= search) {\n        minIndex = index + 1\n      } else { /* if (current > search) */\n        maxIndex = index - 1\n      }\n    }\n\n    return 0\n  }\n}\n\n/**\n * Internal utility that builds an iterator out of an `Iterable` or an `Array`.\n */\nexport function iterableToArray<A>(values: Iterable<A>): A[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as A[]\n\n  const cursor = values[Symbol.iterator]()\n  const arr: A[] = []\n\n  while (true) {\n    const item = cursor.next()\n    if (item.value) arr.push(item.value)\n    if (item.done) return arr\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides a {@link Scheduler} data type, capable of scheduling units of work\n * for asynchronous execution, as an alternative to Javascript's `setTimeout`,\n * `setInterval` or other globally available commands.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Scheduler } from \"funfix/dist/exec/scheduler\"\n * // ... or ...\n * import { Scheduler } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module exec/scheduler\n */\n\n/***/\n\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, IAssignCancelable, MultiAssignCancelable } from \"./cancelable\"\nimport { DynamicRef } from \"./ref\"\nimport { arrayBSearchInsertPos } from \"./internals\"\n\n/**\n * A `Scheduler` is an execution context that can execute units of\n * work asynchronously, with a delay or periodically.\n *\n * It replaces Javascript's `setTimeout`, which is desirable due to\n * the provided utilities and because special behavior might be needed\n * in certain specialized contexts (e.g. tests), even if the\n * [[Scheduler.global]] reference is implemented with `setTimeout`.\n */\nexport abstract class Scheduler {\n  /**\n   * Schedules the given `command` for async execution.\n   *\n   * In [[GlobalScheduler]] this method uses\n   * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}\n   * when available. But given that `setImmediate` is a very\n   * non-standard operation that is currently implemented only by\n   * IExplorer and Node.js, on non-supporting environments we fallback\n   * on `setTimeout`. See\n   * [the W3C proposal]{@link https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html}.\n   *\n   * @param runnable is the thunk to execute asynchronously\n   */\n  public abstract executeAsync(runnable: () => void): void\n\n  /**\n   * Execute the given `runnable` on the current call stack by means\n   * of a \"trampoline\", preserving stack safety.\n   *\n   * This is an alternative to {@link executeAsync} for triggering\n   * light asynchronous boundaries.\n   */\n  public abstract trampoline(runnable: () => void): void\n\n  /** Reports that an asynchronous computation failed. */\n  public abstract reportFailure(e: any): void\n\n  /**\n   * Returns the current time in milliseconds.  Note that while the\n   * unit of time of the return value is a millisecond, the\n   * granularity of the value depends on the underlying operating\n   * system and may be larger.  For example, many operating systems\n   * measure time in units of tens of milliseconds.\n   *\n   * It's the equivalent of `Date.now()`. When wanting to measure\n   * time, do not use `Date.now()` directly, prefer this method\n   * instead, because then it can be mocked for testing purposes,\n   * or overridden for better precision.\n   */\n  public abstract currentTimeMillis(): number\n\n  /**\n   * Schedules a task to run in the future, after `delay`.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output after 5 minutes:\n   *\n   * ```typescript\n   * const task =\n   *   scheduler.scheduleOnce(Duration.minutes(5), () => {\n   *     console.log(\"Hello, world!\")\n   *   })\n   *\n   * // later if you change your mind ... task.cancel()\n   * ```\n   *\n   * @param delay is the time to wait until the execution happens; if\n   *        specified as a `number`, then it's interpreted as milliseconds;\n   *        for readability, prefer passing [[Duration]] values\n   * @param runnable is the callback to be executed\n   *\n   * @return a [[Cancelable]] that can be used to cancel the created\n   *         task before execution.\n   */\n  public abstract scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable\n\n  /**\n   * Schedules for execution a periodic task that is first executed\n   * after the given initial delay and subsequently with the given\n   * delay between the termination of one execution and the\n   * commencement of the next.\n   *\n   * For example the following schedules a message to be printed to\n   * standard output every 10 seconds with an initial delay of 5\n   * seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleWithFixedDelay(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   * // later if you change your mind ...\n   * task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param delay is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleWithFixedDelay(initialDelay: number | Duration, delay: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNow: number | Duration) =>\n      ref.update(self.scheduleOnce(delayNow, () => {\n        runnable()\n        loop(self, ref, delay)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task, initialDelay)\n  }\n\n  /**\n   * Schedules a periodic task that becomes enabled first after the given\n   * initial delay, and subsequently with the given period. Executions will\n   * commence after `initialDelay` then `initialDelay + period`, then\n   * `initialDelay + 2 * period` and so on.\n   *\n   * If any execution of the task encounters an exception, subsequent executions\n   * are suppressed. Otherwise, the task will only terminate via cancellation or\n   * termination of the scheduler. If any execution of this task takes longer\n   * than its period, then subsequent executions may start late, but will not\n   * concurrently execute.\n   *\n   * For example the following schedules a message to be printed to standard\n   * output approximately every 10 seconds with an initial delay of 5 seconds:\n   *\n   * ```typescript\n   * const task =\n   *   s.scheduleAtFixedRate(Duration.seconds(5), Duration.seconds(10), () => {\n   *     console.log(\"repeated message\")\n   *   })\n   *\n   *   // later if you change your mind ...\n   *   task.cancel()\n   * ```\n   *\n   * @param initialDelay is the time to wait until the first execution happens\n   * @param period is the time to wait between 2 successive executions of the task\n   * @param runnable is the thunk to be executed\n   * @return a cancelable that can be used to cancel the execution of\n   *         this repeated task at any time.\n   */\n  public scheduleAtFixedRate(initialDelay: number | Duration, period: number | Duration, runnable: () => void): ICancelable {\n    const loop = (self: Scheduler, ref: IAssignCancelable, delayNowMs: number, periodMs: number) =>\n      ref.update(self.scheduleOnce(delayNowMs, () => {\n        // Benchmarking the duration of the runnable\n        const startAt = self.currentTimeMillis()\n        runnable()\n        // Calculating the next delay based on the current execution\n        const elapsedMs = self.currentTimeMillis() - startAt\n        const nextDelayMs = Math.max(0, periodMs - elapsedMs)\n        loop(self, ref, periodMs, nextDelayMs)\n      }))\n\n    const task = MultiAssignCancelable.empty()\n    return loop(this, task,\n      typeof initialDelay === \"number\" ? initialDelay : initialDelay.toMillis(),\n      typeof period === \"number\" ? period : period.toMillis()\n    )\n  }\n\n  /**\n   * Exposes a reusable [[GlobalScheduler]] reference by means of a\n   * {@link DynamicRef}, which allows for lexically scoped bindings to happen.\n   *\n   * ```typescript\n   * const myScheduler = new GlobalScheduler(false)\n   *\n   * Scheduler.global.bind(myScheduler, () => {\n   *   Scheduler.global.get() // myScheduler\n   * })\n   *\n   * Scheduler.global.get() // default instance\n   * ```\n   */\n  static readonly global: DynamicRef<Scheduler> =\n    DynamicRef.of(() => globalSchedulerRef)\n}\n\n/**\n * Internal trampoline implementation used for implementing\n * {@link Scheduler.trampoline}.\n *\n * @final\n * @hidden\n */\nclass Trampoline {\n  private readonly _parent: Scheduler\n  private readonly _queue: (() => void)[]\n  private _isActive: boolean\n\n  constructor(parent: Scheduler) {\n    this._isActive = false\n    this._queue = []\n    this._parent = parent\n  }\n\n  execute(r: () => void) {\n    if (!this._isActive) {\n      this.runLoop(r)\n    } else {\n      this._queue.push(r)\n    }\n  }\n\n  private runLoop(r: () => void) {\n    this._isActive = true\n    try {\n      let cursor: (() => void) | undefined = r\n      while (cursor) {\n        try { cursor() } catch (e) { this._parent.reportFailure(e) }\n        cursor = this._queue.pop()\n      }\n    } finally {\n      this._isActive = false\n    }\n  }\n}\n\n/**\n * `GlobalScheduler` is a [[Scheduler]] implementation based on Javascript's\n * [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout}\n * and (if available and configured)\n * [setImmediate]{@link https://developer.mozilla.org/en/docs/Web/API/Window/setImmediate}.\n */\nexport class GlobalScheduler extends Scheduler {\n  /**\n   * If `true`, then `setImmediate` is used in `execute`.\n   */\n  private _useSetImmediate: boolean\n\n  /**\n   * {@link Trampoline} used for immediate execution in\n   * {@link Scheduler.trampoline}.\n   */\n  private _trampoline: Trampoline\n\n  /**\n   * @param canUseSetImmediate is a boolean informing the\n   * `GlobalScheduler` implementation that it can use the nonstandard\n   * `setImmediate` for scheduling asynchronous tasks without extra\n   * delays.\n   */\n  constructor(canUseSetImmediate: boolean = false) {\n    super()\n    this._trampoline = new Trampoline(this)\n    // tslint:disable:strict-type-predicates\n    this._useSetImmediate = (canUseSetImmediate || false) && (typeof setImmediate === \"function\")\n  }\n\n  executeAsync(runnable: () => void): void {\n    const r = safeRunnable(runnable, this.reportFailure)\n    if (this._useSetImmediate) setImmediate(r)\n    else setTimeout(r)\n  }\n\n  trampoline(runnable: () => void): void {\n    this._trampoline.execute(runnable)\n  }\n\n  reportFailure(e: any): void {\n    console.error(e)\n  }\n\n  currentTimeMillis(): number {\n    return Date.now()\n  }\n\n  scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const r = safeRunnable(runnable, this.reportFailure)\n    const ms = Math.max(0, Duration.of(delay).toMillis())\n    const task = setTimeout(r, ms)\n    return Cancelable.of(() => clearTimeout(task))\n  }\n}\n\n/**\n * The `TestScheduler` is a {@link Scheduler} type meant for testing purposes,\n * being capable of simulating asynchronous execution and the passage of time.\n *\n * Example:\n *\n * ```typescript\n * const s = new TestScheduler()\n *\n * s.execute(() => { console.log(\"Hello, world!\") })\n *\n * // Triggers actual execution\n * s.tick()\n *\n * // Simulating delayed execution\n * const task = s.scheduleOnce(Duration.seconds(10), () => {\n *   console.log(\"Hello, delayed!\")\n * })\n *\n * // We can cancel a delayed task if we want\n * task.cancel()\n *\n * // Or we can execute it by moving the internal clock forward in time\n * s.tick(Duration.seconds(10))\n * ```\n */\nexport class TestScheduler extends Scheduler {\n  private _reporter: (error: any) => void\n  private _clock: number\n  private _triggeredFailures: Array<any>\n  private _tasks: Array<[number, () => void]>\n  private _tasksSearch: (search: number) => number\n  private _trampoline: Trampoline\n\n  constructor(reporter?: (error: any) => void) {\n    super()\n    this._reporter = reporter || (_ => {})\n    this._clock = 0\n    this._triggeredFailures = []\n    this._trampoline = new Trampoline(this)\n    this._updateTasks([])\n  }\n\n  /**\n   * Returns a list of triggered errors, if any happened during\n   * the {@link tick} execution.\n   */\n  public triggeredFailures(): Array<any> { return this._triggeredFailures }\n\n  /**\n   * Returns `true` if there are any tasks left to execute, `false`\n   * otherwise.\n   */\n  public hasTasksLeft(): boolean { return this._tasks.length > 0 }\n\n  public executeAsync(runnable: () => void): void {\n    this._tasks.push([this._clock, runnable])\n  }\n\n  public trampoline(runnable: () => void): void {\n    this._trampoline.execute(runnable)\n  }\n\n  public reportFailure(e: any): void {\n    this._triggeredFailures.push(e)\n    this._reporter(e)\n  }\n\n  public currentTimeMillis(): number {\n    return this._clock\n  }\n\n  public scheduleOnce(delay: number | Duration, runnable: () => void): ICancelable {\n    const d = Math.max(0, Duration.of(delay).toMillis())\n    const scheduleAt = this._clock + d\n    const insertAt = this._tasksSearch(-scheduleAt)\n    const ref: [number, () => void] = [scheduleAt, runnable]\n    this._tasks.splice(insertAt, 0, ref)\n\n    return Cancelable.of(() => {\n      const filtered: Array<[number, () => void]> = []\n      for (const e of this._tasks) {\n        if (e !== ref) filtered.push(e)\n      }\n      this._updateTasks(filtered)\n    })\n  }\n\n  /**\n   * Executes the current batch of tasks that are pending, relative\n   * to [currentTimeMillis]{@link TestScheduler.currentTimeMillis}.\n   *\n   * ```typescript\n   * const s = new TestScheduler()\n   *\n   * // Immediate execution\n   * s.execute(() => console.log(\"A\"))\n   * s.execute(() => console.log(\"B\"))\n   * // Delay with 1 second from now\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"C\"))\n   * s.scheduleOnce(Duration.seconds(1), () => console.log(\"D\"))\n   * // Delay with 2 seconds from now\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"E\"))\n   * s.scheduleOnce(Duration.seconds(2), () => console.log(\"F\"))\n   *\n   * // Actual execution...\n   *\n   * // Prints A, B\n   * s.tick()\n   * // Prints C, D\n   * s.tick(Duration.seconds(1))\n   * // Prints E, F\n   * s.tick(Duration.seconds(1))\n   * ```\n   *\n   * @param duration is an optional timespan to user for incrementing\n   * [currentTimeMillis]{@link TestScheduler.currentTimeMillis}, thus allowing\n   * the execution of tasks scheduled to execute with a delay.\n   *\n   * @return the number of executed tasks\n   */\n  public tick(duration?: number | Duration): number {\n    let toExecute = []\n    let jumpMs = Duration.of(duration || 0).toMillis()\n    let executed = 0\n\n    while (true) {\n      const peek = this._tasks.length > 0\n        ? this._tasks[this._tasks.length - 1]\n        : undefined\n\n      if (peek && peek[0] <= this._clock) {\n        toExecute.push(this._tasks.pop())\n      } else if (toExecute.length > 0) {\n        // Executing current batch, randomized\n        while (toExecute.length > 0) {\n          const index = Math.floor(Math.random() * toExecute.length)\n          const elem = toExecute[index] as any\n          try {\n            toExecute.splice(index, 1)\n            elem[1]()\n          } catch (e) {\n            this.reportFailure(e)\n          } finally {\n            executed += 1\n          }\n        }\n      } else if (jumpMs > 0) {\n        const nextTaskJump = peek && (peek[0] - this._clock) || jumpMs\n        const add = Math.min(nextTaskJump, jumpMs)\n        this._clock += add\n        jumpMs -= add\n      } else {\n        break\n      }\n    }\n    return executed\n  }\n\n  private _updateTasks(tasks: Array<[number, () => void]>) {\n    this._tasks = tasks\n    this._tasksSearch = arrayBSearchInsertPos(this._tasks, e => -e[0])\n  }\n}\n\n/**\n * Internal, reusable [[GlobalScheduler]] reference.\n *\n * @Hidden\n */\nconst globalSchedulerRef = new GlobalScheduler(true)\n\n/**\n * Internal utility wrapper a runner in an implementation that\n * reports errors with the provided `reporter` callback.\n *\n * @Hidden\n */\nfunction safeRunnable(r: () => void, reporter: (error: any) => void): () => void {\n  return () => { try { r() } catch (e) { reporter(e) } }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes {@link Future}, a lawful promise implementation.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Future } from \"funfix/dist/exec/future\"\n * // ... or ...\n * import { Future } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module exec/future\n */\n\n/***/\nimport { Try, Success, Failure, Option, Some, None, Either, Left, Right } from \"../core/disjunctions\"\nimport { IllegalStateError, IllegalArgumentError, TimeoutError } from \"../core/errors\"\nimport { Scheduler } from \"./scheduler\"\nimport { Duration } from \"./time\"\nimport { ICancelable, Cancelable, MultiAssignCancelable } from \"./cancelable\"\nimport { iterableToArray } from \"./internals\"\n\n/**\n * `IPromiseLike` represents objects that have a `then` method complying with\n * the [Promises/A+](https://promisesaplus.com/) specification.\n */\nexport interface IPromiseLike<T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the promise.\n   *\n   * See [MDN: Promise.then]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then}.\n   *\n   * @param onFulfilled The callback to execute when the promise is resolved.\n   * @param onRejected The callback to execute when the promise is rejected.\n   *\n   * @returns A promise for the completion of which ever callback is executed.\n   */\n  then(onFulfilled?: (value: T) => any, onRejected?: (reason: any) => any): IPromiseLike<any>\n}\n\n/**\n * A `Future` represents a value which may or may not *currently* be available, but will be\n * available at some point, or an exception if the operation producing the result fails.\n *\n * `Future<A>` is a Promise-like alternative data type, that's cancelable and lawful,\n * inspired by Scala's `Future[A]`.\n *\n * You can easily build futures out of functions, that will execute asynchronously\n * (e.g. not on the current call stack) by means of `Future.of`:\n *\n * ```typescript\n * Future.of(() => 1 + 1)\n * ```\n *\n * Such computations use the [[Scheduler.global]] reference for execution, which\n * can be overridden, many times in the function call, being an optional parameter\n * (e.g. in `Future.of`), or in the local context, because it is exposed as a\n * [[DynamicRef]], which allows for localised overrides:\n *\n * ```typescript\n * import { Scheduler, GlobalScheduler, Future } from \"funfix\"\n *\n * // Custom Scheduler reference that we want to use\n * const ec = new GlobalScheduler(false)\n *\n * Future.of(() => x + y, ec)\n *\n * // ... is equivalent with ...\n *\n * Scheduler.global.bind(ec, () => {\n *   Future.of(() => x + y)\n * })\n * ```\n *\n * To create a `Future` out of an actual asynchronous computation, you can\n * use `Future.create`. Here's an example that takes a function and executes\n * it with an initial delay, returning a cancelable `Future`:\n *\n * ```typescript\n * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n *\n * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n *   Future.create<A>(\n *     cb => {\n *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n *\n *       return Cancelable.of(() => {\n *         console.warn(\"Delayed task was cancelled\")\n *         task.cancel()\n *       })\n *     },\n *     ec\n *   )\n * ```\n *\n * Normally you can `await` on functions returning `Future<A>` values:\n *\n * ```typescript\n * async function asyncSample(n: number): Promise<number> {\n *   let sum = 0\n *   for (let i = 0; i < n; i++) {\n *     sum += await Future.of(() => i)\n *   }\n *   return sum\n * }\n * ```\n *\n * Such functions do need to return a `Promise`, because JavaScript\n * generates code that uses `Promise`'s constructor. But a `Future`\n * is \"thenable\", so you can await on functions returning `Future`\n * just fine.\n */\nexport abstract class Future<A> implements IPromiseLike<A>, ICancelable {\n  /**\n   * Reference to the current {@link Scheduler} available for subsequent\n   * data transformations. Can be set in `Future`'s constructors, or by\n   * transforming the source by {@link withScheduler}.\n   *\n   * Protected, because it shouldn't be public API, being meant for\n   * `Future` implementations.\n   *\n   * @protected\n   */\n  protected readonly _scheduler: Scheduler\n\n  /**\n   * Extracts the completed value for this `Future`, returning `Some(result)`\n   * if this `Future` is already complete or `None` in case the `Future` wasn't\n   * completed yet.\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   *\n   * // Given the async execution of `Future.of`, the immediate invocations of\n   * // `value()` will yield `None`, but after complete it will yield\n   * // `Some(Success(1))`\n   * f1.value()\n   *\n   * const f2 = Future.raise(new DummyError())\n   *\n   * // Immediately yields Some(Failure(DummyError))\n   * f2.value()\n   * ```\n   */\n  abstract value(): Option<Try<A>>\n\n  /**\n   * Given a callback, calls it with this `Future`'s result when that result\n   * is ready.\n   *\n   * The execution of this callback is always trampolined (for already completed\n   * futures), or asynchronous, which means that modeling loops based on it is\n   * memory safe.\n   *\n   * ```typescript\n   * Future.of(() => \"John\").complete(r => {\n   *   r.fold(\n   *    error => console.info(\"Error: \" + error),\n   *    success => console.info(\"Hello, \" + John)\n   *   )\n   * })\n   * ```\n   */\n  abstract onComplete(f: (a: Try<A>) => void): void\n\n  /**\n   * In case this `Future` isn't complete, then send it a cancel signal.\n   *\n   * Depending on the computation that will complete this future, its execution\n   * might be interrupted.\n   *\n   * Execution has the same properties of {@link ICancelable}, being idempotent\n   * (calling it multiple times has the same effect as calling it once).\n   *\n   * In order to create a cancelable `Future`, use {@link Future.create}.\n   */\n  abstract cancel(): void\n\n  /**\n   * Sets the {@link Scheduler} reference that's going to get used for\n   * subsequent data transformations.\n   *\n   * `Future` references have a {@link Scheduler} reference attached at build\n   * time, that's going to get used for data transformations. This method\n   * returns a new `Future` reference that's going to mirror the source,\n   * but that's going to use the given `Scheduler` for subsequent operations\n   * like `map`, `flatMap`, `transformWith`, etc.\n   *\n   * ```typescript\n   * const ec1 = new GlobalScheduler(true)\n   *\n   * // The default Scheduler is global (that second parameter is optiona)\n   * const f1 = Future.create(f, ec1)\n   *\n   * // The `f1` future is going to get executed by `ec1`, however\n   * // this subsequent `flatMap` is getting evaluated by `ec2`\n   * const ec2 = new GlobalScheduler(false)\n   * const f2 = f1.withScheduler(ec2).flatMap(x => Future.pure(x * 2))\n   * ```\n   *\n   * When no `Scheduler` is specified, the default is assumed to be\n   * {@link Scheduler.global}.\n   *\n   * @param ec is the scheduler that's going to get used asynchronous execution\n   *        of subsequent operations\n   */\n  abstract withScheduler(ec: Scheduler): Future<A>\n\n  /**\n   * Transforms the source, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link flatMap} and {@link recoverWith},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * NOTE: in Funfix these fold-like methods, by convention, take as the\n   * first parameter the function that transforms the failure (the left),\n   * whereas the second parameter is the function that transforms the\n   * successful result (the right). Think of `Either<Error, A>`.\n   *\n   * ```typescript\n   * const randomInt = (max: number) =>\n   *   Future.of(() => {\n   *     const n = Math.random() * max\n   *     n & n\n   *   })\n   *\n   * const randomEvenInt = (max: number) =>\n   *   randomInt(max).transformWith(\n   *     err => Future.pure(9),\n   *     value => (\n   *       // retry until we have an even value\n   *       value % 2 == 0 ? Future.pure(value) : randomEvenInt()\n   *     )\n   *   )\n   * ```\n   *\n   * Also see {@link transform}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  abstract transformWith<B>(failure: (e: any) => Future<B>, success: (a: A) => Future<B>): Future<B>\n\n  /**\n   * Transforms the sources, regardless if the result is a failure or a success.\n   *\n   * This function is a combination of {@link map} and {@link recover},\n   * being the (type safe) alternative to JavaScript's\n   * [then]{@link IPromiseLike.then} from the\n   * [Promises/A+](https://promisesaplus.com/) specification.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Left, Right } from \"funfix\"\n   *\n   * // Expose errors by lifting them to an Either<Error, A>\n   * future.transform<Either<any, A>>(Left, Right)\n   * ```\n   *\n   * Also see {@link transformWith}.\n   *\n   * @param failure is the function that's going to get executed in case the\n   *        source signals a failure\n   *\n   * @param success is the function that's going to get executed in case the\n   *        source signals a successful result\n   */\n  transform<B>(failure: (e: any) => B, success: (a: A) => B): Future<B> {\n    return this.transformWith(\n      e => Future.pure(failure(e)),\n      a => Future.pure(success(a)))\n  }\n\n  /**\n   * Exposes underlying errors by lifting both successful and failed\n   * results into an {@link Either} value.\n   *\n   * Given that errors are short-circuiting the processing of {@link flatMap}\n   * chains, this method is useful for exposing errors such that you can\n   * `flatMap` over them.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(new DummyError)\n   *\n   * // Yields a successful Left(DummyError) on completion\n   * const fe: Future<Either<any, number>> = f.attempt()\n   *\n   * // Yields a Right(1) on completion\n   * const fr: Future<Either<any, number>> = Future.pure(1).attempt()\n   * ```\n   */\n  attempt(): Future<Either<any, A>> {\n    return this.transform<Either<any, A>>(Left, Right)\n  }\n\n  /**\n   * Chains asynchronous operations.\n   *\n   * Creates a new future by applying a function to the successful result of\n   * the source and returns the result of the function as the new future.\n   * If this future is completed with an exception then the new future will\n   * also contain this exception.\n   *\n   * This operation is the [monadic bind]{@link Monad.flatMap}.\n   *\n   * ```typescript\n   * const fa = Future.of(() => 3)\n   * const fb = Future.of(() => 5)\n   *\n   * // Yields 3 + 5\n   * fa.flatMap(a => fb.map(b => a + b))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Future<B>): Future<B> {\n    return this.transformWith(Future.raise, f)\n  }\n\n  /**\n   * Given a mapping function, transforms the successful result of the source.\n   *\n   * If the source is completed with an exception, then the new future will\n   * also be completed in an error.\n   *\n   * This operation is the [functor map]{@link Functor.map}.\n   *\n   * ```typescript\n   * const f = Future.of(() => \"The future\")\n   *\n   * const g = f.map(x => x + \" is now!\")\n   * ```\n   */\n  map<B>(f: (a: A) => B): Future<B> {\n    return this.transformWith(Future.raise, a => Future.pure(f(a)))\n  }\n\n  /**\n   * Creates a new future that will handle any matching throwable that this\n   * future might contain by assigning it a value of another future.\n   *\n   * If there is no match, or if this future contains a valid result then the\n   * new future will contain the same result.\n   *\n   * This operation is the equivalent of {@link flatMap} for handling errors.\n   * Also see {@link transformWith}, which can handle both successful results\n   * and failures.\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recoverWith(e => e instanceof DummyError\n   *   ? Future.pure(10) // Fallback\n   *   : Future.raise(e) // Re-throw\n   * )\n   * ```\n   */\n  recoverWith<AA>(f: (e: any) => Future<AA>): Future<A | AA> {\n    return this.transformWith<A | AA>(f, Future.pure)\n  }\n\n  /**\n   *\n   *\n   * ```typescript\n   * const f = Future.of<number>(() => { throw new DummyError() })\n   *\n   * f.recover(e => {\n   *   if (e instanceof DummyError) return 10\n   *   // Don't re-throw exceptions like this, use `recoverWith` instead!\n   *   throw e\n   * })\n   * ```\n   */\n  recover<AA>(f: (e: any) => AA): Future<A | AA> {\n    return this.transformWith<A | AA>(a => Future.pure(f(a)), Future.pure)\n  }\n\n  then<TResult1, TResult2>(\n    onFulfilled?: ((value: A) => (IPromiseLike<TResult1> | TResult1)) | undefined | null,\n    onRejected?: ((reason: any) => (IPromiseLike<TResult2> | TResult2)) | undefined | null): Future<TResult2 | TResult1> {\n\n    if (!onFulfilled && !onRejected) return this as any\n    return this.transformWith(\n      promiseThen(onRejected, Future.raise),\n      promiseThen(onFulfilled, Future.pure))\n  }\n\n  /**\n   * Transforms this `Future<A>` reference into a standard JavaScript `Promise<A>`\n   * reference.\n   *\n   * Normally a `Future` is \"thenable\", so JavaScript should have no problem\n   * working with it, however in certain contexts this conversion is useful for\n   * working with type definitions that don't recognize the structural typing\n   * defined by the Promises/A+ specification.\n   */\n  toPromise(): Promise<A> {\n    return new Promise<A>((resolve, reject) => {\n      this.onComplete(_ => _.fold(reject, resolve))\n    })\n  }\n\n  /**\n   * Delays signaling the result of this `Future` by the specified duration.\n   *\n   * It works for successful results:\n   *\n   * ```typescript\n   * const fa = Future.of(() => \"Alex\")\n   *\n   * // Delays the signaling by 1 second\n   * fa.delayResult(1000).flatMap\n   * ```\n   *\n   * And for failures as well:\n   *\n   * ```typescript\n   * Future.raise(new TimeoutError()).delayResult(1000)\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the final result\n   */\n  delayResult(delay: number | Duration): Future<A> {\n    return this.transformWith(\n      err => Future.delayedTick(delay, this._scheduler).flatMap(_ => Future.raise(err, this._scheduler)),\n      a => Future.delayedTick(delay, this._scheduler).map(_ => a)\n    )\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * fails with a {@link TimeoutError}, cancelling the source.\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * // Will fail with a TimeoutError\n   * fa.timeout(1000)\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the timeout error\n   */\n  timeout(after: number | Duration): Future<A> {\n    // Creating the exception immediately, to get a good stack trace\n    const fb = Future.raise(new TimeoutError(Duration.of(after).toString()), this._scheduler)\n    return this.timeoutTo(after, () => fb)\n  }\n\n  /**\n   * Returns a future that mirrors the source in case the result of the source\n   * is signaled within the required `after` duration, otherwise it\n   * triggers the execution of the given `fallback` after the duration has\n   * passed, cancelling the source.\n   *\n   * This is literally the implementation of {@link Future.timeout}:\n   *\n   * ```typescript\n   * const fa = Future.of(() => 1).delayResult(10000)\n   *\n   * fa.timeoutTo(1000, () => Future.raise(new TimeoutError()))\n   * ```\n   *\n   * @param after is the duration to wait until it triggers the `fallback`\n   * @param fallback is a thunk generating a fallback `Future` to timeout to\n   */\n  timeoutTo<AA>(after: number | Duration, fallback: () => Future<AA>): Future<A | AA> {\n    const other = Future.delayedTick(after, this._scheduler).flatMap(_ => fallback())\n    const lst: Future<A | AA>[] = [this, other]\n    return Future.firstCompletedOf(lst, this._scheduler)\n  }\n\n  // Implements HK<F, A>\n  readonly _funKindF: Future<any>\n  readonly _funKindA: A\n\n  // Implements Constructor<T>\n  static readonly _funErasure: Future<any>\n\n  /**\n   * Given a function that executes immediately, executes it asynchronously\n   * and returns a `Future` that will complete when the result is ready.\n   *\n   * ```typescript\n   * const sum = (x: number, y: number) =>\n   *   Future.of(() => x + y)\n   * ```\n   *\n   * @param thunk is the function to execute asynchronously\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static of<A>(thunk: () => A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new FutureBuilder(\n      cb => ec.executeAsync(() => cb(Try.of(() => thunk()))),\n      ec)\n  }\n\n  /**\n   * Lifts a pure value into the `Future` context, returning a `Future`\n   * reference that's already complete with the given value.\n   *\n   * This is the equivalent of `Promise.resolve(a)`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.pure(10)\n   *\n   * // Prints Success(10)\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param a is the value to lift in the `Future` context and that will\n   *        get signaled in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static pure<A>(a: A, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new PureFuture(Success(a), ec)\n  }\n\n  /**\n   * Lifts an error in the `Future` context, returning a `Future` reference\n   * that's already failed with the given error.\n   *\n   * This is the equivalent of `Promise.reject`.\n   *\n   * ```typescript\n   * const f: Future<number> = Future.raise(\"Oops!\")\n   *\n   * // Prints Failure(\"Oops!\")\n   * f.onComplete(r => console.info(r))\n   * ```\n   *\n   * @param e is the error to lift in the `Future` context and that will\n   *        get signaled as a failure in `onComplete` callbacks\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static raise(e: any, ec: Scheduler = Scheduler.global.get()): Future<never> {\n    return new PureFuture(Failure(e), ec)\n  }\n\n  /**\n   * Given a side-effectful function that triggers an asynchronous computation,\n   * execute it and return a `Future` reference.\n   *\n   * The given `register` function will be invoked immediately to \"schedule\"\n   * the asynchronous callback, where the callback is the parameter injected in\n   * that function.\n   *\n   * The `register` function can optionally return a {@link ICancelable}\n   * reference that can get used to cancel the running asynchronous\n   * computation.\n   *\n   * Example:\n   *\n   * ```typescript\n   * import { Scheduler, Future, Try, Duration, Cancelable } from \"funfix\"\n   *\n   * const delay = <A>(d: Duration, f: () => A, ec: Scheduler = Scheduler.global.get()) =>\n   *   Future.create<A>(\n   *     cb => {\n   *       const task = ec.scheduleOnce(d, () => cb(Try.of(f)))\n   *\n   *       return Cancelable.of(() => {\n   *         console.warn(\"Delayed task was cancelled\")\n   *         task.cancel()\n   *       })\n   *     },\n   *     ec\n   *   )\n   * ```\n   *\n   * Note that by not returning a cancelable, the returned `Future` reference\n   * will NOT BE cancelable.\n   *\n   * ```typescript\n   * // This future is not cancelable, because we are not\n   * // returning a cancelable reference\n   * Future.create<number>(cb => {\n   *   setTimeout(1000, () => cb(Success(10)))\n   * })\n   * ```\n   *\n   * @param register is the side-effectful function that will get invoked\n   *        to build our `Future`, receiving a callback that's supposed to\n   *        get invoked (only once) when the asynchronous computation completes,\n   *        and that can optionally return a cancelable reference that can\n   *        get used to cancel the running computation\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static create<A>(register: (cb: (a: Try<A>) => void) => (ICancelable | void), ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return new FutureBuilder(register, ec)\n  }\n\n  /**\n   * Returns a `Future` reference that's already completed with a `void` value.\n   *\n   * Alias for:\n   *\n   * ```typescript\n   * Future.pure(undefined)\n   * ```\n   *\n   * Note that the same reference is always returned, so this property holds:\n   *\n   * ```typescript\n   * Future.unit() === Future.unit()\n   * ```\n   */\n  static unit(): Future<void> {\n    return futureUnit\n  }\n\n  /**\n   * Returns a `Future` that will complete after the given `delay`.\n   *\n   * This can be used to do delayed execution. For example:\n   *\n   * ```typescript\n   * Future.delayedTick(1000).flatMap(_ =>\n   *   Future.of(() => console.info(\"Hello!\"))\n   * )\n   * ```\n   *\n   * @param delay is the duration to wait before signaling the tick\n   * @param ec is the scheduler that will actually schedule the tick's execution\n   */\n  static delayedTick<A>(delay: number | Duration, ec: Scheduler = Scheduler.global.get()): Future<void> {\n    return Future.create(cb => ec.scheduleOnce(delay, () => cb(Success(undefined))), ec)\n  }\n\n  /**\n   * Keeps calling `f` until it returns a `Right` value.\n   *\n   * Based on Phil Freeman's\n   * [[http://functorial.com/stack-safety-for-free/index.pdf Stack Safety for Free]].\n   *\n   * ```typescript\n   * const generate = () => {\n   *   const n = Math.random() * 1000\n   *   return n & n\n   * }\n   *\n   * // Keeps looping until an odd number is returned\n   * Future.tailRecM(0, a => Future.of(() => {\n   *   return a % 2 == 0 ? Left(generate()) : Right(a)\n   * })\n   * ```\n   *\n   * @param a is the initial seed\n   * @param f is the function that keeps being invoked with the previous\n   *          `Left(a)` value, until a `Right(b)` value is returned,\n   *          which will be the `onComplete` result of the `Future`\n   *          reference\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Future<Either<A, B>>): Future<B> {\n    // Recursive loop based on flatMap\n    return f(a).flatMap(r => {\n      if (r.isRight()) return Future.pure(r.get())\n      return Future.tailRecM(r.swap().get(), f)\n    })\n  }\n\n  /**\n   * Transforms any `Promise`-like data type into a `Future`.\n   *\n   * ```typescript\n   * const p: Promise<number> = Promise.resolve(10)\n   *\n   * const f: Future<number> = Future.fromPromise(p)\n   * ```\n   *\n   * @param ref is the promise reference that we want to convert into a `Future`\n   *\n   * @param ec is an optional {@link Scheduler} reference that will get used\n   *        for scheduling the actual async execution; if one isn't provided\n   *        then {@link Scheduler.global} gets used, which also allows for\n   *        local overrides, being a {@link DynamicRef}\n   */\n  static fromPromise<A>(ref: IPromiseLike<A>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    if (ref instanceof Future)\n      return (ref as Future<A>).withScheduler(ec)\n    else\n      return Future.create(\n        cb => { ref.then(value => cb(Success(value)),err => cb(Failure(err))) },\n        ec\n      )\n  }\n\n  /**\n   * Creates a race condition between multiple futures, returning the result\n   * of the first one that completes, cancelling the rest.\n   *\n   * ```typescript\n   * const failure = Future.raise(new TimeoutError()).delayResult(2000)\n   *\n   * // Will yield 1\n   * const fa1 = Future.of(() => 1).delayResult(1000)\n   * Future.firstCompletedOf([fa1, failure])\n   *\n   * // Will yield a TimeoutError\n   * const fa2 = Future.of(() => 1).delayResult(10000)\n   * Future.firstCompletedOf([fa2, failure])\n   * ```\n   *\n   * @param list is the list of futures for which the race is started\n   * @param ec is the scheduler doing the needed scheduling and error reporting\n   *\n   * @return a future that will complete with the result of the first\n   *         future form the list to complete, the rest being cancelled\n   */\n  static firstCompletedOf<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A> {\n    return futureFirstCompletedOf(list, ec)\n  }\n\n  /**\n   * Given a list of items, builds future results out of it with the specified\n   * mapping function and returns a new future that's going to be completed\n   * with the list of all generated results.\n   *\n   * This is the generic version of {@link Future.sequence}. Useful for\n   * processing futures in parallel, with the `parallelism` factor being\n   * configurable.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const list = [1, 2, 3, 4]\n   *\n   * // Yields [2, 4, 6, 8]\n   * Future.traverse(list)(a => Future.pure(a * 2))\n   * // ... is equivalent to:\n   * Future.sequence(list.map(_ => _ * 2))\n   * ```\n   *\n   * Note that the given `list` is strictly processed, so no lazy behavior\n   * should be expected if an `Iterable` is given.\n   *\n   * But in comparison with {@link Future.sequence}, this builder has lazy\n   * behavior in applying the given mapping function. Coupled with the\n   * `parallelism` factor, this can be used to do batched processing:\n   *\n   * ```typescript\n   * const userIDs = [1, 2, 3, 4]\n   *\n   * // Make at most 2 requests in parallel:\n   * Future.traverse(userIDs, 2)(fetchUserDetails)\n   * ```\n   *\n   * @param list are the values that get fed in the generator function for\n   *        building a list of future results\n   *\n   * @param parallelism is the maximum number of futures that are going to\n   *        be processed in parallel, defaults to `Infinity`\n   *\n   * @param ec is an optional scheduler that's going to be used for scheduling\n   *        the needed asynchronous boundaries\n   *\n   * @return a function that takes as parameter a the generator function that's\n   *         going to map the given `list`, transforming it into a list of\n   *         futures, finally returning a future that's going to complete\n   *         with the list of all asynchronously generated results\n   */\n  static traverse<A>(list: A[] | Iterable<A>, parallelism: number = Infinity, ec: Scheduler = Scheduler.global.get()):\n    <B>(f: (a: A) => Future<B>) => Future<B[]> {\n\n    return f => futureTraverse(list, f, parallelism, ec)\n  }\n\n  /**\n   * Asynchronously transforms a list of futures into a future of a list.\n   *\n   * The equivalent of `Promise.all`, this is the specialized version of\n   * {@link Future.traverse}.\n   *\n   * Contract:\n   *\n   * - the given `Iterable<Future<A>>` list is eagerly evaluated, transformed\n   *   from the start into an `Array<Future<A>>`, so don't expect laziness in\n   *   evaluating it\n   * - In case one of the future fails, then all other futures that are still\n   *   pending get cancelled\n   * - In case the returned future gets cancelled, then all in-progress futures\n   *   from that list get cancelled\n   *\n   * Sample:\n   *\n   * ```typescript\n   * const f1 = Future.of(() => 1)\n   * const f2 = Future.of(() => 2)\n   * const f3 = Future.of(() => 3)\n   *\n   * // Yields [1, 2, 3]\n   * const all: Future<number[]> = Future.sequence([f1, f2, f3])\n   * ```\n   */\n  static sequence<A>(list: Future<A>[] | Iterable<Future<A>>, ec: Scheduler = Scheduler.global.get()): Future<A[]> {\n    return futureSequence(list, ec)\n  }\n\n  /**\n   * Maps 2 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   *\n   *\n   * // Yields Success(3)\n   * Future.map2(fa1, fa2, (a, b) => a + b)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map2(fa1, Future.raise(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, R>(\n    fa1: Future<A1>, fa2: Future<A2>, f: (a1: A1, a2: A2) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1]))\n  }\n\n  /**\n   * Maps 3 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   *\n   *\n   * // Yields Success(6)\n   * Future.map3(fa1, fa2, fa3, (a, b, c) => a + b + c)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map3(\n   *   fa1, fa2, Future.raise(\"error\"),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map3`.\n   */\n  static map3<A1, A2, A3, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2]))\n  }\n\n  /**\n   * Maps 4 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   *\n   * // Yields Success(10)\n   * Future.map4(fa1, fa2, fa3, fa4, (a, b, c, d) => a + b + c + d)\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map4(\n   *   fa1, fa2, fa3, Future.raise(\"error\"),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map4`.\n   */\n  static map4<A1, A2, A3, A4, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3]))\n  }\n\n  /**\n   * Maps 5 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   *\n   * // Yields Success(15)\n   * Future.map5(fa1, fa2, fa3, fa4, fa5,\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map5(\n   *   fa1, fa2, fa3, fa4, Future.raise(\"error\"),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map5`.\n   */\n  static map5<A1, A2, A3, A4, A5, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4]))\n  }\n\n  /**\n   * Maps 6 `Future` values by the mapping function, returning a new\n   * `Future` reference that completes with the result of mapping that\n   * function to the successful values of the futures, or in failure in\n   * case either of them fails.\n   *\n   * This is a specialized {@link Future.sequence} operation and as such\n   * on cancellation or failure all future values get cancelled.\n   *\n   * ```typescript\n   * const fa1 = Future.of(() => 1)\n   * const fa2 = Future.of(() => 2)\n   * const fa3 = Future.of(() => 3)\n   * const fa4 = Future.of(() => 4)\n   * const fa5 = Future.of(() => 5)\n   * const fa6 = Future.of(() => 6)\n   *\n   * // Yields Success(21)\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, fa6,\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Future.map6(\n   *   fa1, fa2, fa3, fa4, fa5, Future.raise(\"error\"),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map6`.\n   */\n  static map6<A1, A2, A3, A4, A5, A6, R>(\n    fa1: Future<A1>, fa2: Future<A2>, fa3: Future<A3>, fa4: Future<A4>, fa5: Future<A5>, fa6: Future<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R,\n    ec: Scheduler = Scheduler.global.get()): Future<R> {\n\n    const fl: Future<any[]> = Future.sequence([fa1, fa2, fa3, fa4, fa5, fa6] as any[], ec)\n    return fl.map(lst => f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]))\n  }\n}\n\nclass PureFuture<A> extends Future<A> {\n  constructor(private readonly _value: Try<A>, protected readonly _scheduler: Scheduler) { super() }\n\n  cancel(): void {}\n  value(): Option<Try<A>> { return Some(this._value) }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new PureFuture(this._value, ec)\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    this._scheduler.trampoline(() => f(this._value))\n  }\n\n  transformWith<B>(failure: (e: any) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler)\n  }\n\n  toPromise(): Promise<A> {\n    return this._value.fold(e => Promise.reject(e), a => Promise.resolve(a))\n  }\n}\n\nclass FutureBuilder<A> extends Future<A> {\n  private _result: Option<Try<A>>\n  private _listeners: ((a: Try<A>) => void)[]\n  private _cancelable: ICancelable\n  protected readonly _scheduler: Scheduler\n\n  constructor(register: (cb: (a: Try<A>) => void) => (ICancelable | void), ec: Scheduler) {\n    super()\n    this._result = None\n    this._listeners = []\n    this._scheduler = ec\n\n    const complete = (result: Try<A>) => {\n      if (this._result !== None) {\n        throw new IllegalStateError(\"Attempt to completing a Future multiple times\")\n      } else {\n        this._result = Some(result)\n        const listeners = this._listeners\n        delete this._listeners\n        delete this._cancelable\n\n        for (const f of listeners) {\n          // Forced async boundary\n          ec.trampoline(() => f(result))\n        }\n      }\n    }\n\n    const cb = register(complete)\n    if (this._result === None && cb) this._cancelable = cb\n  }\n\n  onComplete(f: (a: Try<A>) => void): void {\n    if (this._result !== None) {\n      // Forced async boundary\n      this._scheduler.trampoline(() => f(this._result.get()))\n    } else {\n      this._listeners.push(f)\n    }\n  }\n\n  value(): Option<Try<A>> {\n    return this._result\n  }\n\n  cancel(): void {\n    const cb = this._cancelable\n    if (cb) {\n      cb.cancel()\n      delete this._cancelable\n    }\n  }\n\n  withScheduler(ec: Scheduler): Future<A> {\n    if (this._scheduler === ec) return this\n    return new FutureBuilder(\n      cb => {\n        this.onComplete(cb)\n        return this._cancelable\n      },\n      ec)\n  }\n\n  transformWith<B>(failure: (e: any) => Future<B>, success: (a: A) => Future<B>): Future<B> {\n    return genericTransformWith(this, failure, success, this._scheduler, this._cancelable)\n  }\n}\n\n/**\n * Internal, reusable `transformWith` implementation for {@link PureFuture}\n * and {@link FutureBuilder}.\n *\n * @Hidden\n */\nfunction genericTransformWith<A, B>(\n  self: Future<A>,\n  failure: (e: any) => Future<B>,\n  success: (a: A) => Future<B>,\n  scheduler: Scheduler,\n  cancelable?: ICancelable): Future<B> {\n\n  return new FutureBuilder(\n    cb => {\n      const cRef = new MultiAssignCancelable(cancelable)\n\n      self.onComplete(tryA => {\n        let fb: Future<B>\n        try {\n          fb = tryA.fold(failure, success)\n        } catch (e) {\n          fb = Future.raise(e)\n        }\n\n        // If the resulting Future is already completed, there's no point\n        // in treating it as being cancelable\n        if (fb.value().isEmpty()) {\n          const fbb = fb as any\n          if (fbb._cancelable && fbb._cancelable instanceof MultiAssignCancelable) {\n            // Trick we are doing to get rid of extraneous memory\n            // allocations, otherwise we can leak memory\n            cRef.update(fbb._cancelable).collapse()\n            fbb._cancelable = cRef\n          } else {\n            /* istanbul ignore next */\n            cRef.update((fb as any)._cancelable || fb)\n          }\n        } else {\n          // GC purposes\n          cRef.clear()\n        }\n\n        fb.onComplete(cb)\n      })\n\n      return cRef\n    },\n    scheduler)\n}\n\n/**\n * Reusable instance for `Future<void>`.\n *\n * @hidden\n */\nconst futureUnit: Future<void> =\n  new PureFuture(Success(undefined), Scheduler.global.get())\n\n/**\n * Internal, reusable function used in the implementation of {@link Future.then}.\n *\n * @Hidden\n */\nfunction promiseThen<T, R>(f: ((t: T) => IPromiseLike<R> | R) | undefined | null, alt: (t: T) => Future<T>):\n  ((value: T) => Future<R | T>) {\n\n  return value => {\n    if (typeof f !== \"function\") return alt(value)\n\n    const fb = f(value)\n    if (!fb) return Future.pure(value)\n\n    if (typeof (fb as any).then === \"function\")\n      return Future.fromPromise(fb as IPromiseLike<R>)\n    else\n      return Future.pure(fb as R)\n  }\n}\n\n/** @Hidden */\nfunction futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -1): void {\n  const errors = []\n  for (let i = 0; i < list.length; i++) {\n    if (i !== skip)\n      try { list[i].cancel() } catch (e) { errors.push(e) }\n  }\n\n  if (errors.length > 0) {\n    for (const e of errors) ec.reportFailure(e)\n  }\n}\n\n/** @Hidden */\nfunction futureIterableToArray<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A>[] {\n  if (!values) return []\n  if (Object.prototype.toString.call(values) === \"[object Array]\")\n    return values as Future<A>[]\n\n  const arr: Future<A>[] = []\n  try {\n    const cursor = values[Symbol.iterator]()\n\n    while (true) {\n      const item = cursor.next()\n      if (item.value) arr.push(item.value)\n      if (item.done) break\n    }\n\n    return arr\n  } catch (e) {\n    futureCancelAll(arr, ec)\n    throw e\n  }\n}\n\n/**\n * Internal implementation for `Future.sequence`.\n *\n * @Hidden\n */\nfunction futureSequence<A>(values: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A[]> {\n  return Future.create(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(values, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Success([]))\n      const cRef = Cancelable.of(() => futureCancelAll(futures, ec))\n\n      // Creating race condition\n      let isDone = false\n      let finishedCount = 0\n      let finalArray: A[] = []\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          finishedCount += 1\n\n          if (result.isSuccess()) {\n            if (!isDone) {\n              finalArray[fi] = result.get()\n              isDone = finishedCount === futures.length\n              if (isDone) cb(Success(finalArray))\n            }\n          } else {\n            if (!isDone) {\n              isDone = true\n              cRef.cancel()\n              cb(result as any)\n            } else {\n              ec.reportFailure(result.failed().get())\n            }\n          }\n        })\n      }\n\n      return cRef\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.firstCompletedOf`.\n *\n * @Hidden\n */\nfunction futureFirstCompletedOf<A>(iterable: Future<A>[] | Iterable<Future<A>>, ec: Scheduler): Future<A> {\n  return Future.create(cb => {\n    try {\n      // This can throw, handling error below\n      const futures = futureIterableToArray(iterable, ec)\n      // Short-circuit in case the list is empty, otherwise the\n      // futureSequenceLoop fails (must be non-empty as an invariant)\n      if (futures.length === 0) return cb(Failure(new IllegalArgumentError(\"empty list of futures\")))\n\n      // Creating race condition\n      let isDone = false\n\n      for (let index = 0; index < futures.length; index++) {\n        const fi = index\n        const fa = futures[index]\n\n        fa.onComplete(result => {\n          if (!isDone) {\n            isDone = true\n            futureCancelAll(futures, ec, fi)\n            cb(result)\n          } else if (result.isFailure()) {\n            ec.reportFailure(result.failed().get())\n          }\n        })\n      }\n\n      return Cancelable.of(() => futureCancelAll(futures, ec))\n    } catch (e) {\n      // If an error happens here, it means the conversion from iterable to\n      // array failed, and the futures we've seen are already canceled\n      cb(Failure(e))\n    }\n  }, ec)\n}\n\n/**\n * Internal implementation for `Future.traverse`.\n *\n * @Hidden\n */\nfunction futureTraverse<A, B>(\n  list: A[] | Iterable<A>,\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler): Future<B[]> {\n\n  if (parallelism <= 0) {\n    throw new IllegalArgumentError(`parallelism <= 0`)\n  }\n  return Future.of(() => iterableToArray(list), ec)\n    .flatMap(values => futureTraverseLoop(values, f, parallelism, ec, 0, []))\n}\n\n/** @Hidden */\nfunction futureTraverseLoop<A, B>(\n  list: A[],\n  f: (a: A) => Future<B>,\n  parallelism: number,\n  ec: Scheduler,\n  index: number,\n  result: B[]): Future<B[]> {\n\n  if (index >= list.length) return Future.pure(result)\n  let batch: Future<B>[] = []\n  let length = 0\n\n  try {\n    while (index < list.length && length < parallelism) {\n      batch.push(f(list[index++]))\n      length += 1\n    }\n\n    const fa = Future.sequence(batch, ec).map(b => {\n      for (let i = 0; i < b.length; i++) result.push(b[i])\n    })\n\n    if (index >= list.length) {\n      // We are done, signal final result\n      return fa.map(_ => result)\n    } else {\n      // Continue with the next batch\n      return fa.flatMap(_ => futureTraverseLoop(list, f, parallelism, ec, index, result))\n    }\n  } catch (e) {\n    // Batch generation triggered an error\n    futureCancelAll(batch, ec)\n    return Future.raise(e)\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Utilities for working with type classes and higher kinded types.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { HK } from \"funfix/dist/types/kinds\"\n * // ... or ...\n * import { HK } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/kinds\n */\n\n/***/\nimport { IllegalArgumentError, NotImplementedError } from \"../core/errors\"\n\n/**\n * Given a type `T` representing instances of a class `C`, the type\n * `Constructor<T>` is the type of the class `C`.\n *\n * This type emulates\n * [Class<T> from Flow]{@link https://flow.org/en/docs/types/utilities/#classt-a-classtoc-idtoc-class-hreftoc-classa}.\n *\n * Note that in TypeScript constructors can also be `protected` or `private`\n * and unfortunately specifying `{ new(): T }` is thus insufficient.\n * Which is why, for classes without a public constructor, we have to\n * specify a `_funErasure` (static) member as a property, to help the compiler\n * infer type `T`.\n *\n * Example:\n *\n * ```typescript\n * class NumBox { constructor(public num: number) {} }\n * class GenBox<A> { constructor(public a: A) {} }\n *\n * function getDefault<F>(ref: Constructor<F>): Option<F> {\n *   if ((ref as any)._default) return Some(ref._default)\n *   return None\n * }\n *\n * (NumBox as any)._default = new NumBox(10)\n * (GenBox as any)._default = new GenBox(\"value\")\n *\n * const r1: Option<NumBox> = getDefault(NumBox)\n * const r2: Option<GenBox<any>> = getDefault(GenBox)\n * ```\n *\n * And for classes with a private constructor:\n *\n * ```typescript\n * class PrivateBox<A> {\n *   private constructor(public a: A) {}\n *\n *   static _funErasure: PrivateBox<any> // leaving undefined\n * }\n *\n * const F = PrivateBox as any\n * F._default = new F(\"hello\")\n *\n * const r: Option<PrivateBox<any>> = getDefault(NumBox)\n * ```\n */\nexport type Constructor<T> =\n  { new(...args: any[]): T } | { readonly _funErasure: T }\n\n/**\n * The `TypeClass` interface is to be implemented by type class\n * definitions, exposing IDs needed for discovery management.\n *\n * Only of interest to type class authors.\n */\nexport type TypeClass<F> = Constructor<F> & {\n  readonly _funTypeId: string\n  readonly _funSupertypeIds: string[]\n}\n\n/**\n * Lightweight encoding for higher kinded types.\n *\n * Inspired by the\n * [Lightweight higher-kinded polymorphism]{@link https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf}\n * paper.\n *\n */\nexport interface HK<F, A> {\n  /** Trick for achieving nominal typing. */\n  readonly _funKindF: F\n\n  /** Trick for achieving nominal typing. */\n  readonly _funKindA: A\n}\n\n/**\n * Data type for expressing equivalence in type class laws.\n *\n * @final\n */\nexport class Equiv<A> {\n  private constructor(\n    public readonly lh: A,\n    public readonly rh: A) {}\n\n  static of<A>(lh: A, rh: A): Equiv<A> {\n    return new Equiv(lh, rh)\n  }\n}\n\n/**\n * Given a {@link TypeClass} definition in `tc`, register an `instance`\n * for the given {@link Constructor} specified by `c` that implements the\n * given type class.\n *\n * Example:\n *\n * ```typescript\n * registerTypeClassInstance(Functor)(Box, new BoxFunctorInstance())\n * ```\n *\n * Data types can have only one implementation for a given type class.\n * Multiple implementations are not allowed, therefore registration needs\n * to happen at most once. If registration happens multiple times for\n * instances of the same data type and type class, then an exception is\n * going to be raised:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n *\n * // IllegalArgumentError: Type class coherence issue,\n * // Functor<Box> is already defined!\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance1())\n * ```\n *\n * Note that type classes can have super types. So for example registering\n * a `Monad` instance will also register a `Functor` instance, along with\n * `Applicative`. The registration of supertypes however does not trigger\n * coherence errors. In this example, if you try registering a `Monad`,\n * but a `Functor` was already registered, then that the given `Monad`\n * will simply not be registered as a `Functor` for that data type.\n *\n * This is legal:\n *\n * ```typescript\n * // Ok\n * registerTypeClassInstance(Functor)(Box, new FunctorInstance())\n *\n * // Ok, even though a Monad is also a Functor\n * registerTypeClassInstance(Functor)(Box, new MonadInstance())\n * ```\n *\n * @throws `IllegalArgumentError` in case such a type class instance\n * was already specified, thus leading to a coherence issue.\n */\nexport function registerTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>, instance: F) => void {\n\n  return <T>(c: Constructor<T>, instance: F) => {\n    const obj = c as any\n    const types: {[id: string]: any} = (obj._funTypes || {})\n    obj._funTypes = types\n\n    const existing = types[tc._funTypeId]\n    if (existing) {\n      // If trying to register the same instance, then ignore\n      if (existing === instance) return\n      // Coherence issue\n      const name = existing.constructor.name\n      throw new IllegalArgumentError(\n        \"Type class coherence issue, \" +\n        `${name}<${(c as any).name}> is already defined!`\n      )\n    }\n\n    types[tc._funTypeId] = instance\n    for (const id of tc._funSupertypeIds) {\n      if (!types[id]) types[id] = instance\n    }\n  }\n}\n\n/**\n * Given a {@link TypeClass} instance and a {@link Constructor} reference,\n * returns its associated type class implementation if it exists, or throws\n * a {@link NotImplementedError} in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, getTypeClass } from \"funfix\"\n *\n * const F: Functor<Option<any>> = getTypeClass(Functor, Option)\n * ```\n */\nexport function getTypeClassInstance<F>(tc: TypeClass<F>):\n  <T>(c: Constructor<T>) => F {\n\n  return <T>(c: Constructor<T>) => {\n    const obj = c as any\n    const types: {[id: string]: any} = obj._funTypes || {}\n    const instance = types[tc._funTypeId]\n    if (instance) return instance as any\n    throw new NotImplementedError(`${(tc as any).name}<${obj.name}>`)\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Eq} type class.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Eq } from \"funfix/dist/types/eq\"\n * // ... or ...\n * import { Eq } from \"funfix/dist/types\"\n * // ... or ...\n * import { Eq } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/eq\n */\n\n/***/\n\nimport { Constructor, getTypeClassInstance } from \"./kinds\"\n\n/**\n * The `Eq` is a type class used to determine equality between 2\n * instances of the same type. Any 2 instances `x` and `y` are equal\n * if `eqv(x, y)` is `true`. Moreover, `eqv` should form an\n * equivalence relation.\n *\n * Example:\n *\n * ```typescript\n * const F = eqOf(Option)\n *\n * F.eqv(Some(1), Some(1)) // true\n * F.eqv(Some(1), None)    // false\n * ```\n *\n * MUST obey the laws defined in {@link EqLaws}.\n *\n * CREDITS: this type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Eq<A> {\n  abstract eqv(lh: A, rh: A): boolean\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"eq\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Eq<any>\n}\n\n/**\n * Type class laws defined for {@link Eq}.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class EqLaws<A> {\n  /**\n   * The {@link Eq} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Eq<A>\n\n  /**\n   * Equality is reflexive, i.e.\n   * ```\n   * a == a\n   * ```\n   */\n  reflexive(a: A): boolean {\n    return this.F.eqv(a, a)\n  }\n\n  /**\n   * Equality is symmetric, i.e.\n   * ```\n   * x == y <-> y == x\n   * ```\n   */\n  symmetric(x: A, y: A): boolean {\n    return this.F.eqv(x, y) === this.F.eqv(y, x)\n  }\n\n  /**\n   * Equality is transitive, i.e.\n   * ```\n   * x == y && y == z -> x == z\n   * ```\n   */\n  transitive(x: A, y: A, z: A): boolean {\n    return !(this.F.eqv(x, y) && this.F.eqv(y, z)) || this.F.eqv(x, z)\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Eq} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Eq, eqOf } from \"funfix\"\n *\n * const F: Eq<Option<any>> = eqOf(Option)\n * ```\n */\nexport const eqOf: <F>(c: Constructor<F>) => Eq<F> =\n  getTypeClassInstance(Eq)\n\n/**\n * Given an {@link Eq} instance, returns the {@link EqLaws}\n * associated with it.\n */\nexport function eqLawsOf<A>(instance: Eq<A>): EqLaws<A> {\n  return new (class extends EqLaws<A> { public readonly F = instance })()\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Functor} type class.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Functor } from \"funfix/dist/types/functor\"\n * // ... or ...\n * import { Functor } from \"funfix/dist/types\"\n * // ... or ...\n * import { Functor } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/functor\n */\n\n/***/\nimport { id } from \"../core/std\"\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\n\n/**\n * The `Functor` is a type class providing the `map` operation that\n * allows lifting an `f` function into the functor context and\n * applying it.\n *\n * The name is short for \"covariant functor\".\n *\n * Example:\n *\n * ```typescript\n * const F = functorOf(Option)\n *\n * F.map(Some(1), x => x + 1) // Some(2)\n * ```\n *\n * MUST obey the laws defined in {@link FunctorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import { HK, Functor, registerTypeClassInstance } from \"funfix\"\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * // Type alias defined for readability\n * type BoxK<T> = HK<Box<any>, T>\n *\n * // Actual implementation\n * class BoxFunctor implements Functor<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n * }\n *\n * // Registering global Functor instance for Box\n * registerTypeClassInstance(Functor)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Functor<F> {\n  /**\n   * Given a mapping function, transforms the source.\n   *\n   * The `map` operation must follow these laws:\n   *\n   * - `fa.map(id) <-> fa`\n   * - `fa.map(f).map(g) <-> fa.map(x => g(f(x)))`\n   */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"functor\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = []\n  /** @hidden */\n  static readonly _funErasure: Functor<any>\n}\n\n/**\n * Type class laws defined for {@link Functor}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FunctorLaws<F> {\n  /**\n   * The {@link Functor} designated instance for `F`,\n   * to be tested.\n   */\n  abstract readonly F: Functor<F>\n\n  /**\n   * ```typescript\n   * fa.map(id) <-> fa\n   * ```\n   */\n  covariantIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    return Equiv.of(this.F.map(fa, id), fa)\n  }\n\n  /**\n   * ```typescript\n   * fa.map(f).map(g) <-> fa.map(x => g(f(x)))\n   * ```\n   */\n  covariantComposition<A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C): Equiv<HK<F, C>> {\n    return Equiv.of(\n      this.F.map(this.F.map(fa, f), g),\n      this.F.map(fa, x => g(f(x)))\n    )\n  }\n}\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Functor} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Functor, functorOf } from \"funfix\"\n *\n * const F: Functor<Option<any>> = functorOf(Option)\n * ```\n */\nexport const functorOf: <F>(c: Constructor<F>) => Functor<F> =\n  getTypeClassInstance(Functor)\n\n/**\n * Given an {@link Functor} instance, returns the {@link FunctorLaws}\n * associated with it.\n */\nexport function functorLawsOf<F>(instance: Functor<F>): FunctorLaws<F> {\n  return new (class extends FunctorLaws<F> { public readonly F = instance })()\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Apply} and {@link Applicative} type classes.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Applicative } from \"funfix/dist/types/applicative\"\n * // ... or ...\n * import { Applicative } from \"funfix/dist/types\"\n * // ... or ...\n * import { Applicative } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/applicative\n */\n\n/***/\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Functor, FunctorLaws } from \"./functor\"\nimport { Either, Right, Left } from \"../core/disjunctions\"\nimport { NotImplementedError } from \"../core/errors\"\nimport { applyMixins } from \"../core/std\"\n\n/**\n * The `Apply` type class, a weaker version of {@link Applicative},\n * exposing `ap` (apply), but not `pure`.\n *\n * This type class is exposed in addition to `Applicative` because\n * there are data types for which we can't implement `pure`, but\n * that could still benefit from an `ap` definition. For example\n * in case of a `Map<K, ?>` we couldn't define `pure` for it\n * because we don't have a `K` key.\n *\n * MUST obey the laws defined in {@link ApplyLaws}.\n *\n * Note that having an `Apply` instance implies that a\n * {@link Functor} implementation is also available, which is why\n * `Apply` is a subtype of `Functor`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Apply,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note these can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApply implements Apply<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     const a = (fa as Box<A>).value\n *     return new Box(f(a))\n *   }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n * }\n *\n * // Call needed in order to implement `map2` and `product` using\n * // the default implementations defined by `Apply`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own definitions\n * applyMixins(BoxApply, [Apply])\n *\n * // Registering global Apply instance for Box, needed in order\n * // for the `applyOf(Box)` calls to work\n * registerTypeClassInstance(Apply)(Box, new BoxApply())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Apply<F> implements Functor<F> {\n  /**\n   * Given a value and a function in the `Apply` context,\n   * applies the function to the value.\n   */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Applies the pure (binary) function `f` to the effectful values\n   * `fa` and `fb`.\n   *\n   * `map2` can be seen as a binary version of {@link Functor.map}.\n   */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.ap(fb, this.map(fa, a => (b: B) => f(a, b)))\n  }\n\n  /**\n   * Captures the idea of composing independent effectful values.\n   *\n   * It is of particular interest when taken together with [[Functor]].\n   * Where [[Functor]] captures the idea of applying a unary pure\n   * function to an effectful value, calling `product` with `map`\n   * allows one to apply a function of arbitrary arity to multiple\n   * independent effectful values.\n   *\n   * This operation is equivalent with:\n   *\n   * ```typescript\n   * map2(fa, fb, (a, b) => [a, b])\n   * ```\n   */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.map2(fa, fb, (a: A, b: B) => [a, b] as [A, B])\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"apply\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\"]\n  /** @hidden */\n  static readonly _funErasure: Apply<any>\n}\n\napplyMixins(Apply, [Functor])\n\n/**\n * Type class laws defined for {@link Apply}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplyLaws<F> implements FunctorLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Apply<F>\n\n  applyComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(F.ap(fa, fab), fbc),\n      F.ap(fa, F.ap(fab, F.map(fbc, compose)))\n    )\n  }\n\n  applyProductConsistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map(F.product(f, fa), p => { const [f, a] = p; return f(a) })\n    )\n  }\n\n  applyMap2Consistency<A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, f),\n      F.map2(f, fa, (f, a) => f(a))\n    )\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n}\n\napplyMixins(ApplyLaws, [FunctorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Apply} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Apply, applyOf } from \"funfix\"\n *\n * const F: Apply<Option<any>> = applyOf(Option)\n * ```\n */\nexport const applyOf: <F>(c: Constructor<F>) => Apply<F> =\n  getTypeClassInstance(Apply)\n\n/**\n * Given an {@link Apply} instance, returns the {@link ApplyLaws}\n * associated with it.\n */\nexport function applyLawsOf<F>(instance: Apply<F>): ApplyLaws<F> {\n  return new (class extends ApplyLaws<F> { public readonly F = instance })()\n}\n\n/**\n * `Applicative` functor type class.\n *\n * Allows application of a function in an Applicative context to a\n * value in an `Applicative` context.\n *\n * References:\n *\n * - [The Essence of the Iterator Pattern]{@link https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf}\n * - [Applicative programming with effects]{@link http://staff.city.ac.uk/~ross/papers/Applicative.pdf}\n *\n * Example:\n *\n * ```typescript\n * const F = applicativeOf(Option)\n *\n * F.ap(F.pure(1), F.pure((x: number) => x + 1)) // Some(2)\n * ```\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor} and {@link Apply} implementations are also\n * available, which is why `Applicative` is a subtype of\n * `Functor` and `Apply`.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Applicative,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicative implements Applicative<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const a = (fa as Box<A>).value\n *     const f = (ff as Box<(a: A) => B>).value\n *     return new Box(f(a))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product` and `unit`,\n * // using the default implementations defined by `Applicative`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicative, [Applicative])\n *\n * // Registering global Applicative instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)` and `applicativeOf(Box)`\n * // calls to work\n * registerTypeClassInstance(Applicative)(Box, new BoxApplicative())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Applicative<F> implements Apply<F> {\n  /**\n   * Lifts a strict value `A` into the `F<A>` context.\n   */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Apply.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /**\n   * Shorthand for `pure<void>(undefined)`, provided for convenience\n   * and because implementations can override the default for\n   * optimization purposes.\n   */\n  unit(): HK<F, void> {\n    return this.pure(undefined)\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.ap(fa, this.pure(f))\n  }\n\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicative\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: Applicative<any>\n}\n\napplyMixins(Applicative, [Apply])\n\n/**\n * Type class laws defined for {@link Applicative}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Applicative<F>\n\n  applicativeIdentity<A>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, F.pure((a: A) => a)),\n      fa\n    )\n  }\n\n  applicativeHomomorphism<A, B>(a: A, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), F.pure(f)),\n      F.pure(f(a))\n    )\n  }\n\n  applicativeInterchange<A, B>(a: A, ff: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(F.pure(a), ff),\n      F.ap(ff, F.pure((f: (a: A) => B) => f(a)))\n    )\n  }\n\n  applicativeMap<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.map(fa, f),\n      F.ap(fa, F.pure(f))\n    )\n  }\n\n  applicativeComposition<A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>): Equiv<HK<F, C>> {\n    const F = this.F\n    const compose = (f: (b: B) => C) => (\n      (g: (a: A) => B) => (a: A) => f(g(a))\n    )\n\n    return Equiv.of(\n      F.ap(fa, F.ap(fab, F.ap(fbc, F.pure(compose)))),\n      F.ap(F.ap(fa, fab), fbc)\n    )\n  }\n\n  applicativeUnit<A>(a: A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.map(F.unit(), _ => a), F.pure(a))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Applicative} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Applicative, applicativeOf } from \"funfix\"\n *\n * const F: Applicative<Option<any>> = applicativeOf(Option)\n * ```\n */\nexport const applicativeOf: <F>(c: Constructor<F>) => Applicative<F> =\n  getTypeClassInstance(Applicative)\n\n/**\n * Given an {@link Applicative} instance, returns the {@link ApplicativeLaws}\n * associated with it.\n */\nexport function applicativeLawsOf<F>(instance: Applicative<F>): ApplicativeLaws<F> {\n  return new (class extends ApplicativeLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `ApplicativeError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link ApplicativeErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   ApplicativeError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxApplicativeError implements ApplicativeError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   ap<A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>): Box<B> {\n *     const ta = (fa as Box<A>).value\n *     const tf = (ff as Box<(a: A) => B>).value\n *     return new Box(Try.map2(ta, tf, (a, f) => f(a)))\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `ApplicativeError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxApplicativeError, [ApplicativeError])\n *\n * // Registering global ApplicativeError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `applicativeErrorOf(Box)` calls to work\n * registerTypeClassInstance(ApplicativeError)(Box, new BoxApplicativeError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class ApplicativeError<F, E> implements Applicative<F> {\n  /**\n   * Lift an error into the `F` context.\n   */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /**\n   * Handle any error, potentially recovering from it, by mapping it to an\n   * `F<A>` value.\n   *\n   * @see {@link recover} to handle any error by simply mapping it to an `A`\n   * value instead of an `F<A>`.\n   */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /**\n   * Handle any error by mapping it to an `A` value.\n   *\n   * @see {@link recoverWith} to map to an `F[A]` value instead of\n   * simply an `A` value.\n   */\n  recover<A>(fa: HK<F, A>, f: (e: E) => A): HK<F, A> {\n    const F = this\n    return F.recoverWith(fa, e => F.pure(f(e)))\n  }\n\n  /**\n   * Handle errors by turning them into {@link Either} values.\n   *\n   * If there is no error, then a `Right` value will be returned.\n   * All non-fatal errors should be handled by this method.\n   */\n  attempt<A>(fa: HK<F, A>): HK<F, Either<E, A>> {\n    const F = this\n    return F.recover(\n      F.map(fa, a => Either.right<E, A>(a)),\n      Left)\n  }\n\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link Applicative.ap}. */\n  abstract ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"applicativeError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\"]\n  /** @hidden */\n  static readonly _funErasure: ApplicativeError<any, any>\n}\n\napplyMixins(ApplicativeError, [Applicative])\n\n/**\n * Type class laws defined for {@link ApplicativeError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class ApplicativeErrorLaws<F, E> implements ApplicativeLaws<F> {\n  /**\n   * The {@link Applicative} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: ApplicativeError<F, E>\n\n  applicativeErrorRecoverWith<A>(e: E, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.raise<A>(e), f), f(e))\n  }\n\n  applicativeErrorRecover<A>(e: E, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.raise<A>(e), f), F.pure(f(e)))\n  }\n\n  recoverWithPure<A>(a: A, f: (e: E) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recoverWith(F.pure(a), f), F.pure(a))\n  }\n\n  recoverPure<A>(a: A, f: (e: E) => A): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.recover(F.pure(a), f), F.pure(a))\n  }\n\n  raiseErrorAttempt(e: E): Equiv<HK<F, Either<E, void>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.raise<void>(e)), F.pure(Left(e)))\n  }\n\n  pureAttempt<A>(a: A): Equiv<HK<F, Either<E, A>>> {\n    const F = this.F\n    return Equiv.of(F.attempt(F.pure(a)), F.pure(Right(a)))\n  }\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(ApplicativeErrorLaws, [ApplicativeLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link ApplicativeError} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Eval, ApplicativeError, applicativeErrorOf } from \"funfix\"\n *\n * const F: ApplicativeError<Option<any>> = applicativeErrorOf(Eval)\n * ```\n */\nexport const applicativeErrorOf: <F, E>(c: Constructor<F>) => ApplicativeError<F, E> =\n  getTypeClassInstance(ApplicativeError)\n\n/**\n * Given an {@link ApplicativeError} instance, returns the\n * {@link ApplicativeErrorLaws} associated with it.\n */\nexport function applicativeErrorLawsOf<F,E>(instance: ApplicativeError<F,E>): ApplicativeErrorLaws<F,E> {\n  return new (class extends ApplicativeErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Monad} and {@link FlatMap} type classes.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Monad } from \"funfix/dist/types/monad\"\n * // ... or ...\n * import { Monad } from \"funfix/dist/types\"\n * // ... or ...\n * import { Monad } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/monad\n */\n\n/***/\nimport { HK, Equiv, Constructor, getTypeClassInstance } from \"./kinds\"\nimport { Either, Right, Left } from \"../core/disjunctions\"\nimport { applyMixins } from \"../core/std\"\nimport {\n  Apply,\n  ApplyLaws,\n  Applicative,\n  ApplicativeLaws,\n  ApplicativeError,\n  ApplicativeErrorLaws\n} from \"./applicative\"\n\n/**\n * The `FlatMap` type class is a lightweight {@link Monad}.\n *\n * It exposes [flatMap]{@link FlatMap.flatMap}, which allows to have a\n * value in a context (`F<A>`) and then feed that into a function that\n * takes a normal value and returns a value in a context\n * (`A => F<B>`).\n *\n * One motivation for separating this out from `Monad` is that there are\n * situations where we can implement `flatMap` but not `pure`. For example,\n * we can implement `map` or `flatMap` that transforms the values of a\n * `Map<K, ?>` type, but we can't implement `pure` (because we wouldn't\n * know what key to use when instantiating the new `Map`).\n *\n * Must obey the laws defined in {@link FlatMapLaws}.\n *\n * Note that having an `Monad` instance implies\n * {@link Functor} and {@link Apply} implementations are also available,\n * as `FlatMap` is a subtype of these.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, FlatMap, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxFlatMap implements FlatMap<Box<any>> {\n *   map<A, B>(fa: BoxK<A>, f: (a: A) => B): Box<B> {\n *     return new Box(f((fa as Box<A>).value))\n *   }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.left().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `FlatMap`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxFlatMap, [FlatMap])\n *\n * // Registering global Functor instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `flatMapOf(Box)` calls to work\n * registerTypeClassInstance(FlatMap)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class FlatMap<F> implements Apply<F> {\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link Functor.map}. */\n  abstract map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B>\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Implementations of this method should use constant stack space relative to `f`.\n   */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedByL]{@link FlatMap.followedByL} for a lazy version.\n   */\n  followedBy<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb)\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value produced\n   * by the first.\n   *\n   * See [followedBy]{@link FlatMap.followedBy} for the strict version.\n   */\n  followedByL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, B> {\n    return this.flatMap(fa, _ => fb())\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffectL]{@link FlatMap.forEffectL} for the lazy version.\n   */\n  forEffect<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb, _ => a))\n  }\n\n  /**\n   * Sequentially compose two actions, discarding any value\n   * produced by the second.\n   *\n   * See [forEffect]{@link FlatMap.forEffect} for the strict version.\n   */\n  forEffectL<A, B>(fa: HK<F, A>, fb: () => HK<F, B>): HK<F, A> {\n    return this.flatMap(fa, a => this.map(fb(), _ => a))\n  }\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    return this.flatMap(fa, a => this.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    return this.flatMap(fa, a => this.map(fb, b => [a, b] as [A, B]))\n  }\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"flatMap\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\"]\n  /** @hidden */\n  static readonly _funErasure: FlatMap<any>\n}\n\n/**\n * Type class laws defined for {@link FlatMap}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class FlatMapLaws<F> implements ApplyLaws<F> {\n  /**\n   * The {@link Apply} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: FlatMap<F>\n\n  /**\n   * ```typescript\n   *  fa.flatMap(f).flatMap(g) <-> fa.flatMap(a => f(a).flatMap(g))\n   *  ```\n   */\n  flatMapAssociativity<A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>): Equiv<HK<F, C>> {\n    const F = this.F\n    return Equiv.of(\n      F.flatMap(F.flatMap(fa, f), g),\n      F.flatMap(fa, a => F.flatMap(f(a), g))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fab.ap(fa) <-> fab.flatMap(f => fa.map(f))\n   * ```\n   */\n  flatMapConsistentApply<A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.ap(fa, fab),\n      F.flatMap(fab, f => F.map(fa, f))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedBy(fa, fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.followedBy(() => fb) <-> fa.flatMap(_ => fb)\n   * ```\n   */\n  followedByLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(\n      F.followedByL(fa, () => fb),\n      F.flatMap(fa, _ => fb)\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffect(fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffect(fa, fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  /**\n   * ```typescript\n   * fa.forEffectL(() => fb) <-> fa.flatMap(a => fb.map(_ => a))\n   * ```\n   */\n  forEffectLConsistency<A, B>(fa: HK<F, A>, fb: HK<F, B>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(\n      F.forEffectL(fa, () => fb),\n      F.flatMap(fa, a => F.map(fb, _ => a))\n    )\n  }\n\n  tailRecMConsistentFlatMap<A>(a: A, f: (a: A) => HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    const bounce = (n: number) => {\n      return F.tailRecM([a, n] as [A, number], x => {\n        const [a0, i] = x\n        return i > 0\n          ? F.map(f(a0), a1 => Left([a1, i - 1] as [A, number]))\n          : F.map(f(a0), Right)\n      })\n    }\n\n    /*\n     * The law is for n >= 1\n     * bounce(n) == bounce(n - 1).flatMap(f)\n     *\n     * Many monads blow up if n gets too large here (for instance List, becomes\n     * multiplicative, so the memory is exponential in n).\n     */\n    return Equiv.of(bounce(1), F.flatMap(bounce(0), f))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(FlatMapLaws, [ApplyLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link FlatMap} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, FlatMap, flatMapOf } from \"funfix\"\n *\n * const F: FlatMap<Option<any>> = flatMapOf(Option)\n * ```\n */\nexport const flatMapOf: <F>(c: Constructor<F>) => FlatMap<F> =\n  getTypeClassInstance(FlatMap)\n\n/**\n * Given an {@link FlatMap} instance, returns the {@link FlatMapLaws}\n * associated with it.\n */\nexport function flatMapLawsOf<F>(instance: FlatMap<F>): FlatMapLaws<F> {\n  return new (class extends FlatMapLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `Monad` type class.\n *\n * Allows composition of dependent effectful functions.\n *\n * A `Monad` instance is defined by two operations:\n *\n * - `pure` from {@link Applicative}, which lifts an `A` value\n *    in the `F<A>` context\n * - `flatMap`, which allows us to have a value in a context (`F<A>`)\n *    and then feed that into a function that takes a normal value and\n *    returns a value in a context (`A => F<B>`)\n *\n * See [Monads for functional programming]{@link http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},\n * by Philip Wadler.\n *\n * Must obey the laws defined in {@link MonadLaws}.\n *\n * Note that having an `Applicative` instance implies\n * {@link Functor}, {@link Apply}, {@link Applicative} and {@link FlatMap}\n * implementations are also available, as `Monad` is a subtype\n * of these type classes.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK, Monad, Either,\n *   registerTypeClassInstance,\n *   applyMixins\n * } from \"../src/funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: T) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonad implements Monad<Box<any>> {\n *   pure<A>(a: A): Box<A> { return new Box(a) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     return f((fa as Box<A>).value) as Box<B>\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     let cursor = a\n *     while (true) {\n *       const box = f(cursor) as Box<Either<A, B>>\n *       const v = box.value\n *       if (v.isRight()) return new Box(v.get())\n *       cursor = v.left().get()\n *     }\n *   }\n *\n *   // Mixed-in, as these have default implementations\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `Monad`, because\n * // we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonad, [Monad])\n *\n * // Registering global Monad instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`,\n * // `flatMapOf(Box)` and `monadOf(Box)` calls to work\n * registerTypeClassInstance(Monad)(Box, new BoxFunctor())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class Monad<F> implements FlatMap<F>, Applicative<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link Apply.ap}. */\n  ap<A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>): HK<F, B> {\n    return this.flatMap(fa, a => this.map(ff, f => f(a)))\n  }\n\n  /** Inherited from {@link Functor.map}. */\n  map<A, B>(fa: HK<F, A>, f: (a: A) => B): HK<F, B> {\n    return this.flatMap(fa, a => this.pure(f(a)))\n  }\n\n  /** Inherited from {@link Apply.map2}. */\n  map2<A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z): HK<F, Z> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => f(a, b)))\n  }\n\n  /** Inherited from {@link Apply.product}. */\n  product<A, B>(fa: HK<F, A>, fb: HK<F, B>): HK<F, [A, B]> {\n    const F = this\n    return F.flatMap(fa, a => F.map(fb, b => [a, b] as [A, B]))\n  }\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monad\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] = [\"functor\", \"apply\", \"applicative\", \"flatMap\"]\n  /** @hidden */\n  static readonly _funErasure: Monad<any>\n}\n\napplyMixins(Monad, [Applicative, FlatMap])\n\n/**\n * Type class laws defined for {@link Monad}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadLaws<F> implements ApplicativeLaws<F>, FlatMapLaws<F> {\n  /**\n   * The {@link Monad} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: Monad<F>\n\n  monadLeftIdentity<A, B>(a: A, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.pure(a), f), f(a))\n  }\n\n  monadRightIdentity<A, B>(fa: HK<F, A>): Equiv<HK<F, A>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, F.pure), fa)\n  }\n\n  mapFlatMapCoherence<A, B>(fa: HK<F, A>, f: (a: A) => B): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(fa, a => F.pure(f(a))), F.map(fa, f))\n  }\n\n  tailRecMStackSafety(): Equiv<HK<F, number>> {\n    const F = this.F\n    const n = 10000\n    const res = F.tailRecM(0, i => F.pure(i < n ? Left(i + 1) : Right(i)))\n    return Equiv.of(res, F.pure(n))\n  }\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applyComposition}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n}\n\napplyMixins(MonadLaws, [ApplicativeLaws, FlatMapLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link Monad} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Option, Monad, monadOf } from \"funfix\"\n *\n * const F: Monad<Option<any>> = monadOf(Option)\n * ```\n */\nexport const monadOf: <F>(c: Constructor<F>) => Monad<F> =\n  getTypeClassInstance(Monad)\n\n/**\n * Given an {@link Monad} instance, returns the {@link MonadLaws}\n * associated with it.\n */\nexport function monadLawsOf<F>(instance: Monad<F>): MonadLaws<F> {\n  return new (class extends MonadLaws<F> { public readonly F = instance })()\n}\n\n/**\n * The `MonadError` type class is a {@link Applicative} that\n * also allows you to raise and or handle an error value.\n *\n * This type class allows one to abstract over error-handling\n * applicative types.\n *\n * MUST follow the law defined in {@link MonadErrorLaws}.\n *\n * ## Implementation notes\n *\n * Even though in TypeScript the Funfix library is using `abstract class` to\n * express type classes, when implementing this type class it is recommended\n * that you implement it as a mixin using \"`implements`\", instead of extending\n * it directly with \"`extends`\". See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * Implementation example:\n *\n * ```typescript\n * import {\n *   HK,\n *   MonadError,\n *   registerTypeClassInstance,\n *   applyMixins,\n *   Try\n * } from \"funfix\"\n *\n * // Type alias defined for readability.\n * // HK is our encoding for higher-kinded types.\n * type BoxK<T> = HK<Box<any>, T>\n *\n * class Box<T> implements HK<Box<any>, T> {\n *   constructor(public value: Try<T>) {}\n *\n *   // Implements HK<Box<any>, A>, not really needed, but useful in order\n *   // to avoid type casts. Note they can and should be undefined:\n *   readonly _funKindF: Box<any>\n *   readonly _funKindA: T\n * }\n *\n * class BoxMonadError implements MonadError<Box<any>, any> {\n *   pure<A>(a: A): Box<A> { return new Box(Try.success(a)) }\n *\n *   flatMap<A, B>(fa: BoxK<A>, f: (a: A) => BoxK<B>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   tailRecM<A, B>(a: A, f: (a: A) => BoxK<Either<A, B>>): Box<B> {\n *     throw new NotImplementedError(\"Provide implementation\")\n *   }\n *\n *   raise<A>(e: any): HK<Box<any>, A> {\n *     return new Box(Try.failure(e))\n *   }\n *\n *   recoverWith<A>(fa: BoxK<A>, f: (e: any) => BoxK<A>): HK<Box<any>, A> {\n *     return new Box((fa as Box<A>).value.recoverWith(e => (f(e) as Box<A>).value))\n *   }\n *\n *   // Mixed in\n *   map: <A, B>(fa: BoxK<A>, f: (a: A) => B) => Box<B>\n *   map2: <A, B, Z>(fa: BoxK<A>, fb: BoxK<B>, f: (a: A, b: B) => Z) => Box<Z>\n *   ap: <A, B>(fa: BoxK<A>, ff: BoxK<(a: A) => B>) => Box<B>\n *   product: <A, B> (fa: BoxK<A>, fb: BoxK<B>) => Box<[A, B]>\n *   unit: () => Box<void>\n *   followedBy: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<B>\n *   followedByL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<B>\n *   forEffect: <A, B>(fa: BoxK<A>, fb: BoxK<B>) => Box<A>\n *   forEffectL: <A, B>(fa: BoxK<A>, fb: () => BoxK<B>) => Box<A>\n *   recover: <A>(fa: HK<Box<any>, A>, f: (e: any) => A) => HK<Box<any>, A>\n *   attempt: <A>(fa: HK<Box<any>, A>) => HK<Box<any>, Either<any, A>>\n * }\n *\n * // Call needed in order to implement `map`, `map2`, `product`, etc.\n * // using the default implementations defined by `MonadError`,\n * // because we are using `implements` instead of `extends` above and\n * // because in this sample we want the default implementations,\n * // but note that you can always provide your own\n * applyMixins(BoxMonadError, [MonadError])\n *\n * // Registering global MonadError instance for Box, needed in order\n * // for the `functorOf(Box)`, `applyOf(Box)`, `applicativeOf(Box)`\n * // and `monadErrorOf(Box)` calls to work\n * registerTypeClassInstance(MonadError)(Box, new BoxMonadError())\n * ```\n *\n * We are using `implements` in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these type classes are defined with\n * \"`interface`\", as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n *\n * ## Credits\n *\n * This type class is inspired by the equivalent in Haskell's\n * standard library and the implementation is inspired by the\n * [Typelevel Cats]{@link http://typelevel.org/cats/} project.\n */\nexport abstract class MonadError<F, E> implements ApplicativeError<F, E>, Monad<F> {\n  /** Inherited from {@link Applicative.pure}. */\n  abstract pure<A>(a: A): HK<F, A>\n\n  /** Inherited from {@link ApplicativeError.raise}. */\n  abstract raise<A>(e: E): HK<F, A>\n\n  /** Inherited from {@link FlatMap.flatMap}. */\n  abstract flatMap<A, B>(fa: HK<F, A>, f: (a: A) => HK<F, B>): HK<F, B>\n\n  /** Inherited from {@link FlatMap.tailRecM}. */\n  abstract tailRecM<A, B>(a: A, f: (a: A) => HK<F, Either<A, B>>): HK<F, B>\n\n  /** Inherited from {@link ApplicativeError.recoverWith}. */\n  abstract recoverWith<A>(fa: HK<F, A>, f: (e: E) => HK<F, A>): HK<F, A>\n\n  /** Mixed-in from {@link ApplicativeError.recover}. */\n  recover: <A>(fa: HK<F, A>, f: (e: E) => A) => HK<F, A>\n  /** Mixed-in from {@link ApplicativeError.attempt}. */\n  attempt: <A>(fa: HK<F, A>) => HK<F, Either<E, A>>\n\n  /** Mixed-in from {@link Applicative.unit}. */\n  unit: () => HK<F, void>\n  /** Mixed-in from {@link Applicative.map}. */\n  map: <A, B>(fa: HK<F, A>, f: (a: A) => B) => HK<F, B>\n  /** Mixed-in from {@link Apply.map2}. */\n  map2: <A, B, Z>(fa: HK<F, A>, fb: HK<F, B>, f: (a: A, b: B) => Z) => HK<F, Z>\n  /** Mixed-in from {@link Apply.product}. */\n  product: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, [A, B]>\n  /** Mixed-in from {@link FlatMap.followedBy}. */\n  followedBy: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.followedByL}. */\n  followedByL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, B>\n  /** Mixed-in from {@link FlatMap.forEffect}. */\n  forEffect: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link FlatMap.forEffectL}. */\n  forEffectL: <A, B>(fa: HK<F, A>, fb: () => HK<F, B>) => HK<F, A>\n  /** Mixed-in from {@link Monad.ap}. */\n  ap: <A, B>(fa: HK<F, A>, ff: HK<F, (a: A) => B>) => HK<F, B>\n\n  // Implements TypeClass<F>\n\n  /** @hidden */\n  static readonly _funTypeId: string = \"monadError\"\n  /** @hidden */\n  static readonly _funSupertypeIds: string[] =\n    [\"functor\", \"apply\", \"applicative\", \"monad\", \"applicativeError\"]\n\n  /** @hidden */\n  static readonly _funErasure: MonadError<any, any>\n}\n\napplyMixins(MonadError, [Monad, ApplicativeError])\n\n/**\n * Type class laws defined for {@link MonadError}.\n *\n * This is an abstract definition. In order to use it in unit testing,\n * the implementor must think of a strategy to evaluate the truthiness\n * of the returned `Equiv` values.\n *\n * Even though in TypeScript the Funfix library is using classes to\n * express these laws, when implementing this class it is recommended\n * that you implement it as a mixin using `implements`, instead of extending\n * it directly with `extends`. See\n * [TypeScript: Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * for details and note that we already have {@link applyMixins} defined.\n *\n * We are doing this in order to support multiple inheritance and to\n * avoid inheriting any `static` members. In the Flow definitions (e.g.\n * `.js.flow` files) for Funfix these classes are defined with\n * `interface`, as they are meant to be interfaces that sometimes have\n * default implementations and not classes.\n */\nexport abstract class MonadErrorLaws<F, E> implements ApplicativeErrorLaws<F, E>, MonadLaws<F> {\n  /**\n   * The {@link MonadError} designated instance for `F`,\n   * to be tested.\n   */\n  public readonly F: MonadError<F, E>\n\n  monadErrorLeftZero<A, B>(e: E, f: (a: A) => HK<F, B>): Equiv<HK<F, B>> {\n    const F = this.F\n    return Equiv.of(F.flatMap(F.raise<A>(e), f), F.raise<B>(e))\n  }\n\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecoverWith}. */\n  applicativeErrorRecoverWith: <A>(e: E, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.applicativeErrorRecover}. */\n  applicativeErrorRecover: <A>(e: E, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverWithPure}. */\n  recoverWithPure: <A>(a: A, f: (e: E) => HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.recoverPure}. */\n  recoverPure: <A>(a: A, f: (e: E) => A) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.raiseErrorAttempt}. */\n  raiseErrorAttempt: (e: E) => Equiv<HK<F, Either<E, void>>>\n  /** Mixed-in from {@link ApplicativeErrorLaws.pureAttempt}. */\n  pureAttempt: <A>(a: A) => Equiv<HK<F, Either<E, A>>>\n\n  /** Mixed-in from {@link MonadLaws.monadLeftIdentity}. */\n  monadLeftIdentity: <A, B>(a: A, f: (a: A) => HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.monadRightIdentity}. */\n  monadRightIdentity: <A, B>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link MonadLaws.mapFlatMapCoherence}. */\n  mapFlatMapCoherence: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link MonadLaws.tailRecMStackSafety}. */\n  tailRecMStackSafety: () => Equiv<HK<F, number>>\n\n  /** Mixed-in from {@link FlatMapLaws.flatMapAssociativity}. */\n  flatMapAssociativity: <A, B, C>(fa: HK<F, A>, f: (a: A) => HK<F, B>, g: (b: B) => HK<F, C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link FlatMapLaws.flatMapConsistentApply}. */\n  flatMapConsistentApply: <A, B>(fa: HK<F, A>, fab: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByConsistency}. */\n  followedByConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.followedByLConsistency}. */\n  followedByLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectConsistency}. */\n  forEffectConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.forEffectLConsistency}. */\n  forEffectLConsistency: <A, B>(fa: HK<F, A>, fb: HK<F, B>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FlatMapLaws.tailRecMConsistentFlatMap}. */\n  tailRecMConsistentFlatMap: <A>(a: A, f: (a: A) => HK<F, A>) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link ApplicativeLaws.applicativeIdentity}. */\n  applicativeIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeHomomorphism}. */\n  applicativeHomomorphism: <A, B>(a: A, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeInterchange}. */\n  applicativeInterchange: <A, B>(a: A, ff: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeMap}. */\n  applicativeMap: <A, B>(fa: HK<F, A>, f: (a: A) => B) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeComposition}. */\n  applicativeComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplicativeLaws.applicativeUnit}. */\n  applicativeUnit: <A>(a: A) => Equiv<HK<F, A>>\n\n  /** Mixed-in from {@link FunctorLaws.covariantIdentity}. */\n  covariantIdentity: <A>(fa: HK<F, A>) => Equiv<HK<F, A>>\n  /** Mixed-in from {@link FunctorLaws.covariantComposition}. */\n  covariantComposition: <A, B, C>(fa: HK<F, A>, f: (a: A) => B, g: (b: B) => C) => Equiv<HK<F, C>>\n\n  /** Mixed-in from {@link ApplyLaws.applyComposition}. */\n  applyComposition: <A, B, C>(fa: HK<F, A>, fab: HK<F, (a: A) => B>, fbc: HK<F, (b: B) => C>) => Equiv<HK<F, C>>\n  /** Mixed-in from {@link ApplyLaws.applyProductConsistency}. */\n  applyProductConsistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n  /** Mixed-in from {@link ApplyLaws.applyMap2Consistency}. */\n  applyMap2Consistency: <A, B>(fa: HK<F, A>, f: HK<F, (a: A) => B>) => Equiv<HK<F, B>>\n}\n\napplyMixins(MonadErrorLaws, [MonadLaws, ApplicativeErrorLaws])\n\n/**\n * Given a {@link Constructor} reference, returns its associated\n * {@link MonadError} instance if it exists, or throws a {@link NotImplementedError}\n * in case there's no such association.\n *\n * ```typescript\n * import { Eval, MonadError, monadErrorOf } from \"funfix\"\n *\n * const F: MonadError<Option<any>> = monadErrorOf(Eval)\n * ```\n */\nexport const monadErrorOf: <F, E>(c: Constructor<F>) => MonadError<F, E> =\n  getTypeClassInstance(MonadError)\n\n/**\n * Given an {@link MonadError} instance, returns the\n * {@link MonadErrorLaws} associated with it.\n */\nexport function monadErrorLawsOf<F,E>(instance: MonadError<F,E>): MonadErrorLaws<F,E> {\n  return new (class extends MonadErrorLaws<F,E> { public readonly F = instance })()\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Exposes the {@link Eval} data type, a monad which controls evaluation.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { Eval } from \"funfix/dist/effect/eval\"\n * // ... or ...\n * import { Eval } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module effect/eval\n */\n\n/***/\n\nimport { Try, Either } from \"../core/disjunctions\"\nimport { IllegalStateError } from \"../core/errors\"\n\n/**\n * Eval is a monad which controls evaluation.\n *\n * This type wraps a value (or a computation that produces a value)\n * and can produce it on command via the {@link Eval.get get()}\n * method.\n *\n * There are three basic evaluation strategies:\n *\n *  - {@link Eval.now} and {@link Eval.raise}: for describing strict\n *    values, evaluated immediately\n *  - {@link Eval.once}: evaluated only once when the value is needed,\n *    with the result memoized (cached) for subsequent evaluations\n *  - [[Eval.always]]: evaluated every time the value is needed,\n *    being equivalent to a function\n *\n * Eval supports stack-safe lazy computation via the {@link Eval.map .map}\n * and {@link Eval.flatMap .flatMap} methods, which use an internal\n * trampoline to avoid stack overflows. Computation done within `map`\n * and `flatMap` is always done lazily, even when applied to an\n * `Eval.now` instance.\n *\n * Use `map` and `flatMap` to chain computation, and use `get()` to\n * get the result when needed. It is also not good style to create\n * `Eval` instances whose computation involves calling `get()` on\n * another `Eval` instance -- this can defeat the trampolining and\n * lead to stack overflows.\n *\n * ```typescript\n * const rndInt = Eval.of(() => {\n *   const nr = Math.random() * 1000000\n *   return nr & nr\n * })\n *\n * const evenInt = () =>\n *   rndInt.flatMap(int => {\n *     if (i % 2 == 0)\n *       return Eval.now(i)\n *     else // Retry until we have an even number!\n *       return evenInt()\n *   })\n *\n * const cached = evenInt().memoize()\n *\n * // Nothing happens until now, this triggers the\n * // actual evaluation:\n * const n: number = cached.get()\n * ```\n *\n * This type is inspired by `cats.Eval` from\n * {@link http://typelevel.org/cats/|Typelevel Cats}\n * and by `monix.eval.Coeval` from {@link https://monix.io|Monix}.\n * Note that the design of this type follows Monix's `Coeval`, which\n * means that it does error handling (i.e. it's a `MonadError`).\n *\n * @final\n */\nexport class Eval<A> {\n  /**\n   * Evaluates the source `Eval` and returns the result.\n   *\n   * ```typescript\n   * const ref1 = Eval.always(() => 100)\n   * ref1.get() // 100\n   *\n   * const ref2 = Eval.raise(\"error\")\n   * ref2.get() // throws \"error\"\n   * ```\n   *\n   * WARNING: this function should be considered partial, as it can\n   * throw exception depending on what gets executed, use with care!\n   */\n  get(): A { return this.run().get() }\n\n  /**\n   * Evaluates the source `Eval` and returns the result as a [[Try]],\n   * capturing any thrown exceptions in the process.\n   *\n   * ```typescript\n   * const ref1 = Eval.always(() => 100)\n   * ref1.run() // Success(100)\n   *\n   * const ref2 = Eval.raise(\"error\")\n   * ref2.run() // Failure(\"error\")\n   * ```\n   */\n  run(): Try<A> { return evalRunLoop(this) }\n\n  /**\n   * Evaluates the source `Eval` and returns its successful result,\n   * otherwise return the given `fallback` if the source ends in\n   * failure.\n   *\n   * ```typescript\n   * const ref1 = Eval.always(() => 100)\n   * ref1.getOrElse(0) // 100\n   *\n   * const ref2 = Eval.raise(\"error\")\n   * ref2.getOrElse(0) // 0\n   * ```\n   *\n   * See [[Eval.getOrElseL]] for a lazy alternative.\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    return this.run().getOrElse(fallback)\n  }\n\n  /**\n   * Evaluates the source `Eval` and returns its successful result,\n   * otherwise return the result of the given `thunk` as a fallback,\n   * if the source ends in failure.\n   *\n   * ```typescript\n   * const ref1 = Eval.always(() => 100)\n   * ref1.getOrElseL(() => 0) // 100\n   *\n   * const ref2 = Eval.raise(\"error\")\n   * ref2.getOrElseL(() => 0) // 0\n   * ```\n   *\n   * See [[Eval.getOrElse]] for a strict alternative.\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    return this.run().getOrElseL(thunk)\n  }\n\n  /**\n   * Returns a new `Eval` that applies the mapping function to the\n   * successful result emitted by the source.\n   *\n   * ```typescript\n   * Eval.now(111).map(_ => _ * 2).get() // 222\n   * ```\n   */\n  map<B>(f: (a: A) => B): Eval<B> {\n    return new FlatMap(this, (a: A) => Eval.now(f(a)))\n  }\n\n  /**\n   * Creates a new `Eval` by applying a function to the successful\n   * result of the source, and returns a new instance equivalent to\n   * the result of the function.\n   *\n   * ```typescript\n   * const rndInt = Eval.of(() => {\n   *   const nr = Math.random() * 1000000\n   *   return nr & nr\n   * })\n   *\n   * const evenInt = () =>\n   *   rndInt.flatMap(int => {\n   *     if (i % 2 == 0)\n   *       return Eval.now(i)\n   *     else // Retry until we have an even number!\n   *       return evenInt()\n   *   })\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return new FlatMap(this, f)\n  }\n\n  /**\n   * Alias for {@link Eval.flatMap .flatMap}.\n   */\n  chain<B>(f: (a: A) => Eval<B>): Eval<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * Creates a new `Eval` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link Eval.map .map}, except that\n   * it can also transform errors and not just successful results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is function for transforming failures\n   */\n  transform<R>(failure: (e: any) => R, success: (a: A) => R): Eval<R> {\n    return this.transformWith(\n      e => Eval.now(failure(e)),\n      a => Eval.now(success(a))\n    )\n  }\n\n  /**\n   * Creates a new `Eval` by applying the 'success' function to the\n   * successful result of the source, or the 'error' function to the\n   * potential errors that might happen.\n   *\n   * This function is similar with {@link Eval.flatMap .flatMap},\n   * except that it can also transform errors and not just successful\n   * results.\n   *\n   * @param success is a function for transforming a successful result\n   * @param failure is function for transforming failures\n   */\n  transformWith<R>(failure: (e: any) => Eval<R>, success: (a: A) => Eval<R>): Eval<R> {\n    const f: any = (a: A) => success(a)\n    f.onFailure = failure\n    return new FlatMap(this, f) as any\n  }\n\n  /**\n   * Creates a new `Eval` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link Eval.map .map} for errors.\n   */\n  recover<AA>(f: (e: any) => AA): Eval<A | AA> {\n    return this.recoverWith(a => Eval.now(f(a)))\n  }\n\n  /**\n   * Creates a new `Eval` that will mirror the source on success,\n   * but on failure it will try to recover and yield a successful\n   * result by applying the given function `f` to the thrown error.\n   *\n   * This function is the equivalent of a `try/catch` statement,\n   * or the equivalent of {@link Eval.flatMap .flatMap} for errors.\n   */\n  recoverWith<AA>(f: (e: any) => Eval<AA>): Eval<A | AA> {\n    return this.transformWith(f, Eval.now as any)\n  }\n\n  /**\n   * Handle errors by turning them into {@link Either} values.\n   *\n   * If there is no error, then a `Right` value will be returned instead.\n   * Errors can be handled by this method.\n   */\n  attempt(): Eval<Either<any, A>> {\n    return this.transform(\n      _ => Either.left<any, A>(_),\n      Either.right)\n  }\n\n  /**\n   * Memoizes (caches) the result of the source on the first\n   * evaluation and reuses it on subsequent invocations of `get()`.\n   *\n   * The resulting `Eval` will be idempotent, meaning that\n   * evaluating it multiple times will have the same effect\n   * as evaluating it once.\n   *\n   * See {@link Eval.memoizeOnSuccess .memoizeOnSuccess} for a version\n   * that only caches successful results.\n   */\n  memoize(): Eval<A> {\n    if ((this instanceof Now) || (this instanceof Raise) || (this instanceof Once)) {\n      return this\n    } else if (this instanceof Always) {\n      return new Once(this.thunk, false)\n    } else {\n      return new Once(() => this.get(), false)\n    }\n  }\n\n  /**\n   * Memoizes (cache) the successful result of the source and reuses\n   * it on subsequent invocations of `get()`. Thrown exceptions are\n   * not cached.\n   *\n   * The resulting `Eval` will be idempotent, but only if the result\n   * is successful.\n   *\n   * See {@link Eval.memoize .memoize} for a version that caches both\n   * successful results and failures.\n   */\n  memoizeOnSuccess(): Eval<A> {\n    if (this instanceof Now || this instanceof Raise || this instanceof Once) {\n      return this\n    } else if (this instanceof Always) {\n      return new Once(this.thunk, true)\n    } else {\n      return new Once(() => this.get(), true)\n    }\n  }\n\n  /**\n   * Returns a new `Eval` that upon evaluation will execute the given\n   * function for the generated element, transforming the source into\n   * an `Eval<void>`.\n   *\n   * Similar in spirit with normal {@link Eval.forEach .forEach},\n   * but lazy, as obviously nothing gets executed at this point.\n   */\n  forEachL(cb: (a: A) => void): Eval<void> {\n    return this.map(cb)\n  }\n\n  /**\n   * Triggers the evaluation of the source, executing the given\n   * function for the generated element.\n   *\n   * The application of this function has strict behavior, as the\n   * coeval is immediately executed.\n   */\n  forEach(cb: (a: A) => void): void {\n    this.forEachL(cb).get()\n  }\n\n  // Implements HK<F, A>\n  readonly _funKindF: Eval<any>\n  readonly _funKindA: A\n\n  // Implements Constructor<T>\n  static readonly _funErasure: Eval<any>\n\n  /**\n   * Alias for {@link Eval.always}.\n   */\n  static of<A>(thunk: () => A): Eval<A> {\n    return Eval.always(thunk)\n  }\n\n  /**\n   * Lifts a value into the `Eval` context.\n   *\n   * Alias for {@link Eval.now}.\n   */\n  static pure<A>(value: A): Eval<A> { return Eval.now(value) }\n\n  /**\n   * Returns an `Eval` that on execution is always successful,\n   * emitting the given strict value.\n   */\n  static now<A>(value: A): Eval<A> { return new Now(value) }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Eval<void> {\n    return evalUnitRef\n  }\n\n  /**\n   * Returns an `Eval` that on execution is always finishing in error\n   * emitting the specified exception.\n   */\n  static raise(e: any): Eval<never> { return new Raise(e) }\n\n  /**\n   * Promote a `thunk` function to an `Eval`, catching exceptions in\n   * the process.\n   *\n   * Note that since `Eval` is not memoized by global, this will\n   * recompute the value each time the `Eval` is executed.\n   */\n  static always<A>(thunk: () => A): Eval<A> {\n    return new Always(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function to a `Coeval` that is memoized on the\n   * first evaluation, the result being then available on subsequent\n   * evaluations.\n   *\n   * Note this is equivalent with:\n   *\n   * ```typescript\n   * Eval.always(thunk).memoize()\n   * ```\n   */\n  static once<A>(thunk: () => A): Eval<A> {\n    return new Once(thunk, false)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   */\n  static suspend<A>(thunk: () => Eval<A>): Eval<A> {\n    return new Suspend(thunk)\n  }\n\n  /**\n   * Promote a `thunk` function generating `Eval` results to an `Eval`\n   * of the same type.\n   *\n   * Alias for {@link Eval.suspend}.\n   */\n  static defer<A>(thunk: () => Eval<A>): Eval<A> {\n    return Eval.suspend(thunk)\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in {@link FlatMap.tailRecM}.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Eval<Either<A, B>>): Eval<B> {\n    try {\n      return f(a).flatMap(either => {\n        if (either.isRight()) {\n          return Eval.now(either.get())\n        } else {\n          // Recursive call\n          return Eval.tailRecM(either.swap().get(), f)\n        }\n      })\n    } catch (e) {\n      return Eval.raise(e)\n    }\n  }\n}\n\n/**\n * `Now` is an internal `Eval` state that wraps any strict\n * value in an `Eval` reference. Returned by [[Eval.now]].\n *\n * @private\n */\nclass Now<A> extends Eval<A> {\n  /**\n   * @param value is the value that's going to be returned\n   * when `get()` is called.\n   */\n  constructor(public value: A) { super() }\n\n  get(): A { return this.value }\n  run(): Try<A> { return Try.success(this.value) }\n  toString(): string { return `Eval.now(${JSON.stringify(this.value)})` }\n}\n\n/**\n * Reusable reference, to use in {@link Eval.unit}.\n *\n * @private\n */\nconst evalUnitRef: Now<void> = new Now(undefined)\n\n/**\n * `Raise` is an internal `Eval` state that wraps any error / failure\n * value in an `Eval` reference. Returned by [[Eval.raise]].\n *\n * @private\n */\nclass Raise extends Eval<never> {\n  /**\n   * @param error is the error value that's going to be\n   * throw when `get()` is called.\n   */\n  constructor(public error: any) { super() }\n\n  get(): never { throw this.error }\n  run(): Try<never> { return Try.failure<never>(this.error) }\n  toString(): string { return `Eval.raise(${JSON.stringify(this.error)})` }\n}\n\n/**\n * `Once` is an internal `Eval` state that executes the given `thunk`\n * only once, upon calling `get()` and then memoize its result for\n * subsequent invocations.\n *\n * Returned by [[Eval.once]].\n *\n * @private\n */\nclass Once<A> extends Eval<A> {\n  private _thunk: () => A\n  public cache: Try<A>\n  public onlyOnSuccess: boolean\n\n  constructor(thunk: () => A, onlyOnSuccess: boolean) {\n    super()\n    this._thunk = thunk\n    this.onlyOnSuccess = onlyOnSuccess\n  }\n\n  run(): Try<A> {\n    if (this._thunk) {\n      const result = Try.of(this._thunk)\n      if (result.isSuccess() || !this.onlyOnSuccess) {\n        // GC purposes\n        delete this._thunk\n        delete this.onlyOnSuccess\n        this.cache = result\n      }\n      return result\n    }\n    return this.cache\n  }\n\n  toString(): string { return `Eval.once([thunk])` }\n}\n\n/**\n * `Always` is an internal `Eval` state that executes the given `thunk`\n * every time the call to `get()` happens. Returned by [[Eval.always]].\n *\n * @private\n */\nclass Always<A> extends Eval<A> {\n  constructor(public thunk: () => A) { super() }\n  run(): Try<A> { return Try.of(this.thunk) }\n\n  toString(): string { return `Eval.always([thunk])` }\n}\n\n/**\n * `Suspend` is an internal `Eval` state that represents a factory of\n * `Eval` values. Returned by [[Eval.suspend]].\n *\n * @private\n */\nclass Suspend<A> extends Eval<A> {\n  constructor(public thunk: () => Eval<A>) { super() }\n  toString(): string { return `Eval.suspend([thunk])` }\n}\n\n/**\n * `FlatMap` is an internal `Eval` state that represents a\n * [[Eval.flatMap .flatMap]], [[Eval.map .map]], [[Eval.transform .transform]]\n * or a [[Eval.transformWith .transformWith]] operation, all of them\n * being expressed with this state.\n *\n * @private\n */\nclass FlatMap<A, B> extends Eval<B> {\n  constructor(\n    public source: Eval<A>,\n    public f: (a: A) => Eval<B>) { super() }\n\n  toString(): string {\n    return `Eval#FlatMap(${String(this.source)}, [function])`\n  }\n}\n\n/** @hidden */\ninterface Handler<A, R> {\n  (a: A): R\n}\n\n/** @hidden */\ninterface FailureHandler<A, R> extends Handler<A, R> {\n  onFailure(e: any): R\n}\n\n/** @hidden */\ntype Current = Eval<any>\n/** @hidden */\ntype Bind = ((a: any) => Eval<any>)\n/** @hidden */\ntype CallStack = Array<Bind>\n\n/** @hidden */\nfunction _popNextBind(bFirst: Bind | null, bRest: CallStack | null): Bind | undefined | null {\n  if (bFirst) return bFirst\n  if (bRest && bRest.length > 0) return bRest.pop()\n  return null\n}\n\n/** @hidden */\nfunction _findErrorHandler(bFirst: Bind | null, bRest: CallStack | null): FailureHandler<any, Eval<any>> | undefined | null {\n  let cursor: any = bFirst\n\n  while (true) {\n    if (cursor && typeof cursor.onFailure === \"function\") return cursor\n    if (bRest && bRest.length > 0) cursor = bRest.pop()\n    else return null\n  }\n}\n\n/** @hidden */\nfunction evalRunLoop<A>(start: Eval<A>): Try<A> {\n  let current: Current = start\n  let bFirst: Bind | null = null\n  let bRest: CallStack | null = null\n\n  while (true) {\n    if (current instanceof Now) {\n      const bind = _popNextBind(bFirst, bRest)\n      if (!bind) return Try.success(current.value)\n      bFirst = null\n      try {\n        current = bind(current.value)\n      } catch (e) {\n        current = new Raise(e)\n      }\n    } else if (current instanceof Always) {\n      try {\n        current = new Now(current.thunk())\n      } catch (e) {\n        current = new Raise(e)\n      }\n    } else if (current instanceof Once) {\n      try {\n        current = new Now(current.get())\n      } catch (e) {\n        current = new Raise(e)\n      }\n    } else if (current instanceof Suspend) {\n      try {\n        current = current.thunk()\n      } catch (e) {\n        current = new Raise(e)\n      }\n    } else if (current instanceof FlatMap) {\n      if (bFirst) {\n        if (!bRest) bRest = []\n        bRest.push(bFirst)\n      }\n      bFirst = current.f\n      current = current.source\n    } else if (current instanceof Raise) {\n      const bind = _findErrorHandler(bFirst, bRest)\n      if (!bind) return Try.failure<never>(current.error)\n      bFirst = null\n      try {\n        current = bind.onFailure(current.error)\n      } catch (e) {\n        current = new Raise(e)\n      }\n    } else {\n      /* istanbul ignore next */\n      throw new IllegalStateError(\n        \"Types got screwed, Eval is a sealed trait, inheritance is forbidden\")\n    }\n  }\n}\n","/*\n * Copyright (c) 2017 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Defines standard instances for types in [core]{@link \"core/index\"}.\n *\n * À la carte imports work, assuming an ECMAScript 2015 compatible environment,\n * including ES2015 modules and `import` syntax:\n *\n * ```typescript\n * import { OptionInstances } from \"funfix/dist/types/instances\"\n * // ... or ...\n * import { OptionInstances } from \"funfix\"\n * ```\n *\n * In absence of ES2015 compatibility, you can still rely on working with the\n * packaged (`pkg.main`) universal distribution that works within all browsers\n * and environments.\n *\n * @module types/instances\n */\n\n/***/\nimport { applyMixins } from \"../core/std\"\nimport { Try, Success, Option, Some, Either, Right } from \"../core/disjunctions\"\nimport { Eval } from \"../effect/eval\"\nimport { Future } from \"../exec/future\"\nimport { HK, registerTypeClassInstance } from \"./kinds\"\nimport { Monad, MonadError } from \"./monad\"\nimport { Eq } from \"./eq\"\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type OptionK<A> = HK<Option<any>, A>\n\n/**\n * Type class instances provided by default for [[Option]].\n */\nexport class OptionInstances implements Monad<Option<any>>, Eq<Option<any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Option<void> = Some(undefined)\n\n  eqv(lh: Option<any>, rh: Option<any>): boolean {\n    return lh.equals(rh)\n  }\n\n  pure<A>(a: A): Option<A> {\n    return Some(a)\n  }\n\n  unit(): Option<void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: OptionK<A>, ff: OptionK<(a: A) => B>): Option<B> {\n    return Option.map2(fa as Option<A>, ff as Option<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: OptionK<A>, f: (a: A) => B): Option<B> {\n    return (fa as Option<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: OptionK<A>, fb: OptionK<B>, f: (a: A, b: B) => Z): Option<Z> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, f)\n  }\n\n  product<A, B>(fa: OptionK<A>, fb: OptionK<B>): Option<[A, B]> {\n    return Option.map2(fa as Option<A>, fb as Option<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: OptionK<A>, f: (a: A) => OptionK<B>): Option<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => OptionK<Either<A, B>>): Option<B> {\n    return Option.tailRecM(a, f as any) as any\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<B>\n  followedByL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<B>\n  forEffect: <A, B>(fa: OptionK<A>, fb: OptionK<B>) => Option<A>\n  forEffectL: <A, B>(fa: OptionK<A>, fb: () => OptionK<B>) => Option<A>\n\n  static readonly global: OptionInstances =\n    new OptionInstances()\n}\n\n// Mixins the default implementations\napplyMixins(OptionInstances, [Monad])\n\n// Registering `OptionInstances` as global instances for Option\nregisterTypeClassInstance(Eq)(Option, OptionInstances.global)\nregisterTypeClassInstance(Monad)(Option, OptionInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type TryK<A> = HK<Try<any>, A>\n\n/**\n * Type class instances provided by default for [[Option]].\n */\nexport class TryInstances implements MonadError<Try<any>, any>, Eq<Try<any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Try<void> = Success(undefined)\n\n  eqv(lh: Try<any>, rh: Try<any>): boolean {\n    return lh.equals(rh)\n  }\n\n  pure<A>(a: A): Try<A> {\n    return Success(a)\n  }\n\n  unit(): Try<void> {\n    return Try.unit()\n  }\n\n  ap<A, B>(fa: TryK<A>, ff: TryK<(a: A) => B>): Try<B> {\n    return Try.map2(fa as Try<A>, ff as Try<(a: A) => B>, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: TryK<A>, f: (a: A) => B): Try<B> {\n    return (fa as Try<A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: TryK<A>, fb: TryK<B>, f: (a: A, b: B) => Z): Try<Z> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, f)\n  }\n\n  product<A, B>(fa: TryK<A>, fb: TryK<B>): Try<[A, B]> {\n    return Try.map2(fa as Try<A>, fb as Try<B>, (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: TryK<A>, f: (a: A) => TryK<B>): Try<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => TryK<Either<A, B>>): Try<B> {\n    return Try.tailRecM(a, f as any) as any\n  }\n\n  raise<A>(e: any): Try<A> {\n    return Try.failure<A>(e)\n  }\n\n  attempt<A>(fa: TryK<A>): Try<Either<any, A>> {\n    return Try.success((fa as Try<A>).fold(\n      e => Either.left<any, A>(e),\n      Either.right\n    ))\n  }\n\n  recoverWith<A>(fa: TryK<A>, f: (e: any) => TryK<A>): Try<A> {\n    return (fa as Try<A>).recoverWith(f as ((e: any) => Try<A>))\n  }\n\n  recover<A>(fa: TryK<A>, f: (e: any) => A): Try<A> {\n    return (fa as Try<A>).recover(f as ((e: any) => A))\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<B>\n  followedByL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<B>\n  forEffect: <A, B>(fa: TryK<A>, fb: TryK<B>) => Try<A>\n  forEffectL: <A, B>(fa: TryK<A>, fb: () => TryK<B>) => Try<A>\n\n  static global: TryInstances =\n    new TryInstances()\n}\n\n// Mixins the default implementations\napplyMixins(TryInstances, [MonadError])\n\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Try, TryInstances.global)\nregisterTypeClassInstance(MonadError)(Try, TryInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EitherK<L, R> = HK<Either<L, any>, R>\n\n/**\n * Type class instances provided by default for [[Either]].\n */\nexport class EitherInstances<L> implements Monad<Either<L, any>>, Eq<Either<L, any>> {\n  // tslint:disable-next-line:variable-name\n  private __unit: Either<L, void> = Right(undefined)\n\n  eqv(lh: Either<L, any>, rh: Either<L, any>): boolean {\n    return ((lh as any) as Either<L, any>).equals(rh as any)\n  }\n\n  pure<A>(a: A): Either<L, A> {\n    return Right(a)\n  }\n\n  unit(): Either<L, void> {\n    return this.__unit\n  }\n\n  ap<A, B>(fa: EitherK<L, A>, ff: EitherK<L, (a: A) => B>): Either<L, B> {\n    const faE = (fa as any) as Either<L, A>\n    const ffE = (ff as any) as Either<L, (a: A) => B>\n    return Either.map2(faE, ffE, (a, f) => f(a))\n  }\n\n  map<A, B>(fa: EitherK<L, A>, f: (a: A) => B): Either<L, B> {\n    return ((fa as any) as Either<L, A>).map(f)\n  }\n\n  map2<A, B, Z>(fa: EitherK<L, A>, fb: EitherK<L, B>, f: (a: A, b: B) => Z): Either<L, Z> {\n    return Either.map2((fa as any) as Either<L, A>, (fb as any) as Either<L, B>, f)\n  }\n\n  product<A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>): Either<L, [A, B]> {\n    return Either.map2(\n      (fa as any) as Either<L, A>,\n      (fb as any) as Either<L, B>,\n      (a, b) => [a, b] as [A, B])\n  }\n\n  flatMap<A, B>(fa: HK<Either<L, any>, A>, f: (a: A) => HK<Either<L, any>, B>): HK<Either<L, any>, B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => HK<Either<L, any>, Either<A, B>>): HK<Either<L, any>, B> {\n    return Either.tailRecM(a, f as any) as any\n  }\n\n  // Mixed-in\n  followedBy: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, B>\n  followedByL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, B>\n  forEffect: <A, B>(fa: EitherK<L, A>, fb: EitherK<L, B>) => Either<L, A>\n  forEffectL: <A, B>(fa: EitherK<L, A>, fb: () => EitherK<L, B>) => Either<L, A>\n\n  static global: EitherInstances<any> =\n    new EitherInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EitherInstances, [Monad])\n// Registering `TryInstances` as global instances for Try\nregisterTypeClassInstance(Eq)(Either, EitherInstances.global)\nregisterTypeClassInstance(Monad)(Either, EitherInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type EvalK<A> = HK<Eval<any>, A>\n\n/**\n * Type class instances provided by default for [[Eval]].\n */\nexport class EvalInstances implements MonadError<Eval<any>, any> {\n  pure<A>(a: A): Eval<A> {\n    return Eval.now(a)\n  }\n\n  flatMap<A, B>(fa: EvalK<A>, f: (a: A) => EvalK<B>): Eval<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => EvalK<Either<A, B>>): Eval<B> {\n    return Eval.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: EvalK<A>, ff: EvalK<(a: A) => B>): Eval<B> {\n    return (fa as Eval<A>).flatMap(a =>\n      (ff as Eval<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: EvalK<A>, f: (a: A) => B): Eval<B> {\n    return (fa as Eval<A>).map(f)\n  }\n\n  unit(): Eval<void> {\n    return Eval.unit()\n  }\n\n  raise<A>(e: any): Eval<A> {\n    return Eval.raise(e)\n  }\n\n  attempt<A>(fa: EvalK<A>): Eval<Either<any, A>> {\n    return (fa as Eval<A>).attempt()\n  }\n\n  recoverWith<A>(fa: EvalK<A>, f: (e: any) => EvalK<A>): Eval<A> {\n    return (fa as Eval<A>).recoverWith(f as ((e: any) => Eval<A>))\n  }\n\n  recover<A>(fa: EvalK<A>, f: (e: any) => A): Eval<A> {\n    return (fa as Eval<A>).recover(f as ((e: any) => A))\n  }\n\n  // Mixed-in\n  map2: <A, B, Z>(fa: EvalK<A>, fb: EvalK<B>, f: (a: A, b: B) => Z) => Eval<Z>\n  product: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => EvalK<[A, B]>\n  followedBy: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<B>\n  followedByL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<B>\n  forEffect: <A, B>(fa: EvalK<A>, fb: EvalK<B>) => Eval<A>\n  forEffectL: <A, B>(fa: EvalK<A>, fb: () => EvalK<B>) => Eval<A>\n\n  static global: EvalInstances =\n    new EvalInstances()\n}\n\n// Mixins the default implementations\napplyMixins(EvalInstances, [MonadError])\n// Registering `EvalInstances` as global instances for `Eval`\nregisterTypeClassInstance(MonadError)(Eval, EvalInstances.global)\n\n/**\n * Alias used for encoding higher-kinded types when implementing\n * type class instances.\n */\nexport type FutureK<A> = HK<Future<any>, A>\n\n/**\n * Type class instances provided by default for {@link Future}.\n */\nexport class FutureInstances implements MonadError<Future<any>, any> {\n  pure<A>(a: A): Future<A> {\n    return Future.pure(a)\n  }\n\n  flatMap<A, B>(fa: FutureK<A>, f: (a: A) => FutureK<B>): Future<B> {\n    return (fa as any).flatMap(f)\n  }\n\n  tailRecM<A, B>(a: A, f: (a: A) => FutureK<Either<A, B>>): Future<B> {\n    return Future.tailRecM(a, f as any) as any\n  }\n\n  ap<A, B>(fa: FutureK<A>, ff: FutureK<(a: A) => B>): Future<B> {\n    return (fa as Future<A>).flatMap(a =>\n      (ff as Future<(a: A) => B>).map(f => f(a))\n    )\n  }\n\n  map<A, B>(fa: FutureK<A>, f: (a: A) => B): Future<B> {\n    return (fa as Future<A>).map(f)\n  }\n\n  unit(): Future<void> {\n    return Future.unit()\n  }\n\n  raise<A>(e: any): Future<A> {\n    return Future.raise(e)\n  }\n\n  attempt<A>(fa: FutureK<A>): Future<Either<any, A>> {\n    return (fa as Future<A>).attempt()\n  }\n\n  recoverWith<A>(fa: FutureK<A>, f: (e: any) => FutureK<A>): Future<A> {\n    return (fa as Future<A>).recoverWith(f as ((e: any) => Future<A>))\n  }\n\n  recover<A>(fa: FutureK<A>, f: (e: any) => A): Future<A> {\n    return (fa as Future<A>).recover(f as ((e: any) => A))\n  }\n\n  map2<A, B, Z>(fa: FutureK<A>, fb: FutureK<B>, f: (a: A, b: B) => Z): Future<Z> {\n    return Future.map2(fa as any, fb as any, f as any)\n  }\n\n  // Mixed-in\n  product: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => FutureK<[A, B]>\n  followedBy: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<B>\n  followedByL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<B>\n  forEffect: <A, B>(fa: FutureK<A>, fb: FutureK<B>) => Future<A>\n  forEffectL: <A, B>(fa: FutureK<A>, fb: () => FutureK<B>) => Future<A>\n\n  static global: FutureInstances =\n    new FutureInstances()\n}\n\n// Mixins the default implementations\napplyMixins(FutureInstances, [MonadError])\n// Registering `FutureInstances` as global instances for `Future`\nregisterTypeClassInstance(MonadError)(Future, FutureInstances.global)\n"],"names":["ref","equals","hashCode","lh","rh","valueOf","lh2","rh2","isValueObject","is","v","hashCodeOfString","String","str","hash","length","i","character","charCodeAt","a","derivedCtor","baseCtors","forEach","getOwnPropertyNames","baseCtor","prototype","name","errors","reasons","slice","e","message","Error","errorsRef","_leftRef","_rightRef","_isRight","NoSuchElementError","elem","std","p","zero","right","Left","left","f","fallback","thunk","Right","cb","Option","some","none","other","value","fa1","fa2","isLeft","fa3","fa4","fa5","fa6","cursor","result","get","isRight","swap","Either","isEmpty","_isEmpty","undefined","_ref","None","Some","of","flatMap","that","nonEmpty","l","r","F","_success","_failure","_isSuccess","_successRef","_failureRef","Failure","Success","failure","success","Try","tryUnitRef","isFailure","WrapFn","Empty","refs","CollectionCancelable","Cancelable","BoolWrapFn","BoolEmpty","AlreadyCanceled","_refs","_isCanceled","c","cancel","push","CompositeError","BoolCancelable","canceled","AlreadyCanceledAssignable","MultiAssignCancelable","empty","AssignCancelable","initial","_underlying","_canceled","SerialCancelable","_wasAssigned","IllegalStateError","SingleAssignCancelable","update","label","toUpperCase","C0","C1","C2","C3","C4","C5","C6","MIN","MAX","trunc","Math","x","isNaN","NaN","floor","ceil","d","m","over","duration","unit","toNanos","TimeUnit","NANOSECONDS","Nanoseconds","toMicros","MICROSECONDS","Microseconds","toMillis","MILLISECONDS","Milliseconds","toSeconds","SECONDS","Seconds","toMinutes","MINUTES","Minutes","toHours","HOURS","Hours","toDays","DAYS","Days","IllegalArgumentError","isFinite","convert","Duration","Infinity","negInf","inf","d1","d2","ord","convertTo","plus","negate","s","o","n","cmp","millis","fn","bindL","oldFn","DynamicRef","array","minIndex","maxIndex","index","current","next","search","values","Object","toString","call","Symbol","iterator","arr","item","done","initialDelay","delay","runnable","loop","self","delayNow","scheduleOnce","task","period","delayNowMs","periodMs","startAt","currentTimeMillis","elapsedMs","nextDelayMs","max","Scheduler","globalSchedulerRef","parent","_isActive","_queue","_parent","runLoop","reportFailure","pop","canUseSetImmediate","_trampoline","Trampoline","_useSetImmediate","setImmediate","safeRunnable","setTimeout","execute","error","Date","now","ms","clearTimeout","reporter","_reporter","_clock","_triggeredFailures","_updateTasks","_tasks","scheduleAt","insertAt","_tasksSearch","splice","filtered","toExecute","jumpMs","executed","peek","random","nextTaskJump","add","min","tasks","arrayBSearchInsertPos","GlobalScheduler","transformWith","Future","pure","transform","raise","onFulfilled","onRejected","promiseThen","Promise","resolve","reject","onComplete","_","fold","delayedTick","_scheduler","err","map","after","fb","TimeoutError","timeoutTo","lst","firstCompletedOf","ec","global","FutureBuilder","executeAsync","PureFuture","register","futureUnit","create","tailRecM","withScheduler","then","list","futureFirstCompletedOf","parallelism","futureTraverse","futureSequence","fl","sequence","_value","trampoline","genericTransformWith","_result","_listeners","complete","listeners","_cancelable","scheduler","cancelable","cRef","tryA","fbb","collapse","clear","alt","fromPromise","skip","futures","futureIterableToArray","futureCancelAll","isDone","finishedCount","finalArray","fi","fa","isSuccess","failed","iterable","iterableToArray","futureTraverseLoop","batch","b","Equiv","tc","instance","obj","types","_funTypes","existing","_funTypeId","constructor","_funSupertypeIds","id","NotImplementedError","Eq","eqv","y","z","eqOf","getTypeClassInstance","EqLaws","Functor","g","functorOf","FunctorLaws","ap","map2","Apply","applyMixins","fab","fbc","compose","product","ApplyLaws","applyOf","Applicative","ff","ApplicativeLaws","applicativeOf","recoverWith","recover","ApplicativeError","attempt","ApplicativeErrorLaws","applicativeErrorOf","FlatMap","followedBy","followedByL","forEffect","forEffectL","bounce","a0","a1","FlatMapLaws","flatMapOf","Monad","res","MonadLaws","monadOf","MonadError","MonadErrorLaws","monadErrorOf","run","evalRunLoop","getOrElse","getOrElseL","Eval","onFailure","Now","Raise","Once","Always","forEachL","always","evalUnitRef","Suspend","suspend","either","JSON","stringify","onlyOnSuccess","_thunk","cache","source","bFirst","bRest","start","bind","_popNextBind","_findErrorHandler","__unit","OptionInstances","registerTypeClassInstance","TryInstances","faE","ffE","EitherInstances","EvalInstances","FutureInstances"],"mappings":"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"}