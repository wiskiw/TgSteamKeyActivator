(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.funfix = {})));
}(this, (function (exports) { 'use strict';

function isValueObject(ref) {
    return !!(ref && typeof ref.equals === "function" && typeof ref.hashCode === "function");
}

function is(lh, rh) {
    if (lh === rh || lh !== lh && rh !== rh) {
        return true;
    }
    if (!lh || !rh) {
        return false;
    }

    if (typeof lh.valueOf === "function" && typeof rh.valueOf === "function") {
        var lh2 = lh.valueOf();
        var rh2 = rh.valueOf();
        if (lh2 === rh2 || lh2 !== lh2 && rh2 !== rh2) {
            return true;
        }
        if (!lh2 || !rh2) {
            return false;
        }
    }

    return !!(isValueObject(lh) && lh.equals(rh));
}

function equals(lh, rh) {
    return is(lh, rh);
}

function hashCode(ref) {
    if (typeof ref === "number") {
        return ref & ref;
    }

    if (typeof ref.valueOf === "function") {
        var v = ref.valueOf();
        if (v !== ref) return hashCode(v);
    }
    if (isValueObject(ref)) {
        return ref.hashCode();
    }
    return hashCodeOfString(String(ref));
}

function hashCodeOfString(str) {
    var hash = 0;

    if (str == null || str.length === 0) return hash;
    for (var i = 0; i < str.length; i++) {
        var character = str.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash = hash & hash;
    }
    return hash;
}

function id(a) {
    return a;
}

function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
            if (!derivedCtor.prototype[name]) derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var CompositeError = function (_Error) {
    inherits(CompositeError, _Error);

    function CompositeError(errors) {
        classCallCheck(this, CompositeError);

        var reasons = "";
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = errors.slice(0, 2)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var e = _step.value;

                var message = "";
                if (e instanceof Error) {
                    message = e.name + "(" + e.message + ")";
                } else {
                    message = "" + e;
                }
                reasons += ", " + message;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        reasons = reasons.slice(2);
        if (errors.length > 2) reasons = reasons + ", ...";

        var _this = possibleConstructorReturn(this, (CompositeError.__proto__ || Object.getPrototypeOf(CompositeError)).call(this, reasons));

        _this.name = "CompositeError";
        _this.errorsRef = errors;
        return _this;
    }

    createClass(CompositeError, [{
        key: "errors",
        value: function errors() {
            return this.errorsRef.slice();
        }
    }]);
    return CompositeError;
}(Error);

var DummyError = function (_Error2) {
    inherits(DummyError, _Error2);

    function DummyError(message) {
        classCallCheck(this, DummyError);

        var _this2 = possibleConstructorReturn(this, (DummyError.__proto__ || Object.getPrototypeOf(DummyError)).call(this, message));

        _this2.name = "DummyError";
        return _this2;
    }

    return DummyError;
}(Error);

var NoSuchElementError = function (_Error3) {
    inherits(NoSuchElementError, _Error3);

    function NoSuchElementError(message) {
        classCallCheck(this, NoSuchElementError);

        var _this3 = possibleConstructorReturn(this, (NoSuchElementError.__proto__ || Object.getPrototypeOf(NoSuchElementError)).call(this, message));

        _this3.name = "NoSuchElementError";
        return _this3;
    }

    return NoSuchElementError;
}(Error);

var IllegalInheritanceError = function (_Error4) {
    inherits(IllegalInheritanceError, _Error4);

    function IllegalInheritanceError(message) {
        classCallCheck(this, IllegalInheritanceError);

        var _this4 = possibleConstructorReturn(this, (IllegalInheritanceError.__proto__ || Object.getPrototypeOf(IllegalInheritanceError)).call(this, message));

        _this4.name = "IllegalInheritanceError";
        return _this4;
    }

    return IllegalInheritanceError;
}(Error);

var IllegalStateError = function (_Error5) {
    inherits(IllegalStateError, _Error5);

    function IllegalStateError(message) {
        classCallCheck(this, IllegalStateError);

        var _this5 = possibleConstructorReturn(this, (IllegalStateError.__proto__ || Object.getPrototypeOf(IllegalStateError)).call(this, message));

        _this5.name = "IllegalStateError";
        return _this5;
    }

    return IllegalStateError;
}(Error);

var IllegalArgumentError = function (_Error6) {
    inherits(IllegalArgumentError, _Error6);

    function IllegalArgumentError(message) {
        classCallCheck(this, IllegalArgumentError);

        var _this6 = possibleConstructorReturn(this, (IllegalArgumentError.__proto__ || Object.getPrototypeOf(IllegalArgumentError)).call(this, message));

        _this6.name = "IllegalArgumentError";
        return _this6;
    }

    return IllegalArgumentError;
}(Error);

var NotImplementedError = function (_Error7) {
    inherits(NotImplementedError, _Error7);

    function NotImplementedError(message) {
        classCallCheck(this, NotImplementedError);

        var _this7 = possibleConstructorReturn(this, (NotImplementedError.__proto__ || Object.getPrototypeOf(NotImplementedError)).call(this, message));

        _this7.name = "NotImplementedError";
        return _this7;
    }

    return NotImplementedError;
}(Error);

var TimeoutError = function (_Error8) {
    inherits(TimeoutError, _Error8);

    function TimeoutError(message) {
        classCallCheck(this, TimeoutError);

        var _this8 = possibleConstructorReturn(this, (TimeoutError.__proto__ || Object.getPrototypeOf(TimeoutError)).call(this, message));

        _this8.name = "TimeoutError";
        return _this8;
    }

    return TimeoutError;
}(Error);

var Either = function () {
    function Either(_leftRef, _rightRef, _isRight) {
        classCallCheck(this, Either);

        this._isRight = _isRight;
        if (_isRight) this._rightRef = _rightRef;else this._leftRef = _leftRef;
    }

    createClass(Either, [{
        key: "isLeft",
        value: function isLeft() {
            return !this._isRight;
        }
    }, {
        key: "left",
        value: function left() {
            if (!this._isRight) return this;
            throw new NoSuchElementError("either.left");
        }
    }, {
        key: "isRight",
        value: function isRight() {
            return this._isRight;
        }
    }, {
        key: "right",
        value: function right() {
            if (this._isRight) return this;
            throw new NoSuchElementError("either.right");
        }
    }, {
        key: "contains",
        value: function contains(elem) {
            return this._isRight && is(this._rightRef, elem);
        }
    }, {
        key: "exists",
        value: function exists(p) {
            return this._isRight && p(this._rightRef);
        }
    }, {
        key: "filterOrElse",
        value: function filterOrElse(p, zero) {
            return this._isRight ? p(this._rightRef) ? this.right() : Left(zero()) : this.left();
        }
    }, {
        key: "flatMap",
        value: function flatMap(f) {
            return this._isRight ? f(this._rightRef) : this.left();
        }
    }, {
        key: "fold",
        value: function fold(left, right) {
            return this._isRight ? right(this._rightRef) : left(this._leftRef);
        }
    }, {
        key: "forAll",
        value: function forAll(p) {
            return !this._isRight || p(this._rightRef);
        }
    }, {
        key: "get",
        value: function get$$1() {
            if (this._isRight) return this._rightRef;
            throw new NoSuchElementError("left.get()");
        }
    }, {
        key: "getOrElse",
        value: function getOrElse(fallback) {
            return this._isRight ? this._rightRef : fallback;
        }
    }, {
        key: "getOrElseL",
        value: function getOrElseL(thunk) {
            return this._isRight ? this._rightRef : thunk();
        }
    }, {
        key: "map",
        value: function map(f) {
            return this._isRight ? Right(f(this._rightRef)) : this.left();
        }
    }, {
        key: "forEach",
        value: function forEach(cb) {
            if (this._isRight) cb(this._rightRef);
        }
    }, {
        key: "swap",
        value: function swap() {
            return this._isRight ? Left(this._rightRef) : Right(this._leftRef);
        }
    }, {
        key: "toOption",
        value: function toOption() {
            return this._isRight ? Option.some(this._rightRef) : Option.none();
        }
    }, {
        key: "equals",
        value: function equals$$1(other) {
            if (other == null) return false;
            if (this._isRight) return is(this._rightRef, other._rightRef);
            return is(this._leftRef, other._leftRef);
        }
    }, {
        key: "hashCode",
        value: function hashCode$$1() {
            return this._isRight ? hashCode(this._rightRef) << 2 : hashCode(this._leftRef) << 3;
        }
    }], [{
        key: "left",
        value: function left(value) {
            return Left(value);
        }
    }, {
        key: "right",
        value: function right(value) {
            return Right(value);
        }
    }, {
        key: "map2",
        value: function map2(fa1, fa2, f) {
            if (fa1.isLeft()) return fa1;
            if (fa2.isLeft()) return fa2;
            return Right(f(fa1._rightRef, fa2._rightRef));
        }
    }, {
        key: "map3",
        value: function map3(fa1, fa2, fa3, f) {
            if (fa1.isLeft()) return fa1;
            if (fa2.isLeft()) return fa2;
            if (fa3.isLeft()) return fa3;
            return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef));
        }
    }, {
        key: "map4",
        value: function map4(fa1, fa2, fa3, fa4, f) {
            if (fa1.isLeft()) return fa1;
            if (fa2.isLeft()) return fa2;
            if (fa3.isLeft()) return fa3;
            if (fa4.isLeft()) return fa4;
            return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef));
        }
    }, {
        key: "map5",
        value: function map5(fa1, fa2, fa3, fa4, fa5, f) {
            if (fa1.isLeft()) return fa1;
            if (fa2.isLeft()) return fa2;
            if (fa3.isLeft()) return fa3;
            if (fa4.isLeft()) return fa4;
            if (fa5.isLeft()) return fa5;
            return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef));
        }
    }, {
        key: "map6",
        value: function map6(fa1, fa2, fa3, fa4, fa5, fa6, f) {
            if (fa1.isLeft()) return fa1;
            if (fa2.isLeft()) return fa2;
            if (fa3.isLeft()) return fa3;
            if (fa4.isLeft()) return fa4;
            if (fa5.isLeft()) return fa5;
            if (fa6.isLeft()) return fa6;
            return Right(f(fa1._rightRef, fa2._rightRef, fa3._rightRef, fa4._rightRef, fa5._rightRef, fa6._rightRef));
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            var cursor = a;
            while (true) {
                var result = f(cursor);
                if (result.isLeft()) return result;
                var some = result.get();
                if (some.isRight()) return Right(some.get());
                cursor = some.swap().get();
            }
        }
    }]);
    return Either;
}();

function Left(value) {
    return new Either(value, null, false);
}

function Right(value) {
    return new Either(null, value, true);
}

var Option = function () {
    function Option(ref, isEmpty) {
        classCallCheck(this, Option);

        this._isEmpty = isEmpty != null ? isEmpty : ref === null || ref === undefined;
        this._ref = ref;
    }

    createClass(Option, [{
        key: "get",
        value: function get$$1() {
            if (!this._isEmpty) return this._ref;else throw new NoSuchElementError("Option.get");
        }
    }, {
        key: "getOrElse",
        value: function getOrElse(fallback) {
            if (!this._isEmpty) return this._ref;else return fallback;
        }
    }, {
        key: "orNull",
        value: function orNull() {
            if (!this._isEmpty) return this._ref;else return null;
        }
    }, {
        key: "getOrElseL",
        value: function getOrElseL(thunk) {
            if (!this._isEmpty) return this._ref;else return thunk();
        }
    }, {
        key: "orElse",
        value: function orElse(fallback) {
            if (!this._isEmpty) return this;else return fallback;
        }
    }, {
        key: "orElseL",
        value: function orElseL(thunk) {
            if (!this._isEmpty) return this;else return thunk();
        }
    }, {
        key: "isEmpty",
        value: function isEmpty() {
            return this._isEmpty;
        }
    }, {
        key: "nonEmpty",
        value: function nonEmpty() {
            return !this._isEmpty;
        }
    }, {
        key: "map",
        value: function map(f) {
            return this._isEmpty ? None : Some(f(this._ref));
        }
    }, {
        key: "mapN",
        value: function mapN(f) {
            return this._isEmpty ? None : Option.of(f(this._ref));
        }
    }, {
        key: "flatMap",
        value: function flatMap(f) {
            if (this._isEmpty) return None;else return f(this._ref);
        }
    }, {
        key: "chain",
        value: function chain(f) {
            return this.flatMap(f);
        }
    }, {
        key: "filter",
        value: function filter(p) {
            if (this._isEmpty || !p(this._ref)) return None;else return this;
        }
    }, {
        key: "fold",
        value: function fold(fallback, f) {
            if (this._isEmpty) return fallback();else return f(this._ref);
        }
    }, {
        key: "contains",
        value: function contains(elem) {
            return !this._isEmpty && is(this._ref, elem);
        }
    }, {
        key: "exists",
        value: function exists(p) {
            return !this._isEmpty && p(this._ref);
        }
    }, {
        key: "forAll",
        value: function forAll(p) {
            return this._isEmpty || p(this._ref);
        }
    }, {
        key: "forEach",
        value: function forEach(cb) {
            if (!this._isEmpty) cb(this._ref);
        }
    }, {
        key: "equals",
        value: function equals$$1(that) {
            if (that == null) return false;
            if (this.nonEmpty() && that.nonEmpty()) {
                var l = this.get();
                var r = that.get();
                return is(l, r);
            }
            return this.isEmpty() && that.isEmpty();
        }
    }, {
        key: "hashCode",
        value: function hashCode$$1() {
            if (this._isEmpty) return 2433880;else if (this._ref == null) return 2433881 << 2;else return hashCode(this._ref) << 2;
        }
    }], [{
        key: "of",
        value: function of(value) {
            return value != null ? Some(value) : None;
        }
    }, {
        key: "some",
        value: function some(value) {
            return new Option(value, false);
        }
    }, {
        key: "none",
        value: function none() {
            return None;
        }
    }, {
        key: "empty",
        value: function empty() {
            return None;
        }
    }, {
        key: "pure",
        value: function pure(value) {
            return Some(value);
        }
    }, {
        key: "map2",
        value: function map2(fa1, fa2, f) {
            return fa1.nonEmpty() && fa2.nonEmpty() ? Some(f(fa1.get(), fa2.get())) : None;
        }
    }, {
        key: "map3",
        value: function map3(fa1, fa2, fa3, f) {
            return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() ? Some(f(fa1.get(), fa2.get(), fa3.get())) : None;
        }
    }, {
        key: "map4",
        value: function map4(fa1, fa2, fa3, fa4, f) {
            return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get())) : None;
        }
    }, {
        key: "map5",
        value: function map5(fa1, fa2, fa3, fa4, fa5, f) {
            return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get())) : None;
        }
    }, {
        key: "map6",
        value: function map6(fa1, fa2, fa3, fa4, fa5, fa6, f) {
            return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() && fa6.nonEmpty() ? Some(f(fa1.get(), fa2.get(), fa3.get(), fa4.get(), fa5.get(), fa6.get())) : None;
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            var cursor = a;
            while (true) {
                var result = f(cursor);
                if (result.isEmpty()) return None;
                var some = result.get();
                if (some.isRight()) return Some(some.get());
                cursor = some.swap().get();
            }
        }
    }]);
    return Option;
}();

function Some(value) {
    return new Option(value, false);
}

var None = function () {
    var F = Option;
    return new F(null, true);
}();

var Try = function () {
    function Try(_success, _failure, _isSuccess) {
        classCallCheck(this, Try);

        this._isSuccess = _isSuccess;
        if (_isSuccess) this._successRef = _success;else this._failureRef = _failure;
    }

    createClass(Try, [{
        key: "isSuccess",
        value: function isSuccess() {
            return this._isSuccess;
        }
    }, {
        key: "isFailure",
        value: function isFailure() {
            return !this._isSuccess;
        }
    }, {
        key: "get",
        value: function get$$1() {
            if (!this._isSuccess) throw this._failureRef;
            return this._successRef;
        }
    }, {
        key: "getOrElse",
        value: function getOrElse(fallback) {
            return this._isSuccess ? this._successRef : fallback;
        }
    }, {
        key: "getOrElseL",
        value: function getOrElseL(thunk) {
            return this._isSuccess ? this._successRef : thunk();
        }
    }, {
        key: "orNull",
        value: function orNull() {
            if (this._isSuccess) return this._successRef;
            return null;
        }
    }, {
        key: "orElse",
        value: function orElse(fallback) {
            if (this._isSuccess) return this;
            return fallback;
        }
    }, {
        key: "orElseL",
        value: function orElseL(thunk) {
            if (this._isSuccess) return this;
            return thunk();
        }
    }, {
        key: "failed",
        value: function failed() {
            return this._isSuccess ? Failure(new NoSuchElementError("try.failed()")) : Success(this._failureRef);
        }
    }, {
        key: "fold",
        value: function fold(failure, success) {
            return this._isSuccess ? success(this._successRef) : failure(this._failureRef);
        }
    }, {
        key: "filter",
        value: function filter(p) {
            if (!this._isSuccess) return this;
            try {
                if (p(this._successRef)) return this;
                return Failure(new NoSuchElementError("Predicate does not hold for " + this._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "flatMap",
        value: function flatMap(f) {
            if (!this._isSuccess) return this;
            try {
                return f(this._successRef);
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "chain",
        value: function chain(f) {
            return this.flatMap(f);
        }
    }, {
        key: "map",
        value: function map(f) {
            var _this = this;

            return this._isSuccess ? Try.of(function () {
                return f(_this._successRef);
            }) : this;
        }
    }, {
        key: "forEach",
        value: function forEach(cb) {
            if (this._isSuccess) cb(this._successRef);
        }
    }, {
        key: "recover",
        value: function recover(f) {
            var _this2 = this;

            return this._isSuccess ? this : Try.of(function () {
                return f(_this2._failureRef);
            });
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(f) {
            try {
                return this._isSuccess ? this : f(this._failureRef);
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "toOption",
        value: function toOption() {
            return this._isSuccess ? Some(this._successRef) : None;
        }
    }, {
        key: "toEither",
        value: function toEither() {
            return this._isSuccess ? Right(this._successRef) : Left(this._failureRef);
        }
    }, {
        key: "equals",
        value: function equals$$1(that) {
            if (that == null) return false;
            return this._isSuccess ? that._isSuccess && is(this._successRef, that._successRef) : !that._isSuccess && is(this._failureRef, that._failureRef);
        }
    }, {
        key: "hashCode",
        value: function hashCode$$1() {
            return this._isSuccess ? hashCode(this._successRef) : hashCode(this._failureRef);
        }
    }], [{
        key: "of",
        value: function of(thunk) {
            try {
                return Success(thunk());
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "pure",
        value: function pure(value) {
            return Try.success(value);
        }
    }, {
        key: "unit",
        value: function unit() {
            return tryUnitRef;
        }
    }, {
        key: "success",
        value: function success(value) {
            return Success(value);
        }
    }, {
        key: "failure",
        value: function failure(e) {
            return Failure(e);
        }
    }, {
        key: "map2",
        value: function map2(fa1, fa2, f) {
            if (fa1.isFailure()) return fa1;
            if (fa2.isFailure()) return fa2;
            try {
                return Success(f(fa1._successRef, fa2._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "map3",
        value: function map3(fa1, fa2, fa3, f) {
            if (fa1.isFailure()) return fa1;
            if (fa2.isFailure()) return fa2;
            if (fa3.isFailure()) return fa3;
            try {
                return Success(f(fa1._successRef, fa2._successRef, fa3._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "map4",
        value: function map4(fa1, fa2, fa3, fa4, f) {
            if (fa1.isFailure()) return fa1;
            if (fa2.isFailure()) return fa2;
            if (fa3.isFailure()) return fa3;
            if (fa4.isFailure()) return fa4;
            try {
                return Success(f(fa1._successRef, fa2._successRef, fa3._successRef, fa4._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "map5",
        value: function map5(fa1, fa2, fa3, fa4, fa5, f) {
            if (fa1.isFailure()) return fa1;
            if (fa2.isFailure()) return fa2;
            if (fa3.isFailure()) return fa3;
            if (fa4.isFailure()) return fa4;
            if (fa5.isFailure()) return fa5;
            try {
                return Success(f(fa1._successRef, fa2._successRef, fa3._successRef, fa4._successRef, fa5._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "map6",
        value: function map6(fa1, fa2, fa3, fa4, fa5, fa6, f) {
            if (fa1.isFailure()) return fa1;
            if (fa2.isFailure()) return fa2;
            if (fa3.isFailure()) return fa3;
            if (fa4.isFailure()) return fa4;
            if (fa5.isFailure()) return fa5;
            if (fa6.isFailure()) return fa6;
            try {
                return Success(f(fa1._successRef, fa2._successRef, fa3._successRef, fa4._successRef, fa5._successRef, fa6._successRef));
            } catch (e) {
                return Failure(e);
            }
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            var cursor = a;
            while (true) {
                try {
                    var result = f(cursor);
                    if (result.isFailure()) return result;
                    var some = result.get();
                    if (some.isRight()) return Success(some.get());
                    cursor = some.swap().get();
                } catch (e) {
                    return Failure(e);
                }
            }
        }
    }]);
    return Try;
}();

function Success(value) {
    return new Try(value, null, true);
}

function Failure(e) {
    return new Try(null, e, false);
}

var tryUnitRef = Success(undefined);

var Cancelable = function () {
    function Cancelable() {
        classCallCheck(this, Cancelable);
    }

    createClass(Cancelable, null, [{
        key: "of",
        value: function of(cb) {
            return new WrapFn(cb);
        }
    }, {
        key: "empty",
        value: function empty() {
            return Empty;
        }
    }, {
        key: "collection",
        value: function collection() {
            for (var _len = arguments.length, refs = Array(_len), _key = 0; _key < _len; _key++) {
                refs[_key] = arguments[_key];
            }

            return new CollectionCancelable(refs);
        }
    }]);
    return Cancelable;
}();

var WrapFn = function (_Cancelable) {
    inherits(WrapFn, _Cancelable);

    function WrapFn(cb) {
        classCallCheck(this, WrapFn);

        var _this = possibleConstructorReturn(this, (WrapFn.__proto__ || Object.getPrototypeOf(WrapFn)).call(this));

        _this.thunk = cb;
        return _this;
    }

    createClass(WrapFn, [{
        key: "cancel",
        value: function cancel() {
            if (this.thunk !== null) {
                var ref = this.thunk;
                this.thunk = null;
                ref();
            }
        }
    }]);
    return WrapFn;
}(Cancelable);

var Empty = new (function (_Cancelable2) {
    inherits(Empty, _Cancelable2);

    function Empty() {
        classCallCheck(this, Empty);
        return possibleConstructorReturn(this, (Empty.__proto__ || Object.getPrototypeOf(Empty)).apply(this, arguments));
    }

    createClass(Empty, [{
        key: "cancel",
        value: function cancel() {}
    }]);
    return Empty;
}(Cancelable))();

var BoolCancelable = function () {
    function BoolCancelable() {
        classCallCheck(this, BoolCancelable);
    }

    createClass(BoolCancelable, null, [{
        key: "of",
        value: function of(cb) {
            return new BoolWrapFn(cb);
        }
    }, {
        key: "empty",
        value: function empty() {
            return new BoolEmpty();
        }
    }, {
        key: "alreadyCanceled",
        value: function alreadyCanceled() {
            return AlreadyCanceled;
        }
    }, {
        key: "collection",
        value: function collection() {
            for (var _len2 = arguments.length, refs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                refs[_key2] = arguments[_key2];
            }

            return new CollectionCancelable(refs);
        }
    }]);
    return BoolCancelable;
}();

var CollectionCancelable = function (_BoolCancelable) {
    inherits(CollectionCancelable, _BoolCancelable);

    function CollectionCancelable(refs) {
        classCallCheck(this, CollectionCancelable);

        var _this3 = possibleConstructorReturn(this, (CollectionCancelable.__proto__ || Object.getPrototypeOf(CollectionCancelable)).call(this));

        _this3._refs = refs;
        _this3._isCanceled = false;
        return _this3;
    }

    createClass(CollectionCancelable, [{
        key: "isCanceled",
        value: function isCanceled() {
            return this._isCanceled;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            if (!this._isCanceled) {
                this._isCanceled = true;
                var errors = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this._refs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var c = _step.value;

                        try {
                            c.cancel();
                        } catch (e) {
                            errors.push(e);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                this._refs = [];
                if (errors.length === 1) throw errors[0];else if (errors.length > 1) throw new CompositeError(errors);
            }
        }
    }]);
    return CollectionCancelable;
}(BoolCancelable);

var BoolWrapFn = function (_WrapFn) {
    inherits(BoolWrapFn, _WrapFn);

    function BoolWrapFn() {
        classCallCheck(this, BoolWrapFn);
        return possibleConstructorReturn(this, (BoolWrapFn.__proto__ || Object.getPrototypeOf(BoolWrapFn)).apply(this, arguments));
    }

    createClass(BoolWrapFn, [{
        key: "isCanceled",
        value: function isCanceled() {
            return this.thunk === null;
        }
    }]);
    return BoolWrapFn;
}(WrapFn);

var BoolEmpty = function (_BoolCancelable2) {
    inherits(BoolEmpty, _BoolCancelable2);

    function BoolEmpty() {
        classCallCheck(this, BoolEmpty);

        var _this5 = possibleConstructorReturn(this, (BoolEmpty.__proto__ || Object.getPrototypeOf(BoolEmpty)).apply(this, arguments));

        _this5.canceled = false;
        return _this5;
    }

    createClass(BoolEmpty, [{
        key: "isCanceled",
        value: function isCanceled() {
            return this.canceled;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            this.canceled = true;
        }
    }]);
    return BoolEmpty;
}(BoolCancelable);

var AlreadyCanceled = new (function (_BoolCancelable3) {
    inherits(AlreadyCanceled, _BoolCancelable3);

    function AlreadyCanceled() {
        classCallCheck(this, AlreadyCanceled);
        return possibleConstructorReturn(this, (AlreadyCanceled.__proto__ || Object.getPrototypeOf(AlreadyCanceled)).apply(this, arguments));
    }

    createClass(AlreadyCanceled, [{
        key: "isCanceled",
        value: function isCanceled() {
            return true;
        }
    }, {
        key: "cancel",
        value: function cancel() {}
    }]);
    return AlreadyCanceled;
}(BoolCancelable))();

var AssignCancelable = function () {
    function AssignCancelable() {
        classCallCheck(this, AssignCancelable);
    }

    createClass(AssignCancelable, null, [{
        key: "alreadyCanceled",
        value: function alreadyCanceled() {
            return AlreadyCanceledAssignable;
        }
    }, {
        key: "empty",
        value: function empty() {
            return MultiAssignCancelable.empty();
        }
    }, {
        key: "of",
        value: function of(cb) {
            return MultiAssignCancelable.of(cb);
        }
    }]);
    return AssignCancelable;
}();

var AlreadyCanceledAssignable = new (function (_AssignCancelable) {
    inherits(AlreadyCanceledAssignable, _AssignCancelable);

    function AlreadyCanceledAssignable() {
        classCallCheck(this, AlreadyCanceledAssignable);
        return possibleConstructorReturn(this, (AlreadyCanceledAssignable.__proto__ || Object.getPrototypeOf(AlreadyCanceledAssignable)).apply(this, arguments));
    }

    createClass(AlreadyCanceledAssignable, [{
        key: "isCanceled",
        value: function isCanceled() {
            return true;
        }
    }, {
        key: "cancel",
        value: function cancel() {}
    }, {
        key: "update",
        value: function update(value) {
            value.cancel();return this;
        }
    }]);
    return AlreadyCanceledAssignable;
}(AssignCancelable))();

var MultiAssignCancelable = function () {
    function MultiAssignCancelable(initial) {
        classCallCheck(this, MultiAssignCancelable);

        this._underlying = initial;
        this._canceled = false;
    }

    createClass(MultiAssignCancelable, [{
        key: "update",
        value: function update(value) {
            if (this._canceled) value.cancel();else this._underlying = value;
            return this;
        }
    }, {
        key: "isCanceled",
        value: function isCanceled() {
            return this._canceled;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            if (!this._canceled) {
                this._canceled = true;
                if (this._underlying) {
                    this._underlying.cancel();
                    delete this._underlying;
                }
            }
        }
    }, {
        key: "collapse",
        value: function collapse() {
            if (this._underlying && this._underlying instanceof MultiAssignCancelable) {
                var ref = this._underlying;
                this._underlying = ref._underlying;
                this._canceled = ref._canceled;
            }
            return this;
        }
    }, {
        key: "clear",
        value: function clear() {
            if (!this._canceled) this._underlying = undefined;
            return this;
        }
    }], [{
        key: "empty",
        value: function empty() {
            return new MultiAssignCancelable();
        }
    }, {
        key: "of",
        value: function of(cb) {
            return new MultiAssignCancelable(Cancelable.of(cb));
        }
    }]);
    return MultiAssignCancelable;
}();

var SerialCancelable = function () {
    function SerialCancelable(initial) {
        classCallCheck(this, SerialCancelable);

        this._underlying = initial;
        this._canceled = false;
    }

    createClass(SerialCancelable, [{
        key: "update",
        value: function update(value) {
            if (this._canceled) value.cancel();else {
                if (this._underlying) this._underlying.cancel();
                this._underlying = value;
            }
            return this;
        }
    }, {
        key: "isCanceled",
        value: function isCanceled() {
            return this._canceled;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            if (!this._canceled) {
                this._canceled = true;
                if (this._underlying) {
                    this._underlying.cancel();
                    delete this._underlying;
                }
            }
        }
    }], [{
        key: "empty",
        value: function empty() {
            return new SerialCancelable();
        }
    }, {
        key: "of",
        value: function of(cb) {
            return new SerialCancelable(Cancelable.of(cb));
        }
    }]);
    return SerialCancelable;
}();

var SingleAssignCancelable = function () {
    function SingleAssignCancelable() {
        classCallCheck(this, SingleAssignCancelable);

        this._canceled = false;
        this._wasAssigned = false;
    }

    createClass(SingleAssignCancelable, [{
        key: "update",
        value: function update(value) {
            if (this._wasAssigned) throw new IllegalStateError("SingleAssignCancelable#update multiple times");
            this._wasAssigned = true;
            if (this._canceled) value.cancel();else this._underlying = value;
            return this;
        }
    }, {
        key: "isCanceled",
        value: function isCanceled() {
            return this._canceled;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            if (!this._canceled) {
                this._canceled = true;
                if (this._underlying) {
                    this._underlying.cancel();
                    delete this._underlying;
                }
            }
        }
    }], [{
        key: "empty",
        value: function empty() {
            return new SingleAssignCancelable();
        }
    }, {
        key: "of",
        value: function of(cb) {
            var ref = new SingleAssignCancelable();
            ref.update(Cancelable.of(cb));
            return ref;
        }
    }]);
    return SingleAssignCancelable;
}();

var TimeUnit = function () {
    function TimeUnit() {
        classCallCheck(this, TimeUnit);
    }

    createClass(TimeUnit, [{
        key: "toString",
        value: function toString() {
            return this.label.toUpperCase();
        }
    }]);
    return TimeUnit;
}();
var C0 = 1;
var C1 = C0 * 1000;
var C2 = C1 * 1000;
var C3 = C2 * 1000;
var C4 = C3 * 60;
var C5 = C4 * 60;
var C6 = C5 * 24;
var MIN = -9007199254740992;
var MAX = 9007199254740992;

var trunc = Math.trunc || function (x) {
    if (isNaN(x)) return NaN;
    if (x > 0) return Math.floor(x);
    return Math.ceil(x);
};

function x(d, m, over) {
    if (d > over) return MAX;
    if (d < -over) return MIN;
    return d * m;
}

var Nanoseconds = function (_TimeUnit) {
    inherits(Nanoseconds, _TimeUnit);

    function Nanoseconds() {
        classCallCheck(this, Nanoseconds);

        var _this = possibleConstructorReturn(this, (Nanoseconds.__proto__ || Object.getPrototypeOf(Nanoseconds)).apply(this, arguments));

        _this.ord = 0;
        _this.label = "nanoseconds";
        return _this;
    }

    createClass(Nanoseconds, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toNanos(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return d;
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return trunc(d / (C1 / C0));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return trunc(d / (C2 / C0));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return trunc(d / (C3 / C0));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return trunc(d / (C4 / C0));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return trunc(d / (C5 / C0));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C0));
        }
    }]);
    return Nanoseconds;
}(TimeUnit);

var NANOSECONDS = new Nanoseconds();

var Microseconds = function (_TimeUnit2) {
    inherits(Microseconds, _TimeUnit2);

    function Microseconds() {
        classCallCheck(this, Microseconds);

        var _this2 = possibleConstructorReturn(this, (Microseconds.__proto__ || Object.getPrototypeOf(Microseconds)).apply(this, arguments));

        _this2.ord = 1;
        _this2.label = "microseconds";
        return _this2;
    }

    createClass(Microseconds, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toMicros(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C1 / C0, trunc(MAX / (C1 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return d;
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return trunc(d / (C2 / C1));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return trunc(d / (C3 / C1));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return trunc(d / (C4 / C1));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return trunc(d / (C5 / C1));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C1));
        }
    }]);
    return Microseconds;
}(TimeUnit);

var MICROSECONDS = new Microseconds();

var Milliseconds = function (_TimeUnit3) {
    inherits(Milliseconds, _TimeUnit3);

    function Milliseconds() {
        classCallCheck(this, Milliseconds);

        var _this3 = possibleConstructorReturn(this, (Milliseconds.__proto__ || Object.getPrototypeOf(Milliseconds)).apply(this, arguments));

        _this3.ord = 2;
        _this3.label = "milliseconds";
        return _this3;
    }

    createClass(Milliseconds, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toMillis(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C2 / C0, trunc(MAX / (C2 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return x(d, C2 / C1, trunc(MAX / (C2 / C1)));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return d;
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return trunc(d / (C3 / C2));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return trunc(d / (C4 / C2));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return trunc(d / (C5 / C2));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C2));
        }
    }]);
    return Milliseconds;
}(TimeUnit);

var MILLISECONDS = new Milliseconds();

var Seconds = function (_TimeUnit4) {
    inherits(Seconds, _TimeUnit4);

    function Seconds() {
        classCallCheck(this, Seconds);

        var _this4 = possibleConstructorReturn(this, (Seconds.__proto__ || Object.getPrototypeOf(Seconds)).apply(this, arguments));

        _this4.ord = 3;
        _this4.label = "seconds";
        return _this4;
    }

    createClass(Seconds, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toSeconds(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C3 / C0, trunc(MAX / (C3 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return x(d, C3 / C1, trunc(MAX / (C3 / C1)));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return x(d, C3 / C2, trunc(MAX / (C3 / C2)));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return d;
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return trunc(d / (C4 / C3));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return trunc(d / (C5 / C3));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C3));
        }
    }]);
    return Seconds;
}(TimeUnit);

var SECONDS = new Seconds();

var Minutes = function (_TimeUnit5) {
    inherits(Minutes, _TimeUnit5);

    function Minutes() {
        classCallCheck(this, Minutes);

        var _this5 = possibleConstructorReturn(this, (Minutes.__proto__ || Object.getPrototypeOf(Minutes)).apply(this, arguments));

        _this5.ord = 4;
        _this5.label = "minutes";
        return _this5;
    }

    createClass(Minutes, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toMinutes(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C4 / C0, trunc(MAX / (C4 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return x(d, C4 / C1, trunc(MAX / (C4 / C1)));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return x(d, C4 / C2, trunc(MAX / (C4 / C2)));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return x(d, C4 / C3, trunc(MAX / (C4 / C3)));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return d;
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return trunc(d / (C5 / C4));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C4));
        }
    }]);
    return Minutes;
}(TimeUnit);

var MINUTES = new Minutes();

var Hours = function (_TimeUnit6) {
    inherits(Hours, _TimeUnit6);

    function Hours() {
        classCallCheck(this, Hours);

        var _this6 = possibleConstructorReturn(this, (Hours.__proto__ || Object.getPrototypeOf(Hours)).apply(this, arguments));

        _this6.ord = 5;
        _this6.label = "hours";
        return _this6;
    }

    createClass(Hours, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toHours(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C5 / C0, trunc(MAX / (C5 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return x(d, C5 / C1, trunc(MAX / (C5 / C1)));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return x(d, C5 / C2, trunc(MAX / (C5 / C2)));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return x(d, C5 / C3, trunc(MAX / (C5 / C3)));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return x(d, C5 / C4, trunc(MAX / (C5 / C4)));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return d;
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return trunc(d / (C6 / C5));
        }
    }]);
    return Hours;
}(TimeUnit);

var HOURS = new Hours();

var Days = function (_TimeUnit7) {
    inherits(Days, _TimeUnit7);

    function Days() {
        classCallCheck(this, Days);

        var _this7 = possibleConstructorReturn(this, (Days.__proto__ || Object.getPrototypeOf(Days)).apply(this, arguments));

        _this7.ord = 6;
        _this7.label = "days";
        return _this7;
    }

    createClass(Days, [{
        key: "convert",
        value: function convert(duration, unit) {
            return unit.toDays(duration);
        }
    }, {
        key: "toNanos",
        value: function toNanos(d) {
            return x(d, C6 / C0, trunc(MAX / (C6 / C0)));
        }
    }, {
        key: "toMicros",
        value: function toMicros(d) {
            return x(d, C6 / C1, trunc(MAX / (C6 / C1)));
        }
    }, {
        key: "toMillis",
        value: function toMillis(d) {
            return x(d, C6 / C2, trunc(MAX / (C6 / C2)));
        }
    }, {
        key: "toSeconds",
        value: function toSeconds(d) {
            return x(d, C6 / C3, trunc(MAX / (C6 / C3)));
        }
    }, {
        key: "toMinutes",
        value: function toMinutes(d) {
            return x(d, C6 / C4, trunc(MAX / (C6 / C4)));
        }
    }, {
        key: "toHours",
        value: function toHours(d) {
            return x(d, C6 / C5, trunc(MAX / (C6 / C5)));
        }
    }, {
        key: "toDays",
        value: function toDays(d) {
            return d;
        }
    }]);
    return Days;
}(TimeUnit);

var DAYS = new Days();

var Duration = function () {
    function Duration(duration, unit) {
        classCallCheck(this, Duration);

        if (isNaN(duration)) {
            throw new IllegalArgumentError("NaN is not supported for a Duration");
        }

        this.duration = trunc(duration);
        this.unit = unit;
    }

    createClass(Duration, [{
        key: "isFinite",
        value: function (_isFinite) {
            function isFinite() {
                return _isFinite.apply(this, arguments);
            }

            isFinite.toString = function () {
                return _isFinite.toString();
            };

            return isFinite;
        }(function () {
            return isFinite(this.duration);
        })
    }, {
        key: "toNanos",
        value: function toNanos() {
            return NANOSECONDS.convert(this.duration, this.unit);
        }
    }, {
        key: "toMicros",
        value: function toMicros() {
            return MICROSECONDS.convert(this.duration, this.unit);
        }
    }, {
        key: "toMillis",
        value: function toMillis() {
            return MILLISECONDS.convert(this.duration, this.unit);
        }
    }, {
        key: "toSeconds",
        value: function toSeconds() {
            return SECONDS.convert(this.duration, this.unit);
        }
    }, {
        key: "toMinutes",
        value: function toMinutes() {
            return MINUTES.convert(this.duration, this.unit);
        }
    }, {
        key: "toHours",
        value: function toHours() {
            return HOURS.convert(this.duration, this.unit);
        }
    }, {
        key: "toDays",
        value: function toDays() {
            return DAYS.convert(this.duration, this.unit);
        }
    }, {
        key: "convertTo",
        value: function convertTo(unit) {
            return new Duration(unit.convert(this.duration, this.unit), unit);
        }
    }, {
        key: "negate",
        value: function negate() {
            switch (this.duration) {
                case Infinity:
                    return Duration.negInf();
                case -Infinity:
                    return Duration.inf();
                default:
                    return new Duration(-this.duration, this.unit);
            }
        }
    }, {
        key: "plus",
        value: function plus(other) {
            if (!isFinite(this.duration)) {
                if (!isFinite(other.duration) && this.duration !== other.duration) {
                    throw new IllegalArgumentError("cannot deal with two infinities with different signs, " + "as that would be a NaN");
                }
                return this;
            } else if (other.duration === 0) {
                return this;
            } else if (this.duration === 0) {
                return other;
            }
            if (!isFinite(other.duration)) return other;
            var d1 = this;
            var d2 = other;
            if (d2.unit.ord < d1.unit.ord) {
                d1 = other;
                d2 = this;
            }
            d2 = d2.convertTo(d1.unit);
            return new Duration(d1.duration + d2.duration, d1.unit);
        }
    }, {
        key: "minus",
        value: function minus(other) {
            return this.plus(other.negate());
        }
    }, {
        key: "equals",
        value: function equals(other) {
            function cmp(s, o) {
                var n = s.unit.convert(o.duration, o.unit);
                return n === s.duration;
            }
            if (!isFinite(this.duration)) {
                return !isFinite(other.duration) && this.duration === other.duration;
            }
            return this.unit.ord <= other.unit.ord ? cmp(this, other) : cmp(other, this);
        }
    }, {
        key: "hashCode",
        value: function hashCode() {
            if (this.isFinite()) {
                return this.toNanos();
            } else if (this.duration === Infinity) {
                return 7540833725118015;
            } else {
                return 422082410550358;
            }
        }
    }, {
        key: "toString",
        value: function toString() {
            if (this.isFinite()) return this.duration + " " + this.unit.label;else if (this.duration >= 0) return "[end of time]";else return "[beginning of time]";
        }
    }], [{
        key: "of",
        value: function of(value) {
            return typeof value === "number" ? Duration.millis(value) : value;
        }
    }, {
        key: "zero",
        value: function zero() {
            return new Duration(0, DAYS);
        }
    }, {
        key: "inf",
        value: function inf() {
            return new Duration(Infinity, DAYS);
        }
    }, {
        key: "negInf",
        value: function negInf() {
            return new Duration(-Infinity, DAYS);
        }
    }, {
        key: "nanos",
        value: function nanos(d) {
            return new Duration(d, NANOSECONDS);
        }
    }, {
        key: "micros",
        value: function micros(d) {
            return new Duration(d, MICROSECONDS);
        }
    }, {
        key: "millis",
        value: function millis(d) {
            return new Duration(d, MILLISECONDS);
        }
    }, {
        key: "seconds",
        value: function seconds(d) {
            return new Duration(d, SECONDS);
        }
    }, {
        key: "minutes",
        value: function minutes(d) {
            return new Duration(d, MINUTES);
        }
    }, {
        key: "hours",
        value: function hours(d) {
            return new Duration(d, HOURS);
        }
    }, {
        key: "days",
        value: function days(d) {
            return new Duration(d, DAYS);
        }
    }]);
    return Duration;
}();

var DynamicRef = function () {
    function DynamicRef(fn) {
        classCallCheck(this, DynamicRef);

        this.get = fn;
    }

    createClass(DynamicRef, [{
        key: "bind",
        value: function bind(value, thunk) {
            return this.bindL(function () {
                return value;
            }, thunk);
        }
    }, {
        key: "bindL",
        value: function bindL(value, thunk) {
            var oldFn = this.get;
            try {
                this.get = value;
                return thunk();
            } finally {
                this.get = oldFn;
            }
        }
    }], [{
        key: "of",
        value: function of(fn) {
            return new DynamicRef(fn);
        }
    }]);
    return DynamicRef;
}();

function arrayBSearchInsertPos(array, f) {
    return function (search) {
        var minIndex = 0;
        var maxIndex = array.length - 1;
        while (minIndex <= maxIndex) {
            var index = (minIndex + maxIndex) / 2 | 0;
            var current = f(array[index]);
            var next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined;
            if (current <= search && (next === undefined || search < next)) {
                return index + 1;
            } else if (current <= search) {
                minIndex = index + 1;
            } else {
                maxIndex = index - 1;
            }
        }
        return 0;
    };
}

function iterableToArray(values) {
    if (!values) return [];
    if (Object.prototype.toString.call(values) === "[object Array]") return values;
    var cursor = values[Symbol.iterator]();
    var arr = [];
    while (true) {
        var item = cursor.next();
        if (item.value) arr.push(item.value);
        if (item.done) return arr;
    }
}

var Scheduler = function () {
    function Scheduler() {
        classCallCheck(this, Scheduler);
    }

    createClass(Scheduler, [{
        key: "scheduleWithFixedDelay",
        value: function scheduleWithFixedDelay(initialDelay, delay, runnable) {
            var loop = function loop(self, ref, delayNow) {
                return ref.update(self.scheduleOnce(delayNow, function () {
                    runnable();
                    loop(self, ref, delay);
                }));
            };
            var task = MultiAssignCancelable.empty();
            return loop(this, task, initialDelay);
        }
    }, {
        key: "scheduleAtFixedRate",
        value: function scheduleAtFixedRate(initialDelay, period, runnable) {
            var loop = function loop(self, ref, delayNowMs, periodMs) {
                return ref.update(self.scheduleOnce(delayNowMs, function () {
                    var startAt = self.currentTimeMillis();
                    runnable();

                    var elapsedMs = self.currentTimeMillis() - startAt;
                    var nextDelayMs = Math.max(0, periodMs - elapsedMs);
                    loop(self, ref, periodMs, nextDelayMs);
                }));
            };
            var task = MultiAssignCancelable.empty();
            return loop(this, task, typeof initialDelay === "number" ? initialDelay : initialDelay.toMillis(), typeof period === "number" ? period : period.toMillis());
        }
    }]);
    return Scheduler;
}();

Scheduler.global = DynamicRef.of(function () {
    return globalSchedulerRef;
});

var Trampoline = function () {
    function Trampoline(parent) {
        classCallCheck(this, Trampoline);

        this._isActive = false;
        this._queue = [];
        this._parent = parent;
    }

    createClass(Trampoline, [{
        key: "execute",
        value: function execute(r) {
            if (!this._isActive) {
                this.runLoop(r);
            } else {
                this._queue.push(r);
            }
        }
    }, {
        key: "runLoop",
        value: function runLoop(r) {
            this._isActive = true;
            try {
                var cursor = r;
                while (cursor) {
                    try {
                        cursor();
                    } catch (e) {
                        this._parent.reportFailure(e);
                    }
                    cursor = this._queue.pop();
                }
            } finally {
                this._isActive = false;
            }
        }
    }]);
    return Trampoline;
}();

var GlobalScheduler = function (_Scheduler) {
    inherits(GlobalScheduler, _Scheduler);

    function GlobalScheduler() {
        var canUseSetImmediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        classCallCheck(this, GlobalScheduler);

        var _this = possibleConstructorReturn(this, (GlobalScheduler.__proto__ || Object.getPrototypeOf(GlobalScheduler)).call(this));

        _this._trampoline = new Trampoline(_this);

        _this._useSetImmediate = (canUseSetImmediate || false) && typeof setImmediate === "function";
        return _this;
    }

    createClass(GlobalScheduler, [{
        key: "executeAsync",
        value: function executeAsync(runnable) {
            var r = safeRunnable(runnable, this.reportFailure);
            if (this._useSetImmediate) setImmediate(r);else setTimeout(r);
        }
    }, {
        key: "trampoline",
        value: function trampoline(runnable) {
            this._trampoline.execute(runnable);
        }
    }, {
        key: "reportFailure",
        value: function reportFailure(e) {
            console.error(e);
        }
    }, {
        key: "currentTimeMillis",
        value: function currentTimeMillis() {
            return Date.now();
        }
    }, {
        key: "scheduleOnce",
        value: function scheduleOnce(delay, runnable) {
            var r = safeRunnable(runnable, this.reportFailure);
            var ms = Math.max(0, Duration.of(delay).toMillis());
            var task = setTimeout(r, ms);
            return Cancelable.of(function () {
                return clearTimeout(task);
            });
        }
    }]);
    return GlobalScheduler;
}(Scheduler);

var TestScheduler = function (_Scheduler2) {
    inherits(TestScheduler, _Scheduler2);

    function TestScheduler(reporter) {
        classCallCheck(this, TestScheduler);

        var _this2 = possibleConstructorReturn(this, (TestScheduler.__proto__ || Object.getPrototypeOf(TestScheduler)).call(this));

        _this2._reporter = reporter || function (_) {};
        _this2._clock = 0;
        _this2._triggeredFailures = [];
        _this2._trampoline = new Trampoline(_this2);
        _this2._updateTasks([]);
        return _this2;
    }

    createClass(TestScheduler, [{
        key: "triggeredFailures",
        value: function triggeredFailures() {
            return this._triggeredFailures;
        }
    }, {
        key: "hasTasksLeft",
        value: function hasTasksLeft() {
            return this._tasks.length > 0;
        }
    }, {
        key: "executeAsync",
        value: function executeAsync(runnable) {
            this._tasks.push([this._clock, runnable]);
        }
    }, {
        key: "trampoline",
        value: function trampoline(runnable) {
            this._trampoline.execute(runnable);
        }
    }, {
        key: "reportFailure",
        value: function reportFailure(e) {
            this._triggeredFailures.push(e);
            this._reporter(e);
        }
    }, {
        key: "currentTimeMillis",
        value: function currentTimeMillis() {
            return this._clock;
        }
    }, {
        key: "scheduleOnce",
        value: function scheduleOnce(delay, runnable) {
            var _this3 = this;

            var d = Math.max(0, Duration.of(delay).toMillis());
            var scheduleAt = this._clock + d;
            var insertAt = this._tasksSearch(-scheduleAt);
            var ref = [scheduleAt, runnable];
            this._tasks.splice(insertAt, 0, ref);
            return Cancelable.of(function () {
                var filtered = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = _this3._tasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var e = _step.value;

                        if (e !== ref) filtered.push(e);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                _this3._updateTasks(filtered);
            });
        }
    }, {
        key: "tick",
        value: function tick(duration) {
            var toExecute = [];
            var jumpMs = Duration.of(duration || 0).toMillis();
            var executed = 0;
            while (true) {
                var peek = this._tasks.length > 0 ? this._tasks[this._tasks.length - 1] : undefined;
                if (peek && peek[0] <= this._clock) {
                    toExecute.push(this._tasks.pop());
                } else if (toExecute.length > 0) {
                    while (toExecute.length > 0) {
                        var index = Math.floor(Math.random() * toExecute.length);
                        var elem = toExecute[index];
                        try {
                            toExecute.splice(index, 1);
                            elem[1]();
                        } catch (e) {
                            this.reportFailure(e);
                        } finally {
                            executed += 1;
                        }
                    }
                } else if (jumpMs > 0) {
                    var nextTaskJump = peek && peek[0] - this._clock || jumpMs;
                    var add = Math.min(nextTaskJump, jumpMs);
                    this._clock += add;
                    jumpMs -= add;
                } else {
                    break;
                }
            }
            return executed;
        }
    }, {
        key: "_updateTasks",
        value: function _updateTasks(tasks) {
            this._tasks = tasks;
            this._tasksSearch = arrayBSearchInsertPos(this._tasks, function (e) {
                return -e[0];
            });
        }
    }]);
    return TestScheduler;
}(Scheduler);

var globalSchedulerRef = new GlobalScheduler(true);

function safeRunnable(r, reporter) {
    return function () {
        try {
            r();
        } catch (e) {
            reporter(e);
        }
    };
}

var Future = function () {
    function Future() {
        classCallCheck(this, Future);
    }

    createClass(Future, [{
        key: "transform",
        value: function transform(failure, success) {
            return this.transformWith(function (e) {
                return Future.pure(failure(e));
            }, function (a) {
                return Future.pure(success(a));
            });
        }
    }, {
        key: "attempt",
        value: function attempt() {
            return this.transform(Left, Right);
        }
    }, {
        key: "flatMap",
        value: function flatMap(f) {
            return this.transformWith(Future.raise, f);
        }
    }, {
        key: "map",
        value: function map(f) {
            return this.transformWith(Future.raise, function (a) {
                return Future.pure(f(a));
            });
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(f) {
            return this.transformWith(f, Future.pure);
        }
    }, {
        key: "recover",
        value: function recover(f) {
            return this.transformWith(function (a) {
                return Future.pure(f(a));
            }, Future.pure);
        }
    }, {
        key: "then",
        value: function then(onFulfilled, onRejected) {
            if (!onFulfilled && !onRejected) return this;
            return this.transformWith(promiseThen(onRejected, Future.raise), promiseThen(onFulfilled, Future.pure));
        }
    }, {
        key: "toPromise",
        value: function toPromise() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _this.onComplete(function (_) {
                    return _.fold(reject, resolve);
                });
            });
        }
    }, {
        key: "delayResult",
        value: function delayResult(delay) {
            var _this2 = this;

            return this.transformWith(function (err) {
                return Future.delayedTick(delay, _this2._scheduler).flatMap(function (_) {
                    return Future.raise(err, _this2._scheduler);
                });
            }, function (a) {
                return Future.delayedTick(delay, _this2._scheduler).map(function (_) {
                    return a;
                });
            });
        }
    }, {
        key: "timeout",
        value: function timeout(after) {
            var fb = Future.raise(new TimeoutError(Duration.of(after).toString()), this._scheduler);
            return this.timeoutTo(after, function () {
                return fb;
            });
        }
    }, {
        key: "timeoutTo",
        value: function timeoutTo(after, fallback) {
            var other = Future.delayedTick(after, this._scheduler).flatMap(function (_) {
                return fallback();
            });
            var lst = [this, other];
            return Future.firstCompletedOf(lst, this._scheduler);
        }
    }], [{
        key: "of",
        value: function of(thunk) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return new FutureBuilder(function (cb) {
                return ec.executeAsync(function () {
                    return cb(Try.of(function () {
                        return thunk();
                    }));
                });
            }, ec);
        }
    }, {
        key: "pure",
        value: function pure(a) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return new PureFuture(Success(a), ec);
        }
    }, {
        key: "raise",
        value: function raise(e) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return new PureFuture(Failure(e), ec);
        }
    }, {
        key: "create",
        value: function create(register) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return new FutureBuilder(register, ec);
        }
    }, {
        key: "unit",
        value: function unit() {
            return futureUnit;
        }
    }, {
        key: "delayedTick",
        value: function delayedTick(delay) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return Future.create(function (cb) {
                return ec.scheduleOnce(delay, function () {
                    return cb(Success(undefined));
                });
            }, ec);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return f(a).flatMap(function (r) {
                if (r.isRight()) return Future.pure(r.get());
                return Future.tailRecM(r.swap().get(), f);
            });
        }
    }, {
        key: "fromPromise",
        value: function fromPromise(ref) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            if (ref instanceof Future) return ref.withScheduler(ec);else return Future.create(function (cb) {
                ref.then(function (value) {
                    return cb(Success(value));
                }, function (err) {
                    return cb(Failure(err));
                });
            }, ec);
        }
    }, {
        key: "firstCompletedOf",
        value: function firstCompletedOf(list) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return futureFirstCompletedOf(list, ec);
        }
    }, {
        key: "traverse",
        value: function traverse(list) {
            var parallelism = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
            var ec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Scheduler.global.get();

            return function (f) {
                return futureTraverse(list, f, parallelism, ec);
            };
        }
    }, {
        key: "sequence",
        value: function sequence(list) {
            var ec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Scheduler.global.get();

            return futureSequence(list, ec);
        }
    }, {
        key: "map2",
        value: function map2(fa1, fa2, f) {
            var ec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Scheduler.global.get();

            var fl = Future.sequence([fa1, fa2], ec);
            return fl.map(function (lst) {
                return f(lst[0], lst[1]);
            });
        }
    }, {
        key: "map3",
        value: function map3(fa1, fa2, fa3, f) {
            var ec = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Scheduler.global.get();

            var fl = Future.sequence([fa1, fa2, fa3], ec);
            return fl.map(function (lst) {
                return f(lst[0], lst[1], lst[2]);
            });
        }
    }, {
        key: "map4",
        value: function map4(fa1, fa2, fa3, fa4, f) {
            var ec = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Scheduler.global.get();

            var fl = Future.sequence([fa1, fa2, fa3, fa4], ec);
            return fl.map(function (lst) {
                return f(lst[0], lst[1], lst[2], lst[3]);
            });
        }
    }, {
        key: "map5",
        value: function map5(fa1, fa2, fa3, fa4, fa5, f) {
            var ec = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Scheduler.global.get();

            var fl = Future.sequence([fa1, fa2, fa3, fa4, fa5], ec);
            return fl.map(function (lst) {
                return f(lst[0], lst[1], lst[2], lst[3], lst[4]);
            });
        }
    }, {
        key: "map6",
        value: function map6(fa1, fa2, fa3, fa4, fa5, fa6, f) {
            var ec = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Scheduler.global.get();

            var fl = Future.sequence([fa1, fa2, fa3, fa4, fa5, fa6], ec);
            return fl.map(function (lst) {
                return f(lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]);
            });
        }
    }]);
    return Future;
}();

var PureFuture = function (_Future) {
    inherits(PureFuture, _Future);

    function PureFuture(_value, _scheduler) {
        classCallCheck(this, PureFuture);

        var _this3 = possibleConstructorReturn(this, (PureFuture.__proto__ || Object.getPrototypeOf(PureFuture)).call(this));

        _this3._value = _value;
        _this3._scheduler = _scheduler;
        return _this3;
    }

    createClass(PureFuture, [{
        key: "cancel",
        value: function cancel() {}
    }, {
        key: "value",
        value: function value() {
            return Some(this._value);
        }
    }, {
        key: "withScheduler",
        value: function withScheduler(ec) {
            if (this._scheduler === ec) return this;
            return new PureFuture(this._value, ec);
        }
    }, {
        key: "onComplete",
        value: function onComplete(f) {
            var _this4 = this;

            this._scheduler.trampoline(function () {
                return f(_this4._value);
            });
        }
    }, {
        key: "transformWith",
        value: function transformWith(failure, success) {
            return genericTransformWith(this, failure, success, this._scheduler);
        }
    }, {
        key: "toPromise",
        value: function toPromise() {
            return this._value.fold(function (e) {
                return Promise.reject(e);
            }, function (a) {
                return Promise.resolve(a);
            });
        }
    }]);
    return PureFuture;
}(Future);

var FutureBuilder = function (_Future2) {
    inherits(FutureBuilder, _Future2);

    function FutureBuilder(register, ec) {
        classCallCheck(this, FutureBuilder);

        var _this5 = possibleConstructorReturn(this, (FutureBuilder.__proto__ || Object.getPrototypeOf(FutureBuilder)).call(this));

        _this5._result = None;
        _this5._listeners = [];
        _this5._scheduler = ec;
        var complete = function complete(result) {
            if (_this5._result !== None) {
                throw new IllegalStateError("Attempt to completing a Future multiple times");
            } else {
                _this5._result = Some(result);
                var listeners = _this5._listeners;
                delete _this5._listeners;
                delete _this5._cancelable;

                var _loop = function _loop(f) {
                    ec.trampoline(function () {
                        return f(result);
                    });
                };

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var f = _step.value;

                        _loop(f);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        };
        var cb = register(complete);
        if (_this5._result === None && cb) _this5._cancelable = cb;
        return _this5;
    }

    createClass(FutureBuilder, [{
        key: "onComplete",
        value: function onComplete(f) {
            var _this6 = this;

            if (this._result !== None) {
                this._scheduler.trampoline(function () {
                    return f(_this6._result.get());
                });
            } else {
                this._listeners.push(f);
            }
        }
    }, {
        key: "value",
        value: function value() {
            return this._result;
        }
    }, {
        key: "cancel",
        value: function cancel() {
            var cb = this._cancelable;
            if (cb) {
                cb.cancel();
                delete this._cancelable;
            }
        }
    }, {
        key: "withScheduler",
        value: function withScheduler(ec) {
            var _this7 = this;

            if (this._scheduler === ec) return this;
            return new FutureBuilder(function (cb) {
                _this7.onComplete(cb);
                return _this7._cancelable;
            }, ec);
        }
    }, {
        key: "transformWith",
        value: function transformWith(failure, success) {
            return genericTransformWith(this, failure, success, this._scheduler, this._cancelable);
        }
    }]);
    return FutureBuilder;
}(Future);

function genericTransformWith(self, failure, success, scheduler, cancelable) {
    return new FutureBuilder(function (cb) {
        var cRef = new MultiAssignCancelable(cancelable);
        self.onComplete(function (tryA) {
            var fb = void 0;
            try {
                fb = tryA.fold(failure, success);
            } catch (e) {
                fb = Future.raise(e);
            }

            if (fb.value().isEmpty()) {
                var fbb = fb;
                if (fbb._cancelable && fbb._cancelable instanceof MultiAssignCancelable) {
                    cRef.update(fbb._cancelable).collapse();
                    fbb._cancelable = cRef;
                } else {
                    cRef.update(fb._cancelable || fb);
                }
            } else {
                cRef.clear();
            }
            fb.onComplete(cb);
        });
        return cRef;
    }, scheduler);
}

var futureUnit = new PureFuture(Success(undefined), Scheduler.global.get());

function promiseThen(f, alt) {
    return function (value) {
        if (typeof f !== "function") return alt(value);
        var fb = f(value);
        if (!fb) return Future.pure(value);
        if (typeof fb.then === "function") return Future.fromPromise(fb);else return Future.pure(fb);
    };
}

function futureCancelAll(list, ec) {
    var skip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var errors = [];
    for (var i = 0; i < list.length; i++) {
        if (i !== skip) try {
            list[i].cancel();
        } catch (e) {
            errors.push(e);
        }
    }
    if (errors.length > 0) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var e = _step2.value;

                ec.reportFailure(e);
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    }
}

function futureIterableToArray(values, ec) {
    if (!values) return [];
    if (Object.prototype.toString.call(values) === "[object Array]") return values;
    var arr = [];
    try {
        var cursor = values[Symbol.iterator]();
        while (true) {
            var item = cursor.next();
            if (item.value) arr.push(item.value);
            if (item.done) break;
        }
        return arr;
    } catch (e) {
        futureCancelAll(arr, ec);
        throw e;
    }
}

function futureSequence(values, ec) {
    return Future.create(function (cb) {
        try {
            var _ret2 = function () {
                var futures = futureIterableToArray(values, ec);

                if (futures.length === 0) return {
                        v: cb(Success([]))
                    };
                var cRef = Cancelable.of(function () {
                    return futureCancelAll(futures, ec);
                });

                var isDone = false;
                var finishedCount = 0;
                var finalArray = [];

                var _loop2 = function _loop2(index) {
                    var fi = index;
                    var fa = futures[index];
                    fa.onComplete(function (result) {
                        finishedCount += 1;
                        if (result.isSuccess()) {
                            if (!isDone) {
                                finalArray[fi] = result.get();
                                isDone = finishedCount === futures.length;
                                if (isDone) cb(Success(finalArray));
                            }
                        } else {
                            if (!isDone) {
                                isDone = true;
                                cRef.cancel();
                                cb(result);
                            } else {
                                ec.reportFailure(result.failed().get());
                            }
                        }
                    });
                };

                for (var index = 0; index < futures.length; index++) {
                    _loop2(index);
                }
                return {
                    v: cRef
                };
            }();

            if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } catch (e) {
            cb(Failure(e));
        }
    }, ec);
}

function futureFirstCompletedOf(iterable, ec) {
    return Future.create(function (cb) {
        try {
            var _ret4 = function () {
                var futures = futureIterableToArray(iterable, ec);

                if (futures.length === 0) return {
                        v: cb(Failure(new IllegalArgumentError("empty list of futures")))
                    };

                var isDone = false;

                var _loop3 = function _loop3(index) {
                    var fi = index;
                    var fa = futures[index];
                    fa.onComplete(function (result) {
                        if (!isDone) {
                            isDone = true;
                            futureCancelAll(futures, ec, fi);
                            cb(result);
                        } else if (result.isFailure()) {
                            ec.reportFailure(result.failed().get());
                        }
                    });
                };

                for (var index = 0; index < futures.length; index++) {
                    _loop3(index);
                }
                return {
                    v: Cancelable.of(function () {
                        return futureCancelAll(futures, ec);
                    })
                };
            }();

            if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
        } catch (e) {
            cb(Failure(e));
        }
    }, ec);
}

function futureTraverse(list, f, parallelism, ec) {
    if (parallelism <= 0) {
        throw new IllegalArgumentError("parallelism <= 0");
    }
    return Future.of(function () {
        return iterableToArray(list);
    }, ec).flatMap(function (values) {
        return futureTraverseLoop(values, f, parallelism, ec, 0, []);
    });
}

function futureTraverseLoop(list, f, parallelism, ec, index, result) {
    if (index >= list.length) return Future.pure(result);
    var batch = [];
    var length = 0;
    try {
        while (index < list.length && length < parallelism) {
            batch.push(f(list[index++]));
            length += 1;
        }
        var fa = Future.sequence(batch, ec).map(function (b) {
            for (var i = 0; i < b.length; i++) {
                result.push(b[i]);
            }
        });
        if (index >= list.length) {
            return fa.map(function (_) {
                return result;
            });
        } else {
            return fa.flatMap(function (_) {
                return futureTraverseLoop(list, f, parallelism, ec, index, result);
            });
        }
    } catch (e) {
        futureCancelAll(batch, ec);
        return Future.raise(e);
    }
}

var Equiv = function () {
    function Equiv(lh, rh) {
        classCallCheck(this, Equiv);

        this.lh = lh;
        this.rh = rh;
    }

    createClass(Equiv, null, [{
        key: "of",
        value: function of(lh, rh) {
            return new Equiv(lh, rh);
        }
    }]);
    return Equiv;
}();

function registerTypeClassInstance(tc) {
    return function (c, instance) {
        var obj = c;
        var types = obj._funTypes || {};
        obj._funTypes = types;
        var existing = types[tc._funTypeId];
        if (existing) {
            if (existing === instance) return;

            var name = existing.constructor.name;
            throw new IllegalArgumentError("Type class coherence issue, " + (name + "<" + c.name + "> is already defined!"));
        }
        types[tc._funTypeId] = instance;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = tc._funSupertypeIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var id = _step.value;

                if (!types[id]) types[id] = instance;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
}

function getTypeClassInstance(tc) {
    return function (c) {
        var obj = c;
        var types = obj._funTypes || {};
        var instance = types[tc._funTypeId];
        if (instance) return instance;
        throw new NotImplementedError(tc.name + "<" + obj.name + ">");
    };
}

var Eq = function Eq() {
  classCallCheck(this, Eq);
};

Eq._funTypeId = "eq";

Eq._funSupertypeIds = [];

var EqLaws = function () {
  function EqLaws() {
    classCallCheck(this, EqLaws);
  }

  createClass(EqLaws, [{
    key: "reflexive",
    value: function reflexive(a) {
      return this.F.eqv(a, a);
    }
  }, {
    key: "symmetric",
    value: function symmetric(x, y) {
      return this.F.eqv(x, y) === this.F.eqv(y, x);
    }
  }, {
    key: "transitive",
    value: function transitive(x, y, z) {
      return !(this.F.eqv(x, y) && this.F.eqv(y, z)) || this.F.eqv(x, z);
    }
  }]);
  return EqLaws;
}();

var eqOf = getTypeClassInstance(Eq);

function eqLawsOf(instance) {
  return new (function (_EqLaws) {
    inherits(_class, _EqLaws);

    function _class() {
      classCallCheck(this, _class);

      var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));

      _this.F = instance;
      return _this;
    }

    return _class;
  }(EqLaws))();
}

var Functor = function Functor() {
  classCallCheck(this, Functor);
};

Functor._funTypeId = "functor";

Functor._funSupertypeIds = [];

var FunctorLaws = function () {
  function FunctorLaws() {
    classCallCheck(this, FunctorLaws);
  }

  createClass(FunctorLaws, [{
    key: "covariantIdentity",
    value: function covariantIdentity(fa) {
      return Equiv.of(this.F.map(fa, id), fa);
    }
  }, {
    key: "covariantComposition",
    value: function covariantComposition(fa, f, g) {
      return Equiv.of(this.F.map(this.F.map(fa, f), g), this.F.map(fa, function (x) {
        return g(f(x));
      }));
    }
  }]);
  return FunctorLaws;
}();

var functorOf = getTypeClassInstance(Functor);

function functorLawsOf(instance) {
  return new (function (_FunctorLaws) {
    inherits(_class, _FunctorLaws);

    function _class() {
      classCallCheck(this, _class);

      var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));

      _this.F = instance;
      return _this;
    }

    return _class;
  }(FunctorLaws))();
}

var Apply = function () {
    function Apply() {
        classCallCheck(this, Apply);
    }

    createClass(Apply, [{
        key: "map2",
        value: function map2(fa, fb, f) {
            return this.ap(fb, this.map(fa, function (a) {
                return function (b) {
                    return f(a, b);
                };
            }));
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            return this.map2(fa, fb, function (a, b) {
                return [a, b];
            });
        }
    }]);
    return Apply;
}();

Apply._funTypeId = "apply";

Apply._funSupertypeIds = ["functor"];
applyMixins(Apply, [Functor]);

var ApplyLaws = function () {
    function ApplyLaws() {
        classCallCheck(this, ApplyLaws);
    }

    createClass(ApplyLaws, [{
        key: "applyComposition",
        value: function applyComposition(fa, fab, fbc) {
            var F = this.F;
            var compose = function compose(f) {
                return function (g) {
                    return function (a) {
                        return f(g(a));
                    };
                };
            };
            return Equiv.of(F.ap(F.ap(fa, fab), fbc), F.ap(fa, F.ap(fab, F.map(fbc, compose))));
        }
    }, {
        key: "applyProductConsistency",
        value: function applyProductConsistency(fa, f) {
            var F = this.F;
            return Equiv.of(F.ap(fa, f), F.map(F.product(f, fa), function (p) {
                var _p = slicedToArray(p, 2),
                    f = _p[0],
                    a = _p[1];

                return f(a);
            }));
        }
    }, {
        key: "applyMap2Consistency",
        value: function applyMap2Consistency(fa, f) {
            var F = this.F;
            return Equiv.of(F.ap(fa, f), F.map2(f, fa, function (f, a) {
                return f(a);
            }));
        }
    }]);
    return ApplyLaws;
}();
applyMixins(ApplyLaws, [FunctorLaws]);

var applyOf = getTypeClassInstance(Apply);

function applyLawsOf(instance) {
    return new (function (_ApplyLaws) {
        inherits(_class, _ApplyLaws);

        function _class() {
            classCallCheck(this, _class);

            var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));

            _this.F = instance;
            return _this;
        }

        return _class;
    }(ApplyLaws))();
}

var Applicative = function () {
    function Applicative() {
        classCallCheck(this, Applicative);
    }

    createClass(Applicative, [{
        key: "unit",
        value: function unit() {
            return this.pure(undefined);
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return this.ap(fa, this.pure(f));
        }
    }]);
    return Applicative;
}();

Applicative._funTypeId = "applicative";

Applicative._funSupertypeIds = ["functor", "apply"];
applyMixins(Applicative, [Apply]);

var ApplicativeLaws = function () {
    function ApplicativeLaws() {
        classCallCheck(this, ApplicativeLaws);
    }

    createClass(ApplicativeLaws, [{
        key: "applicativeIdentity",
        value: function applicativeIdentity(fa) {
            var F = this.F;
            return Equiv.of(F.ap(fa, F.pure(function (a) {
                return a;
            })), fa);
        }
    }, {
        key: "applicativeHomomorphism",
        value: function applicativeHomomorphism(a, f) {
            var F = this.F;
            return Equiv.of(F.ap(F.pure(a), F.pure(f)), F.pure(f(a)));
        }
    }, {
        key: "applicativeInterchange",
        value: function applicativeInterchange(a, ff) {
            var F = this.F;
            return Equiv.of(F.ap(F.pure(a), ff), F.ap(ff, F.pure(function (f) {
                return f(a);
            })));
        }
    }, {
        key: "applicativeMap",
        value: function applicativeMap(fa, f) {
            var F = this.F;
            return Equiv.of(F.map(fa, f), F.ap(fa, F.pure(f)));
        }
    }, {
        key: "applicativeComposition",
        value: function applicativeComposition(fa, fab, fbc) {
            var F = this.F;
            var compose = function compose(f) {
                return function (g) {
                    return function (a) {
                        return f(g(a));
                    };
                };
            };
            return Equiv.of(F.ap(fa, F.ap(fab, F.ap(fbc, F.pure(compose)))), F.ap(F.ap(fa, fab), fbc));
        }
    }, {
        key: "applicativeUnit",
        value: function applicativeUnit(a) {
            var F = this.F;
            return Equiv.of(F.map(F.unit(), function (_) {
                return a;
            }), F.pure(a));
        }
    }]);
    return ApplicativeLaws;
}();
applyMixins(ApplicativeLaws, [ApplyLaws]);

var applicativeOf = getTypeClassInstance(Applicative);

function applicativeLawsOf(instance) {
    return new (function (_ApplicativeLaws) {
        inherits(_class2, _ApplicativeLaws);

        function _class2() {
            classCallCheck(this, _class2);

            var _this2 = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));

            _this2.F = instance;
            return _this2;
        }

        return _class2;
    }(ApplicativeLaws))();
}

var ApplicativeError = function () {
    function ApplicativeError() {
        classCallCheck(this, ApplicativeError);
    }

    createClass(ApplicativeError, [{
        key: "recover",
        value: function recover(fa, f) {
            var F = this;
            return F.recoverWith(fa, function (e) {
                return F.pure(f(e));
            });
        }
    }, {
        key: "attempt",
        value: function attempt(fa) {
            var F = this;
            return F.recover(F.map(fa, function (a) {
                return Either.right(a);
            }), Left);
        }
    }]);
    return ApplicativeError;
}();

ApplicativeError._funTypeId = "applicativeError";

ApplicativeError._funSupertypeIds = ["functor", "apply", "applicative"];
applyMixins(ApplicativeError, [Applicative]);

var ApplicativeErrorLaws = function () {
    function ApplicativeErrorLaws() {
        classCallCheck(this, ApplicativeErrorLaws);
    }

    createClass(ApplicativeErrorLaws, [{
        key: "applicativeErrorRecoverWith",
        value: function applicativeErrorRecoverWith(e, f) {
            var F = this.F;
            return Equiv.of(F.recoverWith(F.raise(e), f), f(e));
        }
    }, {
        key: "applicativeErrorRecover",
        value: function applicativeErrorRecover(e, f) {
            var F = this.F;
            return Equiv.of(F.recover(F.raise(e), f), F.pure(f(e)));
        }
    }, {
        key: "recoverWithPure",
        value: function recoverWithPure(a, f) {
            var F = this.F;
            return Equiv.of(F.recoverWith(F.pure(a), f), F.pure(a));
        }
    }, {
        key: "recoverPure",
        value: function recoverPure(a, f) {
            var F = this.F;
            return Equiv.of(F.recover(F.pure(a), f), F.pure(a));
        }
    }, {
        key: "raiseErrorAttempt",
        value: function raiseErrorAttempt(e) {
            var F = this.F;
            return Equiv.of(F.attempt(F.raise(e)), F.pure(Left(e)));
        }
    }, {
        key: "pureAttempt",
        value: function pureAttempt(a) {
            var F = this.F;
            return Equiv.of(F.attempt(F.pure(a)), F.pure(Right(a)));
        }
    }]);
    return ApplicativeErrorLaws;
}();
applyMixins(ApplicativeErrorLaws, [ApplicativeLaws]);

var applicativeErrorOf = getTypeClassInstance(ApplicativeError);

function applicativeErrorLawsOf(instance) {
    return new (function (_ApplicativeErrorLaws) {
        inherits(_class3, _ApplicativeErrorLaws);

        function _class3() {
            classCallCheck(this, _class3);

            var _this3 = possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).apply(this, arguments));

            _this3.F = instance;
            return _this3;
        }

        return _class3;
    }(ApplicativeErrorLaws))();
}

var FlatMap = function () {
    function FlatMap() {
        classCallCheck(this, FlatMap);
    }

    createClass(FlatMap, [{
        key: "followedBy",
        value: function followedBy(fa, fb) {
            return this.flatMap(fa, function (_) {
                return fb;
            });
        }
    }, {
        key: "followedByL",
        value: function followedByL(fa, fb) {
            return this.flatMap(fa, function (_) {
                return fb();
            });
        }
    }, {
        key: "forEffect",
        value: function forEffect(fa, fb) {
            var _this = this;

            return this.flatMap(fa, function (a) {
                return _this.map(fb, function (_) {
                    return a;
                });
            });
        }
    }, {
        key: "forEffectL",
        value: function forEffectL(fa, fb) {
            var _this2 = this;

            return this.flatMap(fa, function (a) {
                return _this2.map(fb(), function (_) {
                    return a;
                });
            });
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            var _this3 = this;

            return this.flatMap(fa, function (a) {
                return _this3.map(ff, function (f) {
                    return f(a);
                });
            });
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            var _this4 = this;

            return this.flatMap(fa, function (a) {
                return _this4.map(fb, function (b) {
                    return f(a, b);
                });
            });
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            var _this5 = this;

            return this.flatMap(fa, function (a) {
                return _this5.map(fb, function (b) {
                    return [a, b];
                });
            });
        }
    }]);
    return FlatMap;
}();

FlatMap._funTypeId = "flatMap";

FlatMap._funSupertypeIds = ["functor", "apply"];

var FlatMapLaws = function () {
    function FlatMapLaws() {
        classCallCheck(this, FlatMapLaws);
    }

    createClass(FlatMapLaws, [{
        key: "flatMapAssociativity",
        value: function flatMapAssociativity(fa, f, g) {
            var F = this.F;
            return Equiv.of(F.flatMap(F.flatMap(fa, f), g), F.flatMap(fa, function (a) {
                return F.flatMap(f(a), g);
            }));
        }
    }, {
        key: "flatMapConsistentApply",
        value: function flatMapConsistentApply(fa, fab) {
            var F = this.F;
            return Equiv.of(F.ap(fa, fab), F.flatMap(fab, function (f) {
                return F.map(fa, f);
            }));
        }
    }, {
        key: "followedByConsistency",
        value: function followedByConsistency(fa, fb) {
            var F = this.F;
            return Equiv.of(F.followedBy(fa, fb), F.flatMap(fa, function (_) {
                return fb;
            }));
        }
    }, {
        key: "followedByLConsistency",
        value: function followedByLConsistency(fa, fb) {
            var F = this.F;
            return Equiv.of(F.followedByL(fa, function () {
                return fb;
            }), F.flatMap(fa, function (_) {
                return fb;
            }));
        }
    }, {
        key: "forEffectConsistency",
        value: function forEffectConsistency(fa, fb) {
            var F = this.F;
            return Equiv.of(F.forEffect(fa, fb), F.flatMap(fa, function (a) {
                return F.map(fb, function (_) {
                    return a;
                });
            }));
        }
    }, {
        key: "forEffectLConsistency",
        value: function forEffectLConsistency(fa, fb) {
            var F = this.F;
            return Equiv.of(F.forEffectL(fa, function () {
                return fb;
            }), F.flatMap(fa, function (a) {
                return F.map(fb, function (_) {
                    return a;
                });
            }));
        }
    }, {
        key: "tailRecMConsistentFlatMap",
        value: function tailRecMConsistentFlatMap(a, f) {
            var F = this.F;
            var bounce = function bounce(n) {
                return F.tailRecM([a, n], function (x) {
                    var _x = slicedToArray(x, 2),
                        a0 = _x[0],
                        i = _x[1];

                    return i > 0 ? F.map(f(a0), function (a1) {
                        return Left([a1, i - 1]);
                    }) : F.map(f(a0), Right);
                });
            };

            return Equiv.of(bounce(1), F.flatMap(bounce(0), f));
        }
    }]);
    return FlatMapLaws;
}();
applyMixins(FlatMapLaws, [ApplyLaws]);

var flatMapOf = getTypeClassInstance(FlatMap);

function flatMapLawsOf(instance) {
    return new (function (_FlatMapLaws) {
        inherits(_class, _FlatMapLaws);

        function _class() {
            classCallCheck(this, _class);

            var _this6 = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));

            _this6.F = instance;
            return _this6;
        }

        return _class;
    }(FlatMapLaws))();
}

var Monad = function () {
    function Monad() {
        classCallCheck(this, Monad);
    }

    createClass(Monad, [{
        key: "ap",
        value: function ap(fa, ff) {
            var _this7 = this;

            return this.flatMap(fa, function (a) {
                return _this7.map(ff, function (f) {
                    return f(a);
                });
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            var _this8 = this;

            return this.flatMap(fa, function (a) {
                return _this8.pure(f(a));
            });
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            var F = this;
            return F.flatMap(fa, function (a) {
                return F.map(fb, function (b) {
                    return f(a, b);
                });
            });
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            var F = this;
            return F.flatMap(fa, function (a) {
                return F.map(fb, function (b) {
                    return [a, b];
                });
            });
        }
    }]);
    return Monad;
}();

Monad._funTypeId = "monad";

Monad._funSupertypeIds = ["functor", "apply", "applicative", "flatMap"];
applyMixins(Monad, [Applicative, FlatMap]);

var MonadLaws = function () {
    function MonadLaws() {
        classCallCheck(this, MonadLaws);
    }

    createClass(MonadLaws, [{
        key: "monadLeftIdentity",
        value: function monadLeftIdentity(a, f) {
            var F = this.F;
            return Equiv.of(F.flatMap(F.pure(a), f), f(a));
        }
    }, {
        key: "monadRightIdentity",
        value: function monadRightIdentity(fa) {
            var F = this.F;
            return Equiv.of(F.flatMap(fa, F.pure), fa);
        }
    }, {
        key: "mapFlatMapCoherence",
        value: function mapFlatMapCoherence(fa, f) {
            var F = this.F;
            return Equiv.of(F.flatMap(fa, function (a) {
                return F.pure(f(a));
            }), F.map(fa, f));
        }
    }, {
        key: "tailRecMStackSafety",
        value: function tailRecMStackSafety() {
            var F = this.F;
            var n = 10000;
            var res = F.tailRecM(0, function (i) {
                return F.pure(i < n ? Left(i + 1) : Right(i));
            });
            return Equiv.of(res, F.pure(n));
        }
    }]);
    return MonadLaws;
}();
applyMixins(MonadLaws, [ApplicativeLaws, FlatMapLaws]);

var monadOf = getTypeClassInstance(Monad);

function monadLawsOf(instance) {
    return new (function (_MonadLaws) {
        inherits(_class2, _MonadLaws);

        function _class2() {
            classCallCheck(this, _class2);

            var _this9 = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));

            _this9.F = instance;
            return _this9;
        }

        return _class2;
    }(MonadLaws))();
}

var MonadError = function MonadError() {
    classCallCheck(this, MonadError);
};

MonadError._funTypeId = "monadError";

MonadError._funSupertypeIds = ["functor", "apply", "applicative", "monad", "applicativeError"];
applyMixins(MonadError, [Monad, ApplicativeError]);

var MonadErrorLaws = function () {
    function MonadErrorLaws() {
        classCallCheck(this, MonadErrorLaws);
    }

    createClass(MonadErrorLaws, [{
        key: "monadErrorLeftZero",
        value: function monadErrorLeftZero(e, f) {
            var F = this.F;
            return Equiv.of(F.flatMap(F.raise(e), f), F.raise(e));
        }
    }]);
    return MonadErrorLaws;
}();
applyMixins(MonadErrorLaws, [MonadLaws, ApplicativeErrorLaws]);

var monadErrorOf = getTypeClassInstance(MonadError);

function monadErrorLawsOf(instance) {
    return new (function (_MonadErrorLaws) {
        inherits(_class3, _MonadErrorLaws);

        function _class3() {
            classCallCheck(this, _class3);

            var _this10 = possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).apply(this, arguments));

            _this10.F = instance;
            return _this10;
        }

        return _class3;
    }(MonadErrorLaws))();
}

var Eval = function () {
    function Eval() {
        classCallCheck(this, Eval);
    }

    createClass(Eval, [{
        key: "get",
        value: function get$$1() {
            return this.run().get();
        }
    }, {
        key: "run",
        value: function run() {
            return evalRunLoop(this);
        }
    }, {
        key: "getOrElse",
        value: function getOrElse(fallback) {
            return this.run().getOrElse(fallback);
        }
    }, {
        key: "getOrElseL",
        value: function getOrElseL(thunk) {
            return this.run().getOrElseL(thunk);
        }
    }, {
        key: "map",
        value: function map(f) {
            return new FlatMap$1(this, function (a) {
                return Eval.now(f(a));
            });
        }
    }, {
        key: "flatMap",
        value: function flatMap(f) {
            return new FlatMap$1(this, f);
        }
    }, {
        key: "chain",
        value: function chain(f) {
            return this.flatMap(f);
        }
    }, {
        key: "transform",
        value: function transform(failure, success) {
            return this.transformWith(function (e) {
                return Eval.now(failure(e));
            }, function (a) {
                return Eval.now(success(a));
            });
        }
    }, {
        key: "transformWith",
        value: function transformWith(failure, success) {
            var f = function f(a) {
                return success(a);
            };
            f.onFailure = failure;
            return new FlatMap$1(this, f);
        }
    }, {
        key: "recover",
        value: function recover(f) {
            return this.recoverWith(function (a) {
                return Eval.now(f(a));
            });
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(f) {
            return this.transformWith(f, Eval.now);
        }
    }, {
        key: "attempt",
        value: function attempt() {
            return this.transform(function (_) {
                return Either.left(_);
            }, Either.right);
        }
    }, {
        key: "memoize",
        value: function memoize() {
            var _this = this;

            if (this instanceof Now || this instanceof Raise || this instanceof Once) {
                return this;
            } else if (this instanceof Always) {
                return new Once(this.thunk, false);
            } else {
                return new Once(function () {
                    return _this.get();
                }, false);
            }
        }
    }, {
        key: "memoizeOnSuccess",
        value: function memoizeOnSuccess() {
            var _this2 = this;

            if (this instanceof Now || this instanceof Raise || this instanceof Once) {
                return this;
            } else if (this instanceof Always) {
                return new Once(this.thunk, true);
            } else {
                return new Once(function () {
                    return _this2.get();
                }, true);
            }
        }
    }, {
        key: "forEachL",
        value: function forEachL(cb) {
            return this.map(cb);
        }
    }, {
        key: "forEach",
        value: function forEach(cb) {
            this.forEachL(cb).get();
        }
    }], [{
        key: "of",
        value: function of(thunk) {
            return Eval.always(thunk);
        }
    }, {
        key: "pure",
        value: function pure(value) {
            return Eval.now(value);
        }
    }, {
        key: "now",
        value: function now(value) {
            return new Now(value);
        }
    }, {
        key: "unit",
        value: function unit() {
            return evalUnitRef;
        }
    }, {
        key: "raise",
        value: function raise(e) {
            return new Raise(e);
        }
    }, {
        key: "always",
        value: function always(thunk) {
            return new Always(thunk);
        }
    }, {
        key: "once",
        value: function once(thunk) {
            return new Once(thunk, false);
        }
    }, {
        key: "suspend",
        value: function suspend(thunk) {
            return new Suspend(thunk);
        }
    }, {
        key: "defer",
        value: function defer(thunk) {
            return Eval.suspend(thunk);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            try {
                return f(a).flatMap(function (either) {
                    if (either.isRight()) {
                        return Eval.now(either.get());
                    } else {
                        return Eval.tailRecM(either.swap().get(), f);
                    }
                });
            } catch (e) {
                return Eval.raise(e);
            }
        }
    }]);
    return Eval;
}();

var Now = function (_Eval) {
    inherits(Now, _Eval);

    function Now(value) {
        classCallCheck(this, Now);

        var _this3 = possibleConstructorReturn(this, (Now.__proto__ || Object.getPrototypeOf(Now)).call(this));

        _this3.value = value;
        return _this3;
    }

    createClass(Now, [{
        key: "get",
        value: function get$$1() {
            return this.value;
        }
    }, {
        key: "run",
        value: function run() {
            return Try.success(this.value);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "Eval.now(" + JSON.stringify(this.value) + ")";
        }
    }]);
    return Now;
}(Eval);

var evalUnitRef = new Now(undefined);

var Raise = function (_Eval2) {
    inherits(Raise, _Eval2);

    function Raise(error) {
        classCallCheck(this, Raise);

        var _this4 = possibleConstructorReturn(this, (Raise.__proto__ || Object.getPrototypeOf(Raise)).call(this));

        _this4.error = error;
        return _this4;
    }

    createClass(Raise, [{
        key: "get",
        value: function get$$1() {
            throw this.error;
        }
    }, {
        key: "run",
        value: function run() {
            return Try.failure(this.error);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "Eval.raise(" + JSON.stringify(this.error) + ")";
        }
    }]);
    return Raise;
}(Eval);

var Once = function (_Eval3) {
    inherits(Once, _Eval3);

    function Once(thunk, onlyOnSuccess) {
        classCallCheck(this, Once);

        var _this5 = possibleConstructorReturn(this, (Once.__proto__ || Object.getPrototypeOf(Once)).call(this));

        _this5._thunk = thunk;
        _this5.onlyOnSuccess = onlyOnSuccess;
        return _this5;
    }

    createClass(Once, [{
        key: "run",
        value: function run() {
            if (this._thunk) {
                var result = Try.of(this._thunk);
                if (result.isSuccess() || !this.onlyOnSuccess) {
                    delete this._thunk;
                    delete this.onlyOnSuccess;
                    this.cache = result;
                }
                return result;
            }
            return this.cache;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "Eval.once([thunk])";
        }
    }]);
    return Once;
}(Eval);

var Always = function (_Eval4) {
    inherits(Always, _Eval4);

    function Always(thunk) {
        classCallCheck(this, Always);

        var _this6 = possibleConstructorReturn(this, (Always.__proto__ || Object.getPrototypeOf(Always)).call(this));

        _this6.thunk = thunk;
        return _this6;
    }

    createClass(Always, [{
        key: "run",
        value: function run() {
            return Try.of(this.thunk);
        }
    }, {
        key: "toString",
        value: function toString() {
            return "Eval.always([thunk])";
        }
    }]);
    return Always;
}(Eval);

var Suspend = function (_Eval5) {
    inherits(Suspend, _Eval5);

    function Suspend(thunk) {
        classCallCheck(this, Suspend);

        var _this7 = possibleConstructorReturn(this, (Suspend.__proto__ || Object.getPrototypeOf(Suspend)).call(this));

        _this7.thunk = thunk;
        return _this7;
    }

    createClass(Suspend, [{
        key: "toString",
        value: function toString() {
            return "Eval.suspend([thunk])";
        }
    }]);
    return Suspend;
}(Eval);

var FlatMap$1 = function (_Eval6) {
    inherits(FlatMap, _Eval6);

    function FlatMap(source, f) {
        classCallCheck(this, FlatMap);

        var _this8 = possibleConstructorReturn(this, (FlatMap.__proto__ || Object.getPrototypeOf(FlatMap)).call(this));

        _this8.source = source;
        _this8.f = f;
        return _this8;
    }

    createClass(FlatMap, [{
        key: "toString",
        value: function toString() {
            return "Eval#FlatMap(" + String(this.source) + ", [function])";
        }
    }]);
    return FlatMap;
}(Eval);

function _popNextBind(bFirst, bRest) {
    if (bFirst) return bFirst;
    if (bRest && bRest.length > 0) return bRest.pop();
    return null;
}

function _findErrorHandler(bFirst, bRest) {
    var cursor = bFirst;
    while (true) {
        if (cursor && typeof cursor.onFailure === "function") return cursor;
        if (bRest && bRest.length > 0) cursor = bRest.pop();else return null;
    }
}

function evalRunLoop(start) {
    var current = start;
    var bFirst = null;
    var bRest = null;
    while (true) {
        if (current instanceof Now) {
            var bind = _popNextBind(bFirst, bRest);
            if (!bind) return Try.success(current.value);
            bFirst = null;
            try {
                current = bind(current.value);
            } catch (e) {
                current = new Raise(e);
            }
        } else if (current instanceof Always) {
            try {
                current = new Now(current.thunk());
            } catch (e) {
                current = new Raise(e);
            }
        } else if (current instanceof Once) {
            try {
                current = new Now(current.get());
            } catch (e) {
                current = new Raise(e);
            }
        } else if (current instanceof Suspend) {
            try {
                current = current.thunk();
            } catch (e) {
                current = new Raise(e);
            }
        } else if (current instanceof FlatMap$1) {
            if (bFirst) {
                if (!bRest) bRest = [];
                bRest.push(bFirst);
            }
            bFirst = current.f;
            current = current.source;
        } else if (current instanceof Raise) {
            var _bind = _findErrorHandler(bFirst, bRest);
            if (!_bind) return Try.failure(current.error);
            bFirst = null;
            try {
                current = _bind.onFailure(current.error);
            } catch (e) {
                current = new Raise(e);
            }
        } else {
            throw new IllegalStateError("Types got screwed, Eval is a sealed trait, inheritance is forbidden");
        }
    }
}

var OptionInstances = function () {
    function OptionInstances() {
        classCallCheck(this, OptionInstances);

        this.__unit = Some(undefined);
    }

    createClass(OptionInstances, [{
        key: "eqv",
        value: function eqv(lh, rh) {
            return lh.equals(rh);
        }
    }, {
        key: "pure",
        value: function pure(a) {
            return Some(a);
        }
    }, {
        key: "unit",
        value: function unit() {
            return this.__unit;
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            return Option.map2(fa, ff, function (a, f) {
                return f(a);
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return fa.map(f);
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            return Option.map2(fa, fb, f);
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            return Option.map2(fa, fb, function (a, b) {
                return [a, b];
            });
        }
    }, {
        key: "flatMap",
        value: function flatMap(fa, f) {
            return fa.flatMap(f);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return Option.tailRecM(a, f);
        }
    }]);
    return OptionInstances;
}();
OptionInstances.global = new OptionInstances();

applyMixins(OptionInstances, [Monad]);

registerTypeClassInstance(Eq)(Option, OptionInstances.global);
registerTypeClassInstance(Monad)(Option, OptionInstances.global);

var TryInstances = function () {
    function TryInstances() {
        classCallCheck(this, TryInstances);

        this.__unit = Success(undefined);
    }

    createClass(TryInstances, [{
        key: "eqv",
        value: function eqv(lh, rh) {
            return lh.equals(rh);
        }
    }, {
        key: "pure",
        value: function pure(a) {
            return Success(a);
        }
    }, {
        key: "unit",
        value: function unit() {
            return Try.unit();
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            return Try.map2(fa, ff, function (a, f) {
                return f(a);
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return fa.map(f);
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            return Try.map2(fa, fb, f);
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            return Try.map2(fa, fb, function (a, b) {
                return [a, b];
            });
        }
    }, {
        key: "flatMap",
        value: function flatMap(fa, f) {
            return fa.flatMap(f);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return Try.tailRecM(a, f);
        }
    }, {
        key: "raise",
        value: function raise(e) {
            return Try.failure(e);
        }
    }, {
        key: "attempt",
        value: function attempt(fa) {
            return Try.success(fa.fold(function (e) {
                return Either.left(e);
            }, Either.right));
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(fa, f) {
            return fa.recoverWith(f);
        }
    }, {
        key: "recover",
        value: function recover(fa, f) {
            return fa.recover(f);
        }
    }]);
    return TryInstances;
}();
TryInstances.global = new TryInstances();

applyMixins(TryInstances, [MonadError]);

registerTypeClassInstance(Eq)(Try, TryInstances.global);
registerTypeClassInstance(MonadError)(Try, TryInstances.global);

var EitherInstances = function () {
    function EitherInstances() {
        classCallCheck(this, EitherInstances);

        this.__unit = Right(undefined);
    }

    createClass(EitherInstances, [{
        key: "eqv",
        value: function eqv(lh, rh) {
            return lh.equals(rh);
        }
    }, {
        key: "pure",
        value: function pure(a) {
            return Right(a);
        }
    }, {
        key: "unit",
        value: function unit() {
            return this.__unit;
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            var faE = fa;
            var ffE = ff;
            return Either.map2(faE, ffE, function (a, f) {
                return f(a);
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return fa.map(f);
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            return Either.map2(fa, fb, f);
        }
    }, {
        key: "product",
        value: function product(fa, fb) {
            return Either.map2(fa, fb, function (a, b) {
                return [a, b];
            });
        }
    }, {
        key: "flatMap",
        value: function flatMap(fa, f) {
            return fa.flatMap(f);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return Either.tailRecM(a, f);
        }
    }]);
    return EitherInstances;
}();
EitherInstances.global = new EitherInstances();

applyMixins(EitherInstances, [Monad]);

registerTypeClassInstance(Eq)(Either, EitherInstances.global);
registerTypeClassInstance(Monad)(Either, EitherInstances.global);

var EvalInstances = function () {
    function EvalInstances() {
        classCallCheck(this, EvalInstances);
    }

    createClass(EvalInstances, [{
        key: "pure",
        value: function pure(a) {
            return Eval.now(a);
        }
    }, {
        key: "flatMap",
        value: function flatMap(fa, f) {
            return fa.flatMap(f);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return Eval.tailRecM(a, f);
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            return fa.flatMap(function (a) {
                return ff.map(function (f) {
                    return f(a);
                });
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return fa.map(f);
        }
    }, {
        key: "unit",
        value: function unit() {
            return Eval.unit();
        }
    }, {
        key: "raise",
        value: function raise(e) {
            return Eval.raise(e);
        }
    }, {
        key: "attempt",
        value: function attempt(fa) {
            return fa.attempt();
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(fa, f) {
            return fa.recoverWith(f);
        }
    }, {
        key: "recover",
        value: function recover(fa, f) {
            return fa.recover(f);
        }
    }]);
    return EvalInstances;
}();
EvalInstances.global = new EvalInstances();

applyMixins(EvalInstances, [MonadError]);

registerTypeClassInstance(MonadError)(Eval, EvalInstances.global);

var FutureInstances = function () {
    function FutureInstances() {
        classCallCheck(this, FutureInstances);
    }

    createClass(FutureInstances, [{
        key: "pure",
        value: function pure(a) {
            return Future.pure(a);
        }
    }, {
        key: "flatMap",
        value: function flatMap(fa, f) {
            return fa.flatMap(f);
        }
    }, {
        key: "tailRecM",
        value: function tailRecM(a, f) {
            return Future.tailRecM(a, f);
        }
    }, {
        key: "ap",
        value: function ap(fa, ff) {
            return fa.flatMap(function (a) {
                return ff.map(function (f) {
                    return f(a);
                });
            });
        }
    }, {
        key: "map",
        value: function map(fa, f) {
            return fa.map(f);
        }
    }, {
        key: "unit",
        value: function unit() {
            return Future.unit();
        }
    }, {
        key: "raise",
        value: function raise(e) {
            return Future.raise(e);
        }
    }, {
        key: "attempt",
        value: function attempt(fa) {
            return fa.attempt();
        }
    }, {
        key: "recoverWith",
        value: function recoverWith(fa, f) {
            return fa.recoverWith(f);
        }
    }, {
        key: "recover",
        value: function recover(fa, f) {
            return fa.recover(f);
        }
    }, {
        key: "map2",
        value: function map2(fa, fb, f) {
            return Future.map2(fa, fb, f);
        }
    }]);
    return FutureInstances;
}();
FutureInstances.global = new FutureInstances();

applyMixins(FutureInstances, [MonadError]);

registerTypeClassInstance(MonadError)(Future, FutureInstances.global);

exports.isValueObject = isValueObject;
exports.is = is;
exports.equals = equals;
exports.hashCode = hashCode;
exports.hashCodeOfString = hashCodeOfString;
exports.id = id;
exports.applyMixins = applyMixins;
exports.CompositeError = CompositeError;
exports.DummyError = DummyError;
exports.NoSuchElementError = NoSuchElementError;
exports.IllegalInheritanceError = IllegalInheritanceError;
exports.IllegalStateError = IllegalStateError;
exports.IllegalArgumentError = IllegalArgumentError;
exports.NotImplementedError = NotImplementedError;
exports.TimeoutError = TimeoutError;
exports.Either = Either;
exports.Left = Left;
exports.Right = Right;
exports.Option = Option;
exports.Some = Some;
exports.None = None;
exports.Try = Try;
exports.Success = Success;
exports.Failure = Failure;
exports.Cancelable = Cancelable;
exports.BoolCancelable = BoolCancelable;
exports.AssignCancelable = AssignCancelable;
exports.MultiAssignCancelable = MultiAssignCancelable;
exports.SerialCancelable = SerialCancelable;
exports.SingleAssignCancelable = SingleAssignCancelable;
exports.TimeUnit = TimeUnit;
exports.NANOSECONDS = NANOSECONDS;
exports.MICROSECONDS = MICROSECONDS;
exports.MILLISECONDS = MILLISECONDS;
exports.SECONDS = SECONDS;
exports.MINUTES = MINUTES;
exports.HOURS = HOURS;
exports.DAYS = DAYS;
exports.Duration = Duration;
exports.Scheduler = Scheduler;
exports.GlobalScheduler = GlobalScheduler;
exports.TestScheduler = TestScheduler;
exports.DynamicRef = DynamicRef;
exports.Future = Future;
exports.Equiv = Equiv;
exports.registerTypeClassInstance = registerTypeClassInstance;
exports.getTypeClassInstance = getTypeClassInstance;
exports.Eq = Eq;
exports.EqLaws = EqLaws;
exports.eqOf = eqOf;
exports.eqLawsOf = eqLawsOf;
exports.Functor = Functor;
exports.FunctorLaws = FunctorLaws;
exports.functorOf = functorOf;
exports.functorLawsOf = functorLawsOf;
exports.Apply = Apply;
exports.ApplyLaws = ApplyLaws;
exports.applyOf = applyOf;
exports.applyLawsOf = applyLawsOf;
exports.Applicative = Applicative;
exports.ApplicativeLaws = ApplicativeLaws;
exports.applicativeOf = applicativeOf;
exports.applicativeLawsOf = applicativeLawsOf;
exports.ApplicativeError = ApplicativeError;
exports.ApplicativeErrorLaws = ApplicativeErrorLaws;
exports.applicativeErrorOf = applicativeErrorOf;
exports.applicativeErrorLawsOf = applicativeErrorLawsOf;
exports.FlatMap = FlatMap;
exports.FlatMapLaws = FlatMapLaws;
exports.flatMapOf = flatMapOf;
exports.flatMapLawsOf = flatMapLawsOf;
exports.Monad = Monad;
exports.MonadLaws = MonadLaws;
exports.monadOf = monadOf;
exports.monadLawsOf = monadLawsOf;
exports.MonadError = MonadError;
exports.MonadErrorLaws = MonadErrorLaws;
exports.monadErrorOf = monadErrorOf;
exports.monadErrorLawsOf = monadErrorLawsOf;
exports.OptionInstances = OptionInstances;
exports.TryInstances = TryInstances;
exports.EitherInstances = EitherInstances;
exports.EvalInstances = EvalInstances;
exports.FutureInstances = FutureInstances;
exports.Eval = Eval;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
