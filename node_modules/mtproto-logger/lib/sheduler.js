'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sheduler = exports.logStream = undefined;

var _eventemitter = require('eventemitter2');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _most = require('most');

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const emitter = new _eventemitter2.default();

const eventsHandler = queue => {
  const result = [];
  const ln = queue.length;
  for (let i = 0; i < ln; i++) {
    const qInstance = queue[i];
    const qLn = qInstance.length;
    for (let j = 0; j < qLn; j++) result.push(qInstance[j]);
  }
  return result;
};

const logStream = exports.logStream = (0, _most.fromEvent)('log', emitter).map(eventsHandler);
class LogEvent {
  constructor(log, values) {
    this.log = log;
    this.values = values;
  }
  print() {
    this.log(...this.values);
  }
}

const stringLimiting = str => typeof str === 'string' && str > 50 ? str.slice(0, 150) : str;

const normalizeVaules = list => {
  if (list.length === 0) return [' '];
  return list.map(stringLimiting);
};

const isSingleObject = results => results.length === 1 && typeof results[0] === 'object';

class Sheduler {

  constructor(sheduleInterval = 50, printInterval = 200) {
    this.queue = [];
    this.buffer = [];

    this.add = (log, time, tagStr, values) => {
      const results = normalizeVaules(values);
      if (isSingleObject(results)) results.unshift('%O');
      const firstLine = [tagStr, time].join('  ');

      this.buffer.push(new LogEvent(log, [firstLine]));
      this.buffer.push(new LogEvent(log, results));
    };

    this.sheduleBuffer = () => {
      this.queue.push(this.buffer);
      this.buffer = [];
    };

    this.print = () => {
      emitter.emit('log', this.queue);
      for (const buffer of this.queue) for (const logEvent of buffer) logEvent.print();
      this.queue = [];
    };

    setInterval(this.sheduleBuffer, sheduleInterval);
    setInterval(this.print, printInterval);
  }
}

exports.Sheduler = Sheduler;
const sheduler = new Sheduler();

exports.default = sheduler;
//# sourceMappingURL=sheduler.js.map